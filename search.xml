<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>二叉树总结</title>
    <url>/2020/09/27/LEBT10/</url>
    <content><![CDATA[<h1 id="二叉树总结"><a href="#二叉树总结" class="headerlink" title="二叉树总结"></a>二叉树总结</h1><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>LeetCode地址：<a href="https://leetcode-cn.com/leetbook/read/data-structure-binary-tree/x63shc/" target="_blank" rel="noopener">https://leetcode-cn.com/leetbook/read/data-structure-binary-tree/x63shc/</a></p>
<p>树 是一种经常用到的数据结构，用来模拟具有树状结构性质的数据集合。</p>
<p>树里的每一个节点有一个值和一个包含所有子节点的列表。从图的观点来看，树也可视为一个拥有N 个节点和N-1 条边的一个有向无环图。</p>
<p>二叉树是一种更为典型的树状结构。如它名字所描述的那样，二叉树是每个节点最多有两个子树的树结构，通常子树被称作“左子树”和“右子树”。</p>
<p>本章包含：</p>
<ul>
<li>掌握树和二叉树的概念</li>
<li>熟悉不同的<strong>遍历</strong>方法</li>
<li>运用<strong>递归</strong>解决二叉树相关题目</li>
</ul>
<h3 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h3><p>通过递归和迭代方法采用系统栈或者队列结构可对二叉树进行遍历。</p>
<p><a href="https://jq20.gitee.io/2020/09/21/LEBT1/" target="_blank" rel="noopener">二叉树遍历</a> <strong>递归框架、迭代框架</strong></p>
<ul>
<li>前序遍历 </li>
<li>中序遍历</li>
<li>后序遍历</li>
<li>层序遍历 <strong>队列，一层结点同时出栈</strong></li>
</ul>
<h2 id="运用递归解决问题"><a href="#运用递归解决问题" class="headerlink" title="运用递归解决问题"></a>运用递归解决问题</h2><ul>
<li><a href="https://jq20.gitee.io/2020/09/23/LEBT2/" target="_blank" rel="noopener">自顶向下和自底向上的递归方案</a> <strong>把握操作结点时机与返回值操作</strong></li>
<li>二叉树的最大深度  <strong>递归迭代比较左右子树最大值</strong></li>
<li><a href="https://jq20.gitee.io/2020/09/23/LEBT3/" target="_blank" rel="noopener">对称二叉树</a> <strong>递归 双指针</strong></li>
<li><a href="https://jq20.gitee.io/2020/09/23/LEBT4/" target="_blank" rel="noopener">路径总和</a> <strong>双队列 递归</strong></li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><p><a href="https://jq20.gitee.io/2020/09/24/LEBT5/" target="_blank" rel="noopener">从中序与后序/前序与中序遍历序列构造二叉树</a>  <strong>递归建树 掌握遍历中根节点与左右子树关系</strong></p>
</li>
<li><p><a href="https://jq20.gitee.io/2020/09/24/LEBT6/" target="_blank" rel="noopener">填充每个节点的下一个右侧节点指针</a> <strong>层次遍历</strong></p>
</li>
<li><p><a href="https://jq20.gitee.io/2020/09/27/LEBT7/" target="_blank" rel="noopener">二叉树的最近公共祖先</a>  <strong>递归比较情况</strong></p>
</li>
<li><p><a href="https://jq20.gitee.io/2020/09/27/LEBT9/" target="_blank" rel="noopener">二叉树的序列化与反序列化</a> <strong>DFS递归，掌握字符串特性与遍历特性</strong></p>
</li>
</ul>
<blockquote>
<p>文件名：LBT10</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCodeExplore</tag>
        <tag>LeetcodeExploreBT</tag>
      </tags>
  </entry>
  <entry>
    <title>链表总结</title>
    <url>/2020/09/07/LEL1/</url>
    <content><![CDATA[<h1 id="链表总结"><a href="#链表总结" class="headerlink" title="链表总结"></a>链表总结</h1><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>LeetCode地址：<a href="https://leetcode-cn.com/leetbook/read/linked-list/x6ybqh/" target="_blank" rel="noopener">https://leetcode-cn.com/leetbook/read/linked-list/x6ybqh/</a></p>
<p>在本 LeetBook 中，将介绍另一种数据结构 —— <code>链表</code>。</p>
<p>与数组相似，链表也是一种<code>线性</code>数据结构。</p>
<p>将了解：</p>
<ul>
<li>了解单链表和双链表的<strong>结构</strong>；</li>
<li>在单链表或双链表中实现<strong>遍历</strong>、插入和<strong>删除</strong>；</li>
<li>分析在单链表或双链表中的各种操作的<strong>复杂度</strong>；</li>
<li>在链表中使用双指针技巧（快指针慢指针技巧）；</li>
<li>解决一些经典问题，例如反转链表；</li>
<li>分析你设计的算法的复杂度；</li>
<li>积累设计和调试的经验。</li>
</ul>
<h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><ul>
<li><em><a href="https://jq20.gitee.io/2020/09/07/LEL2/" target="_blank" rel="noopener">设计链表</a></em>  <strong>构造 添加 删除  获取</strong></li>
</ul>
<h2 id="双指针技巧"><a href="#双指针技巧" class="headerlink" title="双指针技巧"></a>双指针技巧</h2><ul>
<li><a href="https://jq20.gitee.io/2020/09/09/LEL4/" target="_blank" rel="noopener">环形链表</a> <strong>HashSet 快慢双指针</strong></li>
<li><a href="https://jq20.gitee.io/2020/09/09/LEL4/" target="_blank" rel="noopener">相交链表</a>  <strong>HashSet 双指针 暴力</strong></li>
<li><a href="https://jq20.gitee.io/2020/09/09/LEL5/" target="_blank" rel="noopener">删除链表的倒数第N个节点</a> <strong>双指针</strong></li>
</ul>
<h2 id="经典问题"><a href="#经典问题" class="headerlink" title="经典问题"></a>经典问题</h2><ul>
<li><a href="https://jq20.gitee.io/2020/09/10/LEL6/" target="_blank" rel="noopener">反转链表</a> <strong>迭代 递归</strong></li>
<li><a href="https://jq20.gitee.io/2020/09/10/LEL6/" target="_blank" rel="noopener">移除链表元素</a> <strong>哨兵前置结点 递归</strong></li>
<li><a href="https://jq20.gitee.io/2020/09/10/LEL8/" target="_blank" rel="noopener">奇偶链表</a> 奇偶<strong>双指针拼接</strong>链表</li>
<li><a href="https://jq20.gitee.io/2020/09/10/LEL9/" target="_blank" rel="noopener">回文链表</a> <strong>数组双指针 递归</strong> <strong>改变表反转后部分比较</strong></li>
</ul>
<h2 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h2><ul>
<li>设计双链表 <strong>构造 添加 删除  获取</strong></li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><blockquote>
<p>如果你需要经常添加或删除结点，链表可能是一个不错的选择。</p>
<p>如果你需要经常按索引访问元素，数组可能是比链表更好的选择。</p>
<p><img src="/images/LEL1/screen-shot-2018-04-28-at-174531.png" alt="img"></p>
<p><img src="/images/LEL1/image-20200913220319984.png" alt="image-20200913220319984"></p>
</blockquote>
<ul>
<li><a href="https://jq20.gitee.io/2020/09/11/LEL10/" target="_blank" rel="noopener">合并两个有序链表</a> <strong>迭代 递归</strong></li>
<li><a href="https://jq20.gitee.io/2020/09/11/LEL11/" target="_blank" rel="noopener">两数相加</a> <strong>遍历设变量 递归</strong> </li>
<li><a href="https://jq20.gitee.io/2020/09/13/LEL12/" target="_blank" rel="noopener">扁平化多级双向链表</a> <strong>递归DFS</strong> <strong>栈迭代DFS</strong></li>
<li><a href="https://jq20.gitee.io/2020/09/13/LEL13/" target="_blank" rel="noopener">复制带随机指针的链表</a> <strong>递归回溯</strong> <strong>空间O(n)迭代</strong></li>
<li><a href="https://jq20.gitee.io/2020/09/13/LEL14/" target="_blank" rel="noopener">旋转链表</a> <strong>直觉成环断开</strong></li>
</ul>
<blockquote>
<p>文件名：LEL1</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCodeExplore</tag>
        <tag>LeetcodeExploreLL</tag>
      </tags>
  </entry>
  <entry>
    <title>队列和栈篇总结</title>
    <url>/2020/08/07/LEQS1/</url>
    <content><![CDATA[<h1 id="队列和栈篇总结"><a href="#队列和栈篇总结" class="headerlink" title="队列和栈篇总结"></a>队列和栈篇总结</h1><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>地址：<a href="https://leetcode-cn.com/leetbook/read/queue-stack/xkrhpg/" target="_blank" rel="noopener">https://leetcode-cn.com/leetbook/read/queue-stack/xkrhpg/</a></p>
<ul>
<li>队列：先进先出</li>
<li>栈：后入先出</li>
</ul>
<p>包含内容：</p>
<ol>
<li>FIFO 和 LIFO 处理顺序的原理；</li>
<li><strong>实现</strong>队列和栈数据结构；</li>
<li>熟悉<strong>内置</strong>的队列和栈结构；</li>
<li>解决基本的<strong>队列相关问题</strong>，尤其是 <strong>BFS</strong>；</li>
<li>解决基本的<strong>栈相关问题</strong>；</li>
<li>理解在使用 <strong>DFS</strong> 和其他 <strong>递归 算法</strong>来解决问题时，系统<strong>栈</strong>是如何发挥作用的。</li>
</ol>
<h2 id="队列：先入先出数据结构"><a href="#队列：先入先出数据结构" class="headerlink" title="队列：先入先出数据结构"></a>队列：先入先出数据结构</h2><ol>
<li><a href="https://jq20.gitee.io/2020/08/11/LEQS2/" target="_blank" rel="noopener">队列构造与内置函数</a>：<strong>Queue，Deque的常见用法</strong>,<strong>数组构建循环队列</strong></li>
</ol>
<h2 id="队列和广度优先搜索"><a href="#队列和广度优先搜索" class="headerlink" title="队列和广度优先搜索"></a>队列和广度优先搜索</h2><ol>
<li><a href="https://jq20.gitee.io/2020/08/23/LEQS3/" target="_blank" rel="noopener">转盘问题</a>之<strong>BFS解题框架</strong> , 双向BFS【坑】</li>
<li><a href="https://jq20.gitee.io/2020/08/23/LEQS5/" target="_blank" rel="noopener">岛屿数量</a>：<strong>BFS，DFS，并查集</strong>【坑】</li>
<li><a href="https://jq20.gitee.io/2020/08/11/LEQS4/" target="_blank" rel="noopener">完全平方数</a>：<strong>BFS+队列</strong></li>
</ol>
<h2 id="栈：后入先出的数据结构"><a href="#栈：后入先出的数据结构" class="headerlink" title="栈：后入先出的数据结构"></a>栈：后入先出的数据结构</h2><ol>
<li><a href="https://jq20.gitee.io/2020/08/26/LEQS6/" target="_blank" rel="noopener">最小栈</a>：<strong>java实现栈及常见用法</strong>，辅助栈，栈存差值</li>
<li><a href="https://jq20.gitee.io/2020/08/11/LEQS7/" target="_blank" rel="noopener">有效括号</a>：<strong>HashMap键值匹配用法</strong></li>
<li><a href="https://jq20.gitee.io/2020/08/30/LEQS8/" target="_blank" rel="noopener">每日温度</a>：单调栈</li>
<li><a href="https://jq20.gitee.io/2020/08/30/LEQS9/" target="_blank" rel="noopener">逆波兰表达式求值</a>：栈实现，数组实现栈</li>
</ol>
<h2 id="栈和深度优先搜索"><a href="#栈和深度优先搜索" class="headerlink" title="栈和深度优先搜索"></a>栈和深度优先搜索</h2><ol>
<li><a href="https://jq20.gitee.io/2020/08/31/LEQS10/" target="_blank" rel="noopener">克隆图</a>：<strong>DFS，BFS</strong></li>
<li><a href="https://jq20.gitee.io/2020/09/02/LEQS11/" target="_blank" rel="noopener">目标和</a>：<strong>递归栈，动态规划</strong>【坑】</li>
<li><a href="https://jq20.gitee.io/2020/09/02/LEQS12/" target="_blank" rel="noopener">二叉树的中序遍历</a>：栈</li>
</ol>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol>
<li><a href="https://jq20.gitee.io/2020/09/05/LEQS13/" target="_blank" rel="noopener">字符串解码</a>：栈，递归栈【坑】，<code>API String，Character，StringBuffer，LinkedList</code></li>
<li><a href="https://jq20.gitee.io/2020/09/05/LEQS14/" target="_blank" rel="noopener">图像渲染</a>：DFS，BFS【坑】</li>
<li><a href="https://jq20.gitee.io/2020/09/06/LEQS15/" target="_blank" rel="noopener">矩阵</a>：BFS</li>
<li><a href="https://jq20.gitee.io/2020/09/06/LEQS16/" target="_blank" rel="noopener">钥匙和房间</a>：BFS</li>
</ol>
<blockquote>
<p>文件名：LEQS1</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCodeExplore</tag>
        <tag>LeetcodeExploreQ&amp;S</tag>
      </tags>
  </entry>
  <entry>
    <title>数组和字符串篇总结</title>
    <url>/2020/08/18/LEAD13/</url>
    <content><![CDATA[<h1 id="数组和字符串篇总结"><a href="#数组和字符串篇总结" class="headerlink" title="数组和字符串篇总结"></a>数组和字符串篇总结</h1><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>地址：<a href="https://leetcode-cn.com/leetbook/detail/array-and-string/" target="_blank" rel="noopener">https://leetcode-cn.com/leetbook/detail/array-and-string/</a></p>
<p>本 LeetBook 中，介绍 <code>数组</code> 和 <code>字符串</code>。包含以下要点：</p>
<ul>
<li><strong>二维数组</strong>理解和使用</li>
<li><strong>字符串</strong>的理解和使用</li>
<li>选修：字符串匹配中<code>KMP算法</code></li>
<li><strong>双指针</strong>技巧</li>
</ul>
<h2 id="数组操作类型题"><a href="#数组操作类型题" class="headerlink" title="数组操作类型题"></a>数组操作类型题</h2><ol>
<li><a href="https://leetcode-cn.com/problems/find-pivot-index/" target="_blank" rel="noopener"><em>寻找数组中心索引 Easy</em></a></li>
<li><a href="https://leetcode-cn.com/problems/search-insert-position/solution/sou-suo-cha-ru-wei-zhi-by-leetcode-solution/" target="_blank" rel="noopener">搜索插入位置 Easy</a>  <strong>二分法</strong></li>
<li><a href="https://jq20.gitee.io/2020/06/08/LEA1/" target="_blank" rel="noopener">合并区间</a> <strong>数组排序，lambda表达式</strong></li>
</ol>
<h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><ol>
<li><a href="https://jq20.gitee.io/2020/06/11/LEA2/" target="_blank" rel="noopener">旋转矩阵</a>  <strong>转置矩阵思想</strong></li>
<li><a href="https://jq20.gitee.io/2020/06/11/LEA3/" target="_blank" rel="noopener">零矩阵</a> <strong>记录数组作用</strong></li>
<li><a href="https://jq20.gitee.io/2020/06/14/LEA4/" target="_blank" rel="noopener">对角线遍历</a>  <strong>简化问题；分情况奇偶</strong></li>
</ol>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ol>
<li><a href="https://jq20.gitee.io/2020/07/03/LEAS1/" target="_blank" rel="noopener">最长公共前缀</a>  <strong>二分法；分治[未更新]</strong></li>
<li><a href="https://jq20.gitee.io/2020/07/25/LEAS2/" target="_blank" rel="noopener">最长回文子串</a>  <strong>中心扩散法 ；双指针判断回文串</strong></li>
<li><a href="https://jq20.gitee.io/2020/08/04/LEAS3/" target="_blank" rel="noopener">翻转字符串里的单词</a>  <strong>字符串操作api；双指针处理字符串；StringBuilder</strong></li>
<li><a href="https://jq20.gitee.io/2020/08/07/LEAS4/" target="_blank" rel="noopener">KMP算法之“实现 strStr()”</a>  <strong>KMP算法；双指针；KMP之状态转换法;Sunday算法；逐一匹配</strong></li>
</ol>
<h2 id="双指针技巧"><a href="#双指针技巧" class="headerlink" title="双指针技巧"></a>双指针技巧</h2><ol>
<li><a href="https://jq20.gitee.io/2020/08/10/LEAD1/" target="_blank" rel="noopener">反转字符串</a></li>
<li><a href="https://jq20.gitee.io/2020/08/10/LEAD2/" target="_blank" rel="noopener">数组拆分</a></li>
<li><a href="https://jq20.gitee.io/2020/08/10/LEAD4/" target="_blank" rel="noopener">两数之和 II - 输入有序数组</a> </li>
<li><a href="https://jq20.gitee.io/2020/08/10/LEAD4/" target="_blank" rel="noopener">移除元素</a> </li>
<li><a href="https://jq20.gitee.io/2020/08/11/LEAD5/" target="_blank" rel="noopener">最大连续1的个数</a></li>
<li><a href="https://jq20.gitee.io/2020/08/12/LEAD8/" target="_blank" rel="noopener">长度最小的子数组</a>  <strong>灵活移动慢指针</strong></li>
</ol>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><ol>
<li><a href="https://jq20.gitee.io/2020/08/10/LEAD9/" target="_blank" rel="noopener">杨辉三角</a> <strong>动态规划；Arraylist使用</strong></li>
<li><a href="https://jq20.gitee.io/2020/08/14/LEAD7/" target="_blank" rel="noopener">杨辉三角 Ⅱ</a> </li>
<li><a href="https://jq20.gitee.io/2020/08/15/LEAD6/" target="_blank" rel="noopener">反转字符串中的单词 III</a> <strong>StringBuffer使用</strong></li>
<li><a href="https://jq20.gitee.io/2020/08/18/LEAD13/" target="_blank" rel="noopener">寻找旋转排列数组中的最小值</a> <strong>二分查找</strong></li>
<li><a href="https://jq20.gitee.io/2020/08/17/LEAD11/" target="_blank" rel="noopener">删除排序数组中的重复项</a>  <strong>双指针</strong></li>
<li><a href="https://jq20.gitee.io/2020/08/17/LEAD12/" target="_blank" rel="noopener">移动零</a> <strong>双指针</strong></li>
</ol>
<blockquote>
<p>文件名：LEAD13</p>
</blockquote>
<p>​                          </p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCodeExplore</tag>
        <tag>LeetcodeExploreA&amp;S</tag>
      </tags>
  </entry>
  <entry>
    <title>StudyNotesFromSasa(28-30/12/2020)</title>
    <url>/2020/12/29/StudyNotesFromSasa/</url>
    <content><![CDATA[<h1 id="StudyNotesFromSasa-28-30-12-2020"><a href="#StudyNotesFromSasa-28-30-12-2020" class="headerlink" title="StudyNotesFromSasa(28-30/12/2020)"></a>StudyNotesFromSasa(28-30/12/2020)</h1><h2 id="Key-module"><a href="#Key-module" class="headerlink" title="Key module"></a>Key module</h2><ul>
<li>picture slide board</li>
<li>hover menu</li>
<li>onlick menu</li>
<li>absolute layout</li>
<li>hover style change</li>
</ul>
<h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><h3 id="lt-a-target-quot-quot-Where-to-display-the-linked-URL"><a href="#lt-a-target-quot-quot-Where-to-display-the-linked-URL" class="headerlink" title="&lt;a target=&quot;&quot;  Where to display the linked URL"></a><code>&lt;a target=&quot;&quot;</code>  Where to display the linked URL</h3><p><code>_blank</code>: usually <strong>a new tab</strong>, but users can configure browsers to open a new window instead.</p>
<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><h3 id="alpha"><a href="#alpha" class="headerlink" title="alpha"></a><code>alpha</code></h3><p>alpha parameter defines the opacity</p>
<p>*<em>Difference  with opacity: *</em>The alpha channel can specifically set the transparency value for an attribute of the element</p>
<h3 id="opacity"><a href="#opacity" class="headerlink" title="opacity"></a><code>opacity</code></h3><p>The <strong><code>opacity</code></strong> CSS property sets the opacity of an element. Opacity is the degree to which content behind an element is hidden, and is the opposite of transparency.</p>
<h3 id="border-radius-achieve-round-control-bar"><a href="#border-radius-achieve-round-control-bar" class="headerlink" title="border-radius  achieve round control bar"></a><code>border-radius</code>  achieve round control bar</h3><p>make circular corners</p>
<h3 id="absolute-achieve-overlapping-images"><a href="#absolute-achieve-overlapping-images" class="headerlink" title="absolute achieve overlapping images"></a><code>absolute</code> achieve overlapping images</h3><h3 id="box-sizing-border-box-width-and-height-contain-any-border-and-padding"><a href="#box-sizing-border-box-width-and-height-contain-any-border-and-padding" class="headerlink" title="box-sizing: border-box  width and height contain any border and padding"></a><strong><code>box-sizing: border-box</code></strong>  width and height contain any border and padding</h3><p>The <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/width" target="_blank" rel="noopener"><code>width</code></a> and <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/height" target="_blank" rel="noopener"><code>height</code></a> properties include the content, padding, and border, but <strong>do not include the margin</strong>.</p>
<h3 id="input-focus"><a href="#input-focus" class="headerlink" title="input:focus"></a><code>input:focus</code></h3><p>change the style when focus</p>
<h3 id="width"><a href="#width" class="headerlink" title="width"></a><code>width</code></h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CSS"><figure class="iseeu highlight /css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">width</span>: <span class="selector-tag">calc</span>(100% <span class="selector-tag">-</span> 20<span class="selector-tag">px</span>);</span><br></pre></td></tr></table></figure></div>

<h3 id="transition-all-0-15s-linear-Change-the-button-colour-linearly"><a href="#transition-all-0-15s-linear-Change-the-button-colour-linearly" class="headerlink" title="transition: all 0.15s linear; Change the button colour linearly"></a><code>transition: all 0.15s linear;</code> Change the button colour linearly</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">transition: &lt;property&gt; &lt;duration&gt; &lt;timing-function&gt; &lt;delay&gt;;</span><br></pre></td></tr></table></figure></div>

<p>define the transition between two states of an element</p>
<h3 id="line-height-same-as-the-height-making-child-elements-Vertically-centered"><a href="#line-height-same-as-the-height-making-child-elements-Vertically-centered" class="headerlink" title="line-height : same as the height making child elements Vertically centered"></a><code>line-height</code> : same as the height making child elements Vertically centered</h3><ul>
<li>used to set the distance between lines of text</li>
<li>On block-level elements, it specifies the minimum height of line boxes within the element.</li>
</ul>
<h3 id="overflow-fit-in-its-block-formatting-context"><a href="#overflow-fit-in-its-block-formatting-context" class="headerlink" title="overflow  fit in its block formatting  context"></a><code>overflow</code>  fit in its block formatting  context</h3><h3 id="Padding"><a href="#Padding" class="headerlink" title="Padding"></a><code>Padding</code></h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CSS"><figure class="iseeu highlight /css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* vertical | horizontal */</span></span><br><span class="line"><span class="selector-tag">padding</span>: 5% 10%;</span><br></pre></td></tr></table></figure></div>

<h3 id="background-url-no-repeat-adding-image-in-lt-a-gt-by-adding-class-style"><a href="#background-url-no-repeat-adding-image-in-lt-a-gt-by-adding-class-style" class="headerlink" title="background: url() no-repeat   adding image  in  &lt;a&gt;  by adding class style"></a><code>background: url() no-repeat</code>   adding image  in  &lt;a&gt;  by adding class style</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;bg-layer&gt; = &lt;bg-image&gt; || &lt;repeat-style&gt; </span><br><span class="line"></span><br><span class="line">&lt;repeat-style&gt; = repeat-x | repeat-y | [ repeat | space | round | no-repeat ]&#123;1,2&#125;</span><br><span class="line">&lt;image&gt; = &lt;url&gt; | &lt;image()&gt; | &lt;image-set()&gt; | &lt;element()&gt; | &lt;paint()&gt; | &lt;cross-fade()&gt; | &lt;gradient&gt;</span><br></pre></td></tr></table></figure>

<h4 id="CSS-Selectors"><a href="#CSS-Selectors" class="headerlink" title="CSS Selectors"></a><a href="https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Selectors" target="_blank" rel="noopener">CSS Selectors</a></h4><ul>
<li><p><strong>descendant combinator</strong> &amp;&amp; <strong>Class selectors</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CSS"><figure class="iseeu highlight /css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.topbar_link_list</span> <span class="selector-tag">a</span><span class="selector-class">.divider</span> &#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">4px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>child combinator</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CSS"><figure class="iseeu highlight /css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.topbar_link_list</span> &gt; * &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>pseudo-classes</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CSS"><figure class="iseeu highlight /css"><table><tr><td class="code"><pre><span class="line">  // achieve hover trigger menu</span><br><span class="line">  <span class="selector-class">.topbar_wrapper</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  	<span class="attribute">color</span>: <span class="number">#fc2e7a</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">// creates a pseudo-element that is the last child of the selected element.</span><br><span class="line">  // used to realize line-through style</span><br><span class="line">  <span class="selector-class">.product_item_price_old</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">      <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">      <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">      <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#666</span>;</span><br><span class="line">      <span class="attribute">position</span>: absolute;</span><br><span class="line">      <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">      <span class="attribute">top</span>: <span class="number">10px</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div>



</li>
</ul>
<h3 id="inline-block-meaning"><a href="#inline-block-meaning" class="headerlink" title="inline-block meaning"></a><a href="https://zhuanlan.zhihu.com/p/31856017" target="_blank" rel="noopener"><code>inline-block</code> meaning</a></h3><ol>
<li><p><code>inline-block</code> working in block elements</p>
<p>Making elements show in one line  and still can <strong>set width and height</strong></p>
</li>
<li><p><code>inline-block</code> working in inline elements (&lt;span&gt;)</p>
<ul>
<li>still can <strong>set width and height</strong></li>
<li>inline alignment(text align way)</li>
</ul>
</li>
</ol>
<h3 id="border-achieve-arrow-style"><a href="#border-achieve-arrow-style" class="headerlink" title="border achieve arrow style"></a><code>border</code> achieve arrow style</h3><h3 id="outlines-never-take-up-space-differ-from-borders"><a href="#outlines-never-take-up-space-differ-from-borders" class="headerlink" title="outlines never take up space (differ from borders)"></a><code>outlines</code> never take up space (differ from borders)</h3><h3 id="positon-and-float"><a href="#positon-and-float" class="headerlink" title="positon and float"></a><code>positon</code> and <code>float</code></h3><ol>
<li><p>with <code>position: relative、float、（top / left / bottom / right）</code>simultaneously</p>
<p>float to the location and then move basing on <code>（top / left / bottom / right）</code></p>
</li>
<li><p>with <code>position: absolute and float</code></p>
<p><code>float</code> failure </p>
</li>
</ol>
<h3 id="Specificity-gt-style-priority"><a href="#Specificity-gt-style-priority" class="headerlink" title="Specificity  -&gt; style priority"></a><a href="https://www.w3.org/TR/selectors-3/#specificity" target="_blank" rel="noopener"><strong>Specificity</strong></a>  -&gt; style priority</h3><h4 id="a-selector’s-specificity"><a href="#a-selector’s-specificity" class="headerlink" title="a selector’s specificity"></a>a selector’s specificity</h4><p>A selector’s specificity is calculated as follows:</p>
<ul>
<li>count the number of <strong>ID selectors</strong> in the selector (= a)</li>
<li>count the number of <strong>class selectors, attributes selectors, and pseudo-classes</strong> in the selector (= b)</li>
<li>count the number of <strong>type selectors and pseudo-elements</strong> in the selector (= c)</li>
<li><strong>ignor</strong>e the universal selector(=d)</li>
</ul>
<h5 id="Example-in-Sasa"><a href="#Example-in-Sasa" class="headerlink" title="Example in Sasa"></a>Example in Sasa</h5><p>Based on the rule b,d <code>.category_expand_item a</code> has higher specificity</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span>&gt;</span><br><span class="line"><span class="comment">/* a=0 b=2 c=0 -&gt; specificity =   2 */</span></span><br><span class="line"><span class="selector-class">.category_expand_item</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#444</span>;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* a=0 b=1 c=0 -&gt; specificity =   1 */</span></span><br><span class="line"><span class="selector-class">.category_expand_column_container</span> * &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">12px</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">18px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">6px</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#999</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class="category_expand_item"&gt;</span><br><span class="line">...</span><br><span class="line">	&lt;div class="category_expand_column_container"&gt;</span><br><span class="line">		&lt;a&gt;日霜&lt;/a&gt; </span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">	</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<h4 id="important"><a href="#important" class="headerlink" title="!important"></a><code>!important</code></h4><p>this declaration <strong>overrides</strong> any other declarations</p>
<h3 id="z-index"><a href="#z-index" class="headerlink" title="z-index"></a><code>z-index</code></h3><p>sets the z-order of a <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/position" target="_blank" rel="noopener">positioned</a> element and its descendants or flex items.</p>
<h3 id="text-transform-uppercase"><a href="#text-transform-uppercase" class="headerlink" title="text-transform: uppercase"></a><code>text-transform: uppercase</code></h3><p>converts all characters to uppercase.</p>
<h2 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h2><h3 id="Set-Interval-timing-and-stop"><a href="#Set-Interval-timing-and-stop" class="headerlink" title="Set Interval timing and stop"></a>Set Interval timing and stop</h3><ul>
<li>setInterval  repeatedly calls a function with a fixed time delay between each call</li>
<li>clearInterval </li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// set Interval timing</span></span><br><span class="line">				<span class="keyword">var</span> looptimer = setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">					next_on = now_on + <span class="number">1</span>;</span><br><span class="line">					<span class="keyword">if</span> (next_on == pic_div.length) &#123;next_on = <span class="number">0</span>;&#125;</span><br><span class="line">					startrun(pic_div[now_on],<span class="number">0</span>);</span><br><span class="line">					startrun(pic_div[next_on],<span class="number">100</span>);</span><br><span class="line">					buttonOff(controlb_div[now_on]);</span><br><span class="line">					buttonOn(controlb_div[next_on]);</span><br><span class="line">					now_on = next_on;</span><br><span class="line">				&#125;,<span class="number">5000</span>);</span><br><span class="line"><span class="comment">//stop changing when the mouse is over the pic</span></span><br><span class="line">				pic.onmouseover = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">					clearInterval(looptimer);</span><br><span class="line">				&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>Achieve Gradient Change of image color</strong></li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">startrun</span>(<span class="params">obj, target</span>) </span>&#123;</span><br><span class="line">    clearInterval(obj.timer);</span><br><span class="line">    obj.timer = setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> speed = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &gt; obj.alpha) &#123;</span><br><span class="line">            speed = <span class="number">5</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            speed = <span class="number">-5</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (obj.alpha == target) &#123;</span><br><span class="line">            <span class="comment">//when the color back to the target, stop the loop</span></span><br><span class="line">            clearInterval(obj.timer);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            obj.alpha = obj.alpha + speed;</span><br><span class="line">            obj.style.filter = <span class="string">"alpha(opacity="</span> + obj.alpha + <span class="string">")"</span>;</span><br><span class="line">            obj.style.opacity = obj.alpha / <span class="number">100</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">30</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="Monitor-mouse"><a href="#Monitor-mouse" class="headerlink" title="Monitor mouse"></a>Monitor mouse</h3><ul>
<li>onmouseover</li>
<li>onmouseout</li>
</ul>
<h2 id="Other-Tips"><a href="#Other-Tips" class="headerlink" title="Other Tips"></a>Other Tips</h2><h3 id="margin-overflow"><a href="#margin-overflow" class="headerlink" title="margin overflow"></a>margin overflow</h3><p><strong>Problem</strong> ： big  blank block appears in the right border</p>
<p><strong>Solution</strong>： check the element with more width over the main border</p>
<h3 id="folding-css-code-as-region"><a href="#folding-css-code-as-region" class="headerlink" title="folding css code as region"></a>folding css code as region</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CSS"><figure class="iseeu highlight /css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* #region */</span></span><br><span class="line"><span class="comment">/* #endregion */</span></span><br></pre></td></tr></table></figure></div>



<blockquote>
<p>File name：StudyNotesFromSasa</p>
</blockquote>
]]></content>
      <categories>
        <category>RisksisStudy</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>Git常用操作</title>
    <url>/2020/10/10/Git/</url>
    <content><![CDATA[<h1 id="Git常用操作"><a href="#Git常用操作" class="headerlink" title="Git常用操作"></a>Git常用操作</h1><h2 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h2><h3 id="Create-a-new-local-repository"><a href="#Create-a-new-local-repository" class="headerlink" title="Create a new local repository."></a>Create a new local repository.</h3><p>Download your <code>lab4</code> sails system from our course room and open it with <strong>VSCode</strong>. Then, bring up the terminal.</p>
<p>Hit the following commands to set up a <strong>new local repository</strong> and also link it with a <strong>remote GitHub repo</strong>.</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">git init</span><br><span class="line">git remote add origin 👉https://the.remote.url.git👈 &lt;-- change this with your GitHub repo URL</span><br></pre></td></tr></table></figure></div>

<h2 id="删除默认origin-并添加"><a href="#删除默认origin-并添加" class="headerlink" title="删除默认origin 并添加"></a>删除默认origin 并添加</h2><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">git remote remove origin</span><br><span class="line">git remote add origin 👉correct https://the.remote.url.git👈</span><br></pre></td></tr></table></figure></div>

<h3 id="上传仓库到github"><a href="#上传仓库到github" class="headerlink" title="上传仓库到github"></a>上传仓库到github</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">"some changes"</span></span><br><span class="line">git push -u origin master</span><br><span class="line">Start mileston2;created user api,perfected models,added policies and encrypted password;altered bootstrap.js;added user view concluding login and signup page</span><br></pre></td></tr></table></figure></div>

<h2 id="配置账户名密码"><a href="#配置账户名密码" class="headerlink" title="配置账户名密码"></a>配置账户名密码</h2><p>After the terminal has been installed, run the following commands in the terminal to set up the <strong>username</strong> and <strong>email</strong>:</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">"👉Your name👈"</span></span><br><span class="line">git config --global user.email <span class="string">"👉Your Email👈"</span></span><br></pre></td></tr></table></figure></div>

<p>The <code>user.name</code> and <code>user.email</code> will be displayed on the Github commit page.</p>
<h2 id="github清除远程仓库"><a href="#github清除远程仓库" class="headerlink" title="github清除远程仓库"></a>github清除远程仓库</h2><ol>
<li><p>第一步，备份，留下readme和.git文件夹</p>
</li>
<li><p>执行命令</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">$ git add *   //把本地仓库的文件上传到缓存。</span><br><span class="line">$ git commit -m <span class="string">'del'</span>   //把第一步上传到缓存的东西上传到本地仓库，其中<span class="string">'del'</span>是操作标识，内容随便填就行。</span><br><span class="line">$ git push origin master   //把本地仓库的文件上传到远程仓库。</span><br></pre></td></tr></table></figure></div>

</li>
</ol>
<h2 id="本地新仓库提交远程已有仓库报错"><a href="#本地新仓库提交远程已有仓库报错" class="headerlink" title="本地新仓库提交远程已有仓库报错"></a>本地新仓库提交远程已有仓库报错</h2><p><a href="https://blog.csdn.net/zhangkui0418/article/details/82977519" target="_blank" rel="noopener">https://blog.csdn.net/zhangkui0418/article/details/82977519</a></p>
<h2 id="git查看远程仓库地址命令："><a href="#git查看远程仓库地址命令：" class="headerlink" title="git查看远程仓库地址命令："></a>git查看远程仓库地址命令：</h2><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure></div>

<p><a href="http://linjunzhu.github.io/blog/2014/10/24/git-resume/" target="_blank" rel="noopener">http://linjunzhu.github.io/blog/2014/10/24/git-resume/</a></p>
<blockquote>
<p>文件名：Git</p>
</blockquote>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>树的遍历</title>
    <url>/2020/09/21/LEBT1/</url>
    <content><![CDATA[<h1 id="题目：-树的遍历"><a href="#题目：-树的遍历" class="headerlink" title="题目： 树的遍历"></a>题目： <a href="https://leetcode-cn.com/leetbook/read/data-structure-binary-tree/xezko3/" target="_blank" rel="noopener">树的遍历</a></h1><h2 id="二叉树重要性"><a href="#二叉树重要性" class="headerlink" title="二叉树重要性"></a>二叉树重要性</h2><ol>
<li>回溯、动归、分治算法，其实都是树</li>
<li>快速排序就是个二叉树的前序遍历，归并排序就是个二叉树的后续遍历【坑】</li>
</ol>
<h2 id="写递归算法的秘诀"><a href="#写递归算法的秘诀" class="headerlink" title="写递归算法的秘诀"></a>写递归算法的秘诀</h2><ul>
<li><strong>写递归算法的关键是要明确函数的「定义」是什么，然后相信这个定义，利用这个定义推导最终结果，绝不要跳入递归的细节</strong>。</li>
</ul>
<h3 id="例题：计算一颗二叉树有多少结点"><a href="#例题：计算一颗二叉树有多少结点" class="headerlink" title="例题：计算一颗二叉树有多少结点"></a>例题：计算一颗二叉树有多少结点</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义：count(root) 返回以 root 为根的树有多少节点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 自己加上子树的节点数就是整棵树的节点数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + count(root.left) + count(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="要点："><a href="#要点：" class="headerlink" title="要点："></a>要点：</h3><ul>
<li><strong>写树相关的算法，简单说就是，先搞清楚当前</strong> <strong><code>root</code></strong> <strong>节点该做什么，然后根据函数定义递归调用子节点</strong>，递归调用会让孩子节点做相同的事情。</li>
</ul>
<h2 id="二叉树递归框架"><a href="#二叉树递归框架" class="headerlink" title="二叉树递归框架"></a>二叉树递归框架</h2><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 二叉树遍历框架 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 前序遍历</span></span><br><span class="line">    traverse(root.left)</span><br><span class="line">    <span class="comment">// 中序遍历</span></span><br><span class="line">    traverse(root.right)</span><br><span class="line">    <span class="comment">// 后序遍历</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="数据结构：LinkedList"><a href="#数据结构：LinkedList" class="headerlink" title="数据结构：LinkedList"></a>数据结构：LinkedList</h3><img src="/images/LEBT1/image-20201227143129804.png" alt="image-20201227143129804" style="zoom: 67%;" />

<ul>
<li>LinkedList 继承了 AbstractSequentialList 类。</li>
<li>LinkedList 实现了 <strong>Queue 接口</strong>，可作为队列使用。</li>
<li>LinkedList 实现了 <strong>List 接口</strong>，可进行列表的相关操作。</li>
<li>LinkedList 实现了 <strong>Deque 接口</strong>，可作为队列使用。</li>
<li>LinkedList 实现了 Cloneable 接口，可实现克隆。</li>
</ul>
<h4 id="重要方法-模拟栈"><a href="#重要方法-模拟栈" class="headerlink" title="重要方法: 模拟栈"></a>重要方法: 模拟栈</h4><table>
<thead>
<tr>
<th align="left">public boolean add(E e)/push()</th>
<th>链表末尾添加元素，返回是否成功，成功为 true，失败为 false。</th>
</tr>
</thead>
<tbody><tr>
<td align="left"></td>
<td>add(int index, E element)/addFirst(E e)/addLast(E e)</td>
</tr>
<tr>
<td align="left"><strong><a href="https://www.runoob.com/manual/jdk11api/java.base/java/util/LinkedList.html#pollLast()" target="_blank" rel="noopener">pollLast</a></strong>()/pop()</td>
<td>检索并删除此列表的<strong>最后一个元素</strong>，如果此列表为空，则返回 <code>null</code> 。</td>
</tr>
<tr>
<td align="left"></td>
<td><strong><a href="https://www.runoob.com/manual/jdk11api/java.base/java/util/LinkedList.html#pollFirst()" target="_blank" rel="noopener">pollFirst</a></strong>()/<strong><a href="https://www.runoob.com/manual/jdk11api/java.base/java/util/LinkedList.html#poll()" target="_blank" rel="noopener">poll</a></strong>()</td>
</tr>
<tr>
<td align="left">peekLast()</td>
<td>检索但不删除此列表的<strong>最后一个元素</strong>，如果此列表为空，则返回 <code>null</code> 。</td>
</tr>
<tr>
<td align="left"></td>
<td>peekFirst()/<strong><a href="https://www.runoob.com/manual/jdk11api/java.base/java/util/LinkedList.html#peek()" target="_blank" rel="noopener">peek</a></strong>()</td>
</tr>
</tbody></table>
<h2 id="二叉树迭代查询"><a href="#二叉树迭代查询" class="headerlink" title="二叉树迭代查询"></a>二叉树迭代查询</h2><h4 id="前序遍历："><a href="#前序遍历：" class="headerlink" title="前序遍历："></a>前序遍历：</h4><p>要点：</p>
<p>简单栈结构，直接按照 <code>Top-&gt;Bottom</code> 和 <code>Left-&gt;Right</code>压栈即可</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; output = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stack.add(root);</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">      TreeNode node = stack.pollLast();</span><br><span class="line">      output.add(node.val);</span><br><span class="line">      <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        stack.add(node.right);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        stack.add(node.left);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="中序遍历："><a href="#中序遍历：" class="headerlink" title="中序遍历："></a>中序遍历：</h4><p>要点：</p>
<p>左孩子最先出栈，两个while循环保证出栈顺序正确</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        Deque&lt;TreeNode&gt; stk = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="keyword">null</span> || !stk.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stk.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stk.pop();</span><br><span class="line">            res.add(root.val);</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="后序遍历："><a href="#后序遍历：" class="headerlink" title="后序遍历："></a>后序遍历：</h4><p>要点：</p>
<p>从下到上、从左至右，所以需要将输出列表逆序输出，即在加入结果集时逆序加入即可。</p>
<ul>
<li>更改左右，逆序</li>
</ul>
<p><strong>Tips：</strong></p>
<ul>
<li>必须创建LinkedList才能使用addFirst（）函数</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; output = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stack.add(root);</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">      TreeNode node = stack.pollLast();</span><br><span class="line">      output.addFirst(node.val);</span><br><span class="line">      <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        stack.add(node.left);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        stack.add(node.right);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="层次遍历：BFS-队列"><a href="#层次遍历：BFS-队列" class="headerlink" title="层次遍历：BFS 队列"></a>层次遍历：BFS 队列</h4><p>要点：记录队列一层节点数，获取数量，一口气出栈一层结点即可区分一层</p>
<ul>
<li>ArrayDeque继承虚拟集合类，add 尾部插入 poll 头部弹出删除</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 二叉树的层序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123; </span><br><span class="line">            <span class="comment">// 变量 i 无实际意义，只是为了循环 n 次</span></span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.add(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<blockquote>
<p>文件名：LBT1</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCodeExplore</tag>
        <tag>LeetcodeExploreBT</tag>
      </tags>
  </entry>
  <entry>
    <title>最小栈【Java栈实现方法】</title>
    <url>/2020/08/26/LEQS6/</url>
    <content><![CDATA[<h1 id="题目：-最小栈Easy【Java栈实现方法】"><a href="#题目：-最小栈Easy【Java栈实现方法】" class="headerlink" title="题目： 最小栈Easy【Java栈实现方法】"></a>题目：<a href="https://leetcode-cn.com/problems/min-stack/" target="_blank" rel="noopener"> 最小栈</a>Easy【Java栈实现方法】</h1><h1 id="Java实现栈：采用Deque替代Stack-或者LinkedList"><a href="#Java实现栈：采用Deque替代Stack-或者LinkedList" class="headerlink" title="Java实现栈：采用Deque替代Stack(或者LinkedList)"></a>Java实现栈：采用Deque替代Stack(或者LinkedList)</h1><p>Java的集合包中本身就有栈的实现Stack，如果看过API或者是源码就会知道Java中的Stack是线程安全的，所有对外暴露的操作都使用了synchronized关键字，即加了一个重锁。什么是重锁？重锁就是需要由用户态切换到核心态，由操作系统来进行线程的同步互斥管理。</p>
<p>所以一般在单线程情况下，没有必要使用Stack，可以使用<strong>Deque</strong>来替代。Deque中也实现了符合栈特性的<code>push(E e)和pop()</code>操作，但还有一点要注意的是，Deque实现的栈的栈顶是其首元素，即读取栈顶的元素应该使用<code>peekFirst()</code>。</p>
<p>Deque实现栈常用方法</p>
<ul>
<li><code>push(E e)</code></li>
<li><code>pop()</code></li>
<li><code>peekFirst()</code> </li>
<li><code>java.util.ArrayDeque.isEmpty()</code> 如果此双端队列不包含任何元素，则此方法返回true。</li>
<li><code>stack.size</code> 栈大小</li>
<li><img src="/images/LEQS6/image-20200903165956996.png" alt="image-20200903165956996"></li>
<li><img src="/images/LEQS6/image-20200905095336981.png" alt="image-20200905095336981"></li>
</ul>
<p>接着再总结一下，集合类中大致的操作规律：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>成功</th>
<th>失败</th>
</tr>
</thead>
<tbody><tr>
<td>remove</td>
<td>删除，并获取元素</td>
<td>抛出异常</td>
</tr>
<tr>
<td>poll</td>
<td>删除，并获取元素</td>
<td>返回null</td>
</tr>
<tr>
<td>get</td>
<td>获取元素</td>
<td>抛出异常</td>
</tr>
<tr>
<td>peek</td>
<td>获取元素</td>
<td>返回null</td>
</tr>
<tr>
<td>add</td>
<td>添加元素，返回true</td>
<td>返回false</td>
</tr>
</tbody></table>
<h3 id="解决方案一：辅助栈"><a href="#解决方案一：辅助栈" class="headerlink" title="解决方案一：辅助栈"></a>解决方案一：辅助栈</h3><h4 id="解题逻辑：辅助栈"><a href="#解题逻辑：辅助栈" class="headerlink" title="解题逻辑：辅助栈"></a><strong>解题逻辑</strong>：辅助栈</h4><ul>
<li><p>借用一个辅助栈<code>min_stack</code>，用于存获取<code>stack</code>中最小值。</p>
</li>
<li><img src="/images/LEQS6/28724fa9f92b6952f7fdaf8760edd1dea850b137c22df28751f1cdd4d2680992-155.gif" alt="155.gif" style="zoom:33%;" />

</li>
</ul>
<h4 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h4><h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Deque&lt;Integer&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Deque&lt;Integer&gt; minStack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        stack.push(x);</span><br><span class="line">        <span class="keyword">if</span> (minStack.isEmpty())</span><br><span class="line">            minStack.push(x);</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            minStack.push(Math.min(x, minStack.peekFirst()));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack.pop();</span><br><span class="line">        minStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.peekFirst();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minStack.peekFirst();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="tips"><a href="#tips" class="headerlink" title="tips:"></a>tips:</h4><ul>
<li>Java中的int是基本数据类型，没有继承自Object类，要存放整型数据必须使用整型的封装类</li>
</ul>
<h3 id="解决方案二：单栈存储插值"><a href="#解决方案二：单栈存储插值" class="headerlink" title="解决方案二：单栈存储插值"></a>解决方案二：单栈存储插值</h3><h4 id="解题逻辑：存储差值一个栈"><a href="#解题逻辑：存储差值一个栈" class="headerlink" title="解题逻辑：存储差值一个栈"></a><strong>解题逻辑</strong>：存储差值一个栈</h4><ul>
<li>每次存入的是 <code>原来值 - 当前最小值</code>。</li>
<li>当原来值大于等于当前最小值的时候，存入就是非负数，出栈的时候就是 <code>栈中的值 + 当前最小值</code> 。</li>
<li>当原来值小于当前最小值的时候，存入是负值，此时的值不入栈，用 <code>min</code> 保存起来，同时将差值入栈。</li>
<li>负数存入，后续通过计算可得到次最小值，依次可将各个阶段站内最小值记录</li>
</ul>
<h4 id="代码分析-1"><a href="#代码分析-1" class="headerlink" title="代码分析"></a>代码分析</h4><h4 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> min;</span><br><span class="line">	Stack&lt;Long&gt; stack;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span></span>&#123;</span><br><span class="line">        stack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">			min = x;</span><br><span class="line">			stack.push(x - min);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			stack.push(x - min);</span><br><span class="line">			<span class="keyword">if</span> (x &lt; min)&#123;</span><br><span class="line">				min = x; <span class="comment">// 更新最小值</span></span><br><span class="line">			&#125;</span><br><span class="line">				</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (stack.isEmpty())</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">long</span> pop = stack.pop();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//弹出的是负值，要更新 min</span></span><br><span class="line">		<span class="keyword">if</span> (pop &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			min = min - pop;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">long</span> top = stack.peek();</span><br><span class="line">		<span class="comment">//负数的话，出栈的值保存在 min 中</span></span><br><span class="line">		<span class="keyword">if</span> (top &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> (<span class="keyword">int</span>) (min);</span><br><span class="line">        <span class="comment">//出栈元素加上最小值即可</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> (<span class="keyword">int</span>) (top + min);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (<span class="keyword">int</span>) min;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="tips-1"><a href="#tips-1" class="headerlink" title="tips:"></a>tips:</h4><ul>
<li>上边的解法的一个缺点就是由于我们保存的是差值，所以可能造成溢出，所以我们用了数据范围更大的 <code>long</code> 类型。</li>
</ul>
<blockquote>
<p>文件名：LEQS6</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCodeExplore</tag>
        <tag>LeetcodeExploreQ&amp;S</tag>
      </tags>
  </entry>
  <entry>
    <title>反转字符串中单词 Ⅲ</title>
    <url>/2020/08/15/LEAD6/</url>
    <content><![CDATA[<h1 id="题目：-反转字符串中单词-Ⅲ-Easy"><a href="#题目：-反转字符串中单词-Ⅲ-Easy" class="headerlink" title="题目： 反转字符串中单词 Ⅲ   Easy"></a>题目： 反转字符串中单词 Ⅲ   Easy</h1><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><ol>
<li><a href="https://blog.csdn.net/qq_41986648/article/details/104562459" target="_blank" rel="noopener"><em>StringBuffer使用详解</em></a></li>
</ol>
<h2 id="2-学习题解代码"><a href="#2-学习题解代码" class="headerlink" title="2.学习题解代码"></a>2.学习题解代码</h2><h3 id="解决方案一"><a href="#解决方案一" class="headerlink" title="解决方案一"></a>解决方案一</h3><h4 id="解题逻辑：Stringbuffer-API"><a href="#解题逻辑：Stringbuffer-API" class="headerlink" title="解题逻辑：Stringbuffer API"></a><strong>解题逻辑</strong>：Stringbuffer API</h4><h4 id="代码分析："><a href="#代码分析：" class="headerlink" title="代码分析："></a>代码分析：</h4><h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseWorlds</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        String[] words = s.split(<span class="string">" "</span>);</span><br><span class="line">        StringBuffer res = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">for</span>(String word : words)&#123;</span><br><span class="line">            res.append(<span class="keyword">new</span> StringBuffer(word).reverse().toString() + <span class="string">" "</span>);     </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString().trim();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="解决方案二"><a href="#解决方案二" class="headerlink" title="解决方案二"></a>解决方案二</h3><h4 id="解题逻辑：Stringbuffer-手动实现split-和reverse函数"><a href="#解题逻辑：Stringbuffer-手动实现split-和reverse函数" class="headerlink" title="解题逻辑：Stringbuffer  手动实现split 和reverse函数"></a><strong>解题逻辑</strong>：Stringbuffer  手动实现split 和reverse函数</h4><h4 id="代码分析：-1"><a href="#代码分析：-1" class="headerlink" title="代码分析："></a>代码分析：</h4><h4 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseWorlds</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        String[] words = s.split(<span class="string">" "</span>);</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(String word : words)&#123;</span><br><span class="line">            res.append( reverse(word) + <span class="string">" "</span>);     </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString().trim();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String[] split(String s)&#123;</span><br><span class="line">        ArrayList &lt;String&gt; words = <span class="keyword">new</span> ArrayList&lt;&gt;&#123;&#125;;</span><br><span class="line">        StringBuilder word = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == <span class="string">" "</span>)&#123;</span><br><span class="line">				words.add(word.toString());</span><br><span class="line">                word = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                word.append(s.charAt(i));            </span><br><span class="line">        &#125;</span><br><span class="line">        words.add(word.toString());</span><br><span class="line">        <span class="keyword">return</span> words.toArray(<span class="keyword">new</span> String[words.size()]) <span class="comment">//集合转为数组</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverse</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            res.insert(<span class="number">0</span>,s.charAt(i)) <span class="comment">//插入实现倒叙</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="Tips"><a href="#Tips" class="headerlink" title="Tips:"></a>Tips:</h4><ul>
<li><p>List.toArray(T[] a) 集合转数组<a href="https://blog.csdn.net/startyangu/article/details/81013681" target="_blank" rel="noopener">方法</a></p>
<p>//转换过来的数组赋值给a</p>
</li>
<li><p>巧妙采用 StringBuilder.insert(int index, Everything)实现倒叙，冒泡插入</p>
</li>
<li><p>word.setLength(0) //清空方法，清空StringBuilder</p>
</li>
</ul>
<blockquote>
<p>文件名：LEAD6</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCodeExplore</tag>
        <tag>LeetcodeExploreA&amp;S</tag>
      </tags>
  </entry>
  <entry>
    <title>SingletonPattern</title>
    <url>/2020/12/23/SingletonPattern/</url>
    <content><![CDATA[<h1 id="单例模式-Singleton-Pattern"><a href="#单例模式-Singleton-Pattern" class="headerlink" title="单例模式 Singleton Pattern"></a>单例模式 Singleton Pattern</h1><p>特点：</p>
<ul>
<li>只能有一个实例且是自己创建自己的</li>
<li>不能被其他类实例化</li>
</ul>
<p>功能：</p>
<ul>
<li><strong>意图：</strong>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</li>
<li><strong>主要解决：</strong>一个全局使用的类频繁地创建与销毁。</li>
<li><strong>何时使用：</strong>当您想控制实例数目，节省系统资源的时候。</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li>1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。</li>
<li>2、避免对资源的多重占用（比如写文件操作）。</li>
</ul>
<p><strong>缺点：</strong>没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</p>
<h2 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a><strong>懒汉式</strong></h2><p>如果一个对象使用频率不高，占用内存还特别大，明显就不合适用饿汉式了，这时就需要一种<strong>懒加载</strong>的思想，当程序<strong>需要这个实例</strong>的时候才去<strong>创建</strong>对象，就如同一个人懒的饿到不行了才去吃东西。</p>
<h3 id="线程是否安全在于是否加锁-synchronized"><a href="#线程是否安全在于是否加锁-synchronized" class="headerlink" title="线程是否安全在于是否加锁 synchronized"></a>线程是否安全在于是否加锁 <strong>synchronized</strong></h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance; </span><br><span class="line">    <span class="comment">//让构造函数private 这样该类就不能被实例化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="comment">// synchronized 无锁就不安全</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="饿汉式-线程安全耗费资源（一般）"><a href="#饿汉式-线程安全耗费资源（一般）" class="headerlink" title="饿汉式: 线程安全耗费资源（一般）"></a>饿汉式: 线程安全耗费资源（一般）</h2><p>不管程序是否需要这个对象的实例，总是在<strong>类加载的时候</strong>就<strong>先创建好实例</strong>，理解起来就像不管一个人想不想吃东西都把吃的先买好，如同饿怕了一样。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//预先实例化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    	<span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="双检锁-双重校验锁（DCL，即-double-checked-locking）"><a href="#双检锁-双重校验锁（DCL，即-double-checked-locking）" class="headerlink" title="双检锁/双重校验锁（DCL，即 double-checked locking）"></a>双检锁/双重校验锁（DCL，即 double-checked locking）</h2><p>先判断对象是否已经被初始化，再决定要不要加锁。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;  </span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">                singleton = <span class="keyword">new</span> Singleton();  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">    	&#125;  </span><br><span class="line">    	<span class="keyword">return</span> singleton;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>volatile  避免编译器重排序问题，所有的写（write）操作都将发生在读（read）操作之前。</li>
</ul>
<h2 id="登记式-静态内部类（推荐）"><a href="#登记式-静态内部类（推荐）" class="headerlink" title="登记式/静态内部类（推荐）"></a><a href="https://blog.csdn.net/mnb65482/article/details/80458571" target="_blank" rel="noopener">登记式/静态内部类（推荐）</a></h2><p>这种方式同样利用了 classloader 机制来保证初始化 instance 时只有一个线程</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;  </span><br><span class="line">   		<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    	<span class="keyword">return</span> SingletonHolder.INSTANCE;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>优点：</p>
<p>外部类加载时并不需要立即加载内部类，内部类<strong>不被加载则不去初始化</strong>INSTANCE，故而不占内存。</p>
<p>当getInstance()方法第一次被调用时，才会去初始化INSTANCE,第一次调用getInstance()方法会导致虚拟机加载SingleTonHoler类，这种方法不仅能确保线程安全，也能保证单例的唯一性，同时也延迟了单例的实例化。</p>
<h2 id="线程安全的懒汉式：枚举"><a href="#线程安全的懒汉式：枚举" class="headerlink" title="线程安全的懒汉式：枚举"></a>线程安全的懒汉式：枚举</h2><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">7.线程安全的懒汉式：枚举</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">enum</span> Singleton5 &#123;</span><br><span class="line">	INSTANCE;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whateverMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



]]></content>
      <categories>
        <category>SwordOffer</category>
      </categories>
      <tags>
        <tag>DesignModel</tag>
        <tag>SwordOffer</tag>
      </tags>
  </entry>
  <entry>
    <title>MailChimp</title>
    <url>/2020/11/07/MailChimp/</url>
    <content><![CDATA[<ul>
<li>[Grammar and Mechanics</li>
</ul>
<p><img src="../images/MailChimp/image-20201107111636972.png" alt="image-20201107111636972"></p>
<p><img src="../images/MailChimp/image-20201107112138082.png" alt="image-20201107112138082"></p>
<p><img src="../images/MailChimp/image-20201107112218253.png" alt="image-20201107112218253"></p>
<ul>
<li><a href="https://styleguide.mailchimp.com/writing-about-people/" target="_blank" rel="noopener">Writing About People</a></li>
</ul>
<p><img src="../images/MailChimp/image-20201107114117923.png" alt="image-20201107114117923"></p>
]]></content>
  </entry>
  <entry>
    <title>大数据基础理论</title>
    <url>/2020/10/04/Backtrack/</url>
    <content><![CDATA[<h1 id="大数据基础理论"><a href="#大数据基础理论" class="headerlink" title="大数据基础理论"></a>大数据基础理论</h1><h2 id="三次信息化浪潮"><a href="#三次信息化浪潮" class="headerlink" title="三次信息化浪潮"></a>三次信息化浪潮</h2><p><img src="/images/BigDataBasic/image-20201004120921885.png" alt="image-20201004120921885"></p>
<p>大数据影响：</p>
<ul>
<li><p>全样非抽样</p>
</li>
<li><p>效率非精准：不存在误差放大问题，关注数据时效性</p>
</li>
<li><p>相关非因果：关联存在，不考虑为什么，相关性重要。买书，关注买了，但为什么不用管</p>
</li>
</ul>
<h1 id="ubuntu使用"><a href="#ubuntu使用" class="headerlink" title="ubuntu使用"></a>ubuntu使用</h1><p>采用云主机，远程连接密码：Jsq123,实例密码19980810sqSQ</p>
<p>注销当前用户 logout</p>
<p>创建hadoop用户密码hadoop</p>
<p>安装wget</p>
<p>rm 删除文件</p>
<p>cd .. 返回上一层</p>
<p>cd / 返回根目录</p>
<h1 id="vim使用操作"><a href="#vim使用操作" class="headerlink" title="vim使用操作"></a>vim使用操作</h1><p>：wq</p>
<p>:q!</p>
<p>esc</p>
<h1 id="hadoop安装"><a href="#hadoop安装" class="headerlink" title="hadoop安装"></a>hadoop安装</h1><p><img src="/images/BigDataBasic/image-20201004173851532.png" alt="image-20201004173851532"></p>
<p>解压handoop sudo tar -zxf/hadoop-2 77.tar.gz -C/usr/local    </p>
<h1 id="伪分布式安装"><a href="#伪分布式安装" class="headerlink" title="伪分布式安装"></a>伪分布式安装</h1><p>名称结点和数据结点放在一个节点上</p>
<p>gedit 需要gui</p>
<h1 id="Hadoop集群部署与使用"><a href="#Hadoop集群部署与使用" class="headerlink" title="Hadoop集群部署与使用"></a>Hadoop集群部署与使用</h1><p>namenode 目录服务器</p>
<blockquote>
<p>文件名：BigDataBasic</p>
</blockquote>
]]></content>
      <categories>
        <category>BigData</category>
      </categories>
  </entry>
  <entry>
    <title>快捷键</title>
    <url>/2020/07/03/Shortcuts/</url>
    <content><![CDATA[<h1 id="IntelliJ-快捷键"><a href="#IntelliJ-快捷键" class="headerlink" title="IntelliJ 快捷键"></a>IntelliJ 快捷键</h1><p><code>System.out.println（）</code> —— <strong>sout + Enter</strong></p>
<p><code>System.out.println（&quot;方法 &quot; + 参数）</code> —— <strong>soutv + Enter</strong></p>
<p><code>public static void main(String[]args){ }</code>——<strong>psvm + enter</strong></p>
<p><code>for (int i = 0; i &lt; ; i++) { }</code>—<strong>fori + enter</strong></p>
<p><code>选中该行可选择包围该行的形式</code> —— <strong>ctri+alt+t</strong></p>
<hr>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">alt+/提示补全</span><br><span class="line">ctrl+/ 单行注释</span><br><span class="line">ctrl+d 复制一行</span><br><span class="line">      ctrl + y删除一行</span><br><span class="line">      alt+down 光标向下移动一个方法</span><br><span class="line">alt+up 光标向上移动一个方法</span><br><span class="line">      </span><br><span class="line">	</span><br><span class="line">shift+enter 向下开始新的一行</span><br><span class="line">ctrl+shift+enter 向上开始新的一行</span><br><span class="line"></span><br><span class="line">alt+left 退回到前一个编辑界面</span><br><span class="line">alt+right 进入到下一个编辑的界面</span><br><span class="line">f4 查看继承关系</span><br><span class="line">ctrl+shift+f 格式化代码</span><br><span class="line">ctrl+alt+/ 提示方法参数类型</span><br><span class="line"></span><br><span class="line">ctrl+y 反撤销</span><br><span class="line">ctrl+x 剪切</span><br><span class="line">	</span><br><span class="line">tab 选中数行，整体往后移动</span><br><span class="line">shift+tab 选中数行，整体向前移动</span><br><span class="line"></span><br><span class="line">ctrl+shift+y 大写转换为小写/小写转换为大写</span><br><span class="line">alt+shift+s 快速生成get set方法 可按住shift进行多选</span><br><span class="line">f2查看文档说明</span><br><span class="line">alt+shift+c 收起所有方法</span><br><span class="line">alt+shift+x打开所有方法</span><br><span class="line">ctrl+shift+x 打开代码所在的硬盘文件夹</span><br><span class="line">alt+shift+z 生成<span class="keyword">try</span>-catch</span><br><span class="line">alt+shift+f 局部变量抽取为成员变量</span><br><span class="line">ctrl+f 查找(代码)</span><br><span class="line">ctrl+h 查找(全局)</span><br><span class="line">双击shift 查找文件</span><br><span class="line">alt+shift+m 抽取方法</span><br><span class="line"></span><br><span class="line">ctrl+e 打开module setting窗口</span><br><span class="line">ctrl+w 关闭当前打开的代码栏</span><br><span class="line">ctrl+shift+w 关闭打开的所有代码栏</span><br><span class="line">ctrl+shift+q 快速搜索类中的错误</span><br><span class="line">ctrl+shift+v 选择要粘贴的内容</span><br><span class="line">ctrl+shift+h 查找方法在哪里被调用</span><br><span class="line">ctrl+alt+h 查看方法的多层重写结构</span><br></pre></td></tr></table></figure></div>

<h1 id="VSCode-快捷键"><a href="#VSCode-快捷键" class="headerlink" title="VSCode 快捷键"></a>VSCode 快捷键</h1><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="code"><pre><span class="line"> ctrl + shift + K   //删除一行</span><br><span class="line"> ！ + enter         //快速创建HTML标准格式的代码   </span><br><span class="line">ctrl + space 更改为 alt + /    // trigger suggest</span><br><span class="line">ctrl + `  //调出终端</span><br><span class="line">shift+alut+↓ //向下复制一行</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>快捷键</category>
      </categories>
  </entry>
  <entry>
    <title>Model</title>
    <url>/2020/10/03/LEBST9/</url>
    <content><![CDATA[<h1 id="题目：-名字-Easy-Medium-Hard"><a href="#题目：-名字-Easy-Medium-Hard" class="headerlink" title="题目： 名字   Easy/Medium/Hard"></a>题目： 名字   Easy/Medium/Hard</h1><h2 id="1-自己构思"><a href="#1-自己构思" class="headerlink" title="1.自己构思"></a>1.自己构思</h2><h3 id="出现问题："><a href="#出现问题：" class="headerlink" title="出现问题："></a>出现问题：</h3><ol>
<li><h3 id="问题解决："><a href="#问题解决：" class="headerlink" title="问题解决："></a>问题解决：</h3></li>
<li></li>
</ol>
<h2 id="2-学习题解代码"><a href="#2-学习题解代码" class="headerlink" title="2.学习题解代码"></a>2.学习题解代码</h2><h3 id="解决方案一"><a href="#解决方案一" class="headerlink" title="解决方案一"></a>解决方案一</h3><h4 id="解题逻辑："><a href="#解题逻辑：" class="headerlink" title="解题逻辑："></a><strong>解题逻辑</strong>：</h4><ul>
<li></li>
</ul>
<h4 id="代码分析："><a href="#代码分析：" class="headerlink" title="代码分析："></a>代码分析：</h4><h4 id="解决自己问题："><a href="#解决自己问题：" class="headerlink" title="解决自己问题："></a>解决自己问题：</h4><ul>
<li><h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4></li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>



<h4 id="tips"><a href="#tips" class="headerlink" title="tips:"></a>tips:</h4><ul>
<li><h3 id="解决方案二"><a href="#解决方案二" class="headerlink" title="解决方案二"></a>解决方案二</h3></li>
</ul>
<h4 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="解决方案三"><a href="#解决方案三" class="headerlink" title="解决方案三"></a>解决方案三</h3><blockquote>
<p>文件名：LBST</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCodeExplore</tag>
        <tag>LeetcodeExploreBST</tag>
      </tags>
  </entry>
  <entry>
    <title>数据流中的第K大元素</title>
    <url>/2020/10/03/LEBST8/</url>
    <content><![CDATA[<h1 id="题目：-数据流中的第K大元素-Easy"><a href="#题目：-数据流中的第K大元素-Easy" class="headerlink" title="题目： 数据流中的第K大元素   Easy"></a>题目： <a href="https://leetcode-cn.com/problems/kth-largest-element-in-a-stream/" target="_blank" rel="noopener">数据流中的第K大元素</a>   Easy</h1><h3 id="解决方案一：二叉搜索树，熟悉插入与查询操作"><a href="#解决方案一：二叉搜索树，熟悉插入与查询操作" class="headerlink" title="解决方案一：二叉搜索树，熟悉插入与查询操作"></a>解决方案一：二叉搜索树，熟悉插入与查询操作</h3><h4 id="解题逻辑："><a href="#解题逻辑：" class="headerlink" title="解题逻辑："></a><strong>解题逻辑</strong>：</h4><ul>
<li><p>我们知道，对于二叉搜索树的每个节点来说，它的左子树上所有结点的值均小于它的根结点的值，右子树上所有结点的值均大于它的根结点的值。</p>
<p>换言之，对于二叉搜索树的每个节点来说，若其左子树共有m个节点，那么该节点是组成二叉搜索树的有序数组中第m + 1个值。</p>
</li>
</ul>
<h4 id="代码分析："><a href="#代码分析：" class="headerlink" title="代码分析："></a>代码分析：</h4><ul>
<li>核心就是记录着当前节点下所有节点树的count搭配左右子树的count可以清楚判断出有序情况下当前结点的位置</li>
<li>以及左右子树表明下一步查询或者插入操作的路径，类似二分搜索的对半分查询方法</li>
</ul>
<h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KthLargestKthLargest</span> 的成员变量 </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//定义二叉搜索的内部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">BST</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">int</span> val;</span><br><span class="line">            <span class="comment">//重复情况不生成结点，增加当前结点的值即可，当前结点重复数量可由结点值减去左右子树结点的值得到</span></span><br><span class="line">            <span class="comment">// 结点的count包含自己，所以默认是1</span></span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">private</span> TreeNode left;</span><br><span class="line">            <span class="keyword">private</span> TreeNode right;</span><br><span class="line">            </span><br><span class="line">            TreeNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//搜索树的根节点</span></span><br><span class="line">        <span class="keyword">private</span> TreeNode root;</span><br><span class="line">        <span class="comment">//add入口</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">            root = add(root, val);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//search入口</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> TreeNode <span class="title">search</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> search(root, k);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//当前结点的count记录了以自己为根的树下一共有多少数</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> TreeNode <span class="title">add</span><span class="params">(TreeNode node, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.val &gt; val) &#123;</span><br><span class="line">                node.left = add(node.left, val);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.val &lt; val) &#123;</span><br><span class="line">                node.right = add(node.right, val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 元素重复 不添加进树但是count++</span></span><br><span class="line">            node.count++;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回找到的结点</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> TreeNode <span class="title">search</span><span class="params">(TreeNode node, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> leftNodeCount = node.left != <span class="keyword">null</span> ? node.left.count : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> rightNodeCount = node.right != <span class="keyword">null</span> ? node.right.count : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> currNodeCount = node.count - leftNodeCount - rightNodeCount;</span><br><span class="line">            <span class="keyword">if</span> (k &gt; currNodeCount + rightNodeCount ) &#123;</span><br><span class="line">                <span class="comment">// k &gt; 当前结点数加右子树的结点数，则搜索左子树</span></span><br><span class="line">                <span class="keyword">return</span> search(node.left, k - currNodeCount - rightNodeCount);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k &lt;= rightNodeCount) &#123;</span><br><span class="line">                <span class="comment">// k &lt;= 右子树的结点数，则搜索右子树</span></span><br><span class="line">                <span class="keyword">return</span> search(node.right, k);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// k == 当前结点数加右子树的结点数，则找到第k大的结点</span></span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//KthLargest 的成员变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">private</span> BST bst = <span class="keyword">new</span> BST();</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//初始化搜索树</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">KthLargest</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.k = k;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : nums) &#123;</span><br><span class="line">            bst.add(n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回需要的结果</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        bst.add(val);</span><br><span class="line">        <span class="keyword">return</span> bst.search(k).val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="解决方案二：最小堆"><a href="#解决方案二：最小堆" class="headerlink" title="解决方案二：最小堆"></a>解决方案二：最小堆</h3><h4 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>



<blockquote>
<p>文件名：LBST8</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCodeExplore</tag>
        <tag>LeetcodeExploreBST</tag>
      </tags>
  </entry>
  <entry>
    <title>删除二叉搜索树中的节点</title>
    <url>/2020/10/05/LEBST6/</url>
    <content><![CDATA[<h1 id="题目：-删除二叉搜索树中的节点-Medium"><a href="#题目：-删除二叉搜索树中的节点-Medium" class="headerlink" title="题目： 删除二叉搜索树中的节点   Medium"></a>题目： <a href="https://leetcode-cn.com/problems/delete-node-in-a-bst/" target="_blank" rel="noopener">删除二叉搜索树中的节点</a>   Medium</h1><h3 id="解决方案一：递归"><a href="#解决方案一：递归" class="headerlink" title="解决方案一：递归"></a>解决方案一：递归</h3><h4 id="二叉搜索树的三个特性："><a href="#二叉搜索树的三个特性：" class="headerlink" title="二叉搜索树的三个特性："></a>二叉搜索树的三个特性：</h4><ol>
<li><p>二叉搜索树的中序遍历的序列是<strong>递增排序的序列</strong>。中序遍历的遍历次序：<code>Left -&gt; Node -&gt; Right</code></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二叉树中序遍历建树</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> LinkedList&lt;Integer&gt; <span class="title">inorder</span><span class="params">(TreeNode root, LinkedList&lt;Integer&gt; arr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> arr;</span><br><span class="line">  inorder(root.left, arr);</span><br><span class="line">  arr.add(root.val);</span><br><span class="line">  inorder(root.right, arr);</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>Successor</strong> ：<strong>右子树的最左结点</strong></p>
<p>代表的是中序遍历序列的下一个节点。即<strong>比当前节点大的最小节点</strong>，简称<strong>后继节点</strong>。 先取当前节点的右节点，然后一直取该节点的左节点，直到左节点为空，则最后指向的节点为<strong>后继节点</strong>。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//该节点存在右子树，否则返回本身，</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">successor</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">  root = root.right;</span><br><span class="line">  <span class="keyword">while</span> (root.left != <span class="keyword">null</span>) root = root.left;</span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>Predecessor</strong>：<strong>左子树的最右节点</strong></p>
<p> 代表的是中序遍历序列的前一个节点。即<strong>比当前节点小的最大节点</strong>，简称<strong>前驱节点</strong>。先取当前节点的左节点，然后取该节点的右节点，直到右节点为空，则最后指向的节点为前驱节点。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//该节点存在左子树</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">predecessor</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">  root = root.left;</span><br><span class="line">  <span class="keyword">while</span> (root.right != <span class="keyword">null</span>) root = root.right;</span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

</li>
</ol>
<h4 id="解题逻辑：三种可能情况"><a href="#解题逻辑：三种可能情况" class="headerlink" title="解题逻辑：三种可能情况"></a><strong>解题逻辑</strong>：三种可能情况</h4><ol>
<li>要删除的节点为叶子节点，可以直接删除</li>
<li>要删除的几点不是叶子节点且<strong>拥有右节点</strong>，则该节点可以由该节点的<strong>后继节点</strong>进行替代，该后继节点位于右子树中较低的位置。然后可以从后继节点的位置递归向下操作以删除后继节点。</li>
<li>要删除的节点不是叶子节点，且<strong>没有右节点但是有左节点</strong>。这意味着它的<strong>后继节点在它的上面</strong>，但是我们并不想返回。我们可以使用它的<strong>前驱节点进行替代</strong>，然后再递归的向下删除前驱节点。</li>
</ol>
<p><img src="/images/LEBST6/1.png" alt=""></p>
<h4 id="代码分析："><a href="#代码分析：" class="headerlink" title="代码分析："></a>代码分析：</h4><p>递归进行第二三种情况时，将后继节点或者前驱节点的<strong>值</strong>找到后，将问题转化为删除前驱或者后继结点问题。</p>
<p>最后落到第一种情况删除叶子结点。</p>
<h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  One step right and then always left</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">successor</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    root = root.right;</span><br><span class="line">    <span class="keyword">while</span> (root.left != <span class="keyword">null</span>) root = root.left;</span><br><span class="line">    <span class="keyword">return</span> root.val;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  One step left and then always right</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">predecessor</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    root = root.left;</span><br><span class="line">    <span class="keyword">while</span> (root.right != <span class="keyword">null</span>) root = root.right;</span><br><span class="line">    <span class="keyword">return</span> root.val;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deleteNode</span><span class="params">(TreeNode root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// delete from the right subtree</span></span><br><span class="line">    <span class="keyword">if</span> (key &gt; root.val) root.right = deleteNode(root.right, key);</span><br><span class="line">    <span class="comment">// delete from the left subtree</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; root.val) root.left = deleteNode(root.left, key);</span><br><span class="line">    <span class="comment">// delete the current node</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// the node is a leaf ：base case</span></span><br><span class="line">      <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) root = <span class="keyword">null</span>;</span><br><span class="line">      <span class="comment">// the node is not a leaf and has a right child：递归分解子问题</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        root.val = successor(root);</span><br><span class="line">        root.right = deleteNode(root.right, root.val);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// the node is not a leaf, has no right child, and has a left child    ：递归分解子问题</span></span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        root.val = predecessor(root);</span><br><span class="line">        root.left = deleteNode(root.left, root.val);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="tips"><a href="#tips" class="headerlink" title="tips:"></a>tips:</h4><img src="/images/LEBST6/image-20201005143136542.png" alt="image-20201005143136542" style="zoom:80%;" />

<h3 id="解决方案二：递归，不平衡但简单"><a href="#解决方案二：递归，不平衡但简单" class="headerlink" title="解决方案二：递归，不平衡但简单"></a>解决方案二：递归，不平衡但简单</h3><h4 id="解题思想："><a href="#解题思想：" class="headerlink" title="解题思想："></a>解题思想：</h4><p>三种删除情况，前两种return左右子树即可，第三种比较巧妙。</p>
<img src="/images/LEBST6/48c5fb57b64ddff5edfca2c3af57fad4493d255c37f35d6bc77651048cdcb294-%E6%8E%92%E5%88%97%E6%96%B9%E6%A1%88.png" alt="排列方案.png" style="zoom: 33%;" />

<p>第三种，直接将左子树连接到右子树的最左结点，即当前结点的后继结点上，会造成不平衡</p>
<img src="/images/LEBST6/ce9864e7052d98fbe006fbd350ceaf691fee1ed85a6ad9cc9f21e1e5295b0f0d-%E8%B0%83%E6%95%B4%E5%9B%BE.png" alt="调整图.png" style="zoom:33%;" />



<h4 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deleteNode</span><span class="params">(TreeNode root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当前节点值比key小，则需要删除当前节点的左子树中key对应的值，并保证二叉搜索树的性质不变</span></span><br><span class="line">        <span class="keyword">if</span>(key &lt; root.val)&#123;</span><br><span class="line">            root.left = deleteNode(root.left,key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当前节点值比key大，则需要删除当前节点的右子树中key对应的值，并保证二叉搜索树的性质不变</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(key &gt; root.val)&#123;</span><br><span class="line">            root.right = deleteNode(root.right,key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当前节点等于key，则需要删除当前节点，并保证二叉搜索树的性质不变</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//当前节点没有左子树</span></span><br><span class="line">            <span class="keyword">if</span>(root.left == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> root.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当前节点没有右子树</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(root.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当前节点既有左子树又有右子树</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                TreeNode node = root.right;</span><br><span class="line">                <span class="comment">//找到当前节点右子树最左边的叶子结点</span></span><br><span class="line">                <span class="keyword">while</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    node = node.left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//将root的左子树放到root的右子树的最下面的左叶子节点的左子树上</span></span><br><span class="line">                node.left = root.left;</span><br><span class="line">                <span class="keyword">return</span> root.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>文件名：LBST6</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCodeExplore</tag>
        <tag>LeetcodeExploreBST</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉搜索树中的插入操作</title>
    <url>/2020/10/05/LEBST5/</url>
    <content><![CDATA[<h1 id="题目：-二叉搜索树中的插入操作-Medium"><a href="#题目：-二叉搜索树中的插入操作-Medium" class="headerlink" title="题目：  二叉搜索树中的插入操作   Medium"></a>题目： <a href="https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/" target="_blank" rel="noopener"> 二叉搜索树中的插入操作</a>   Medium</h1><h2 id="1-自己构思：递归"><a href="#1-自己构思：递归" class="headerlink" title="1.自己构思：递归"></a>1.自己构思：递归</h2><h3 id="实现代码："><a href="#实现代码：" class="headerlink" title="实现代码："></a>实现代码：</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">insertIntoBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            TreeNode newNode = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">            <span class="keyword">return</span> newNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(val &gt; root.val) root.right = insertIntoBST(root.right,val);</span><br><span class="line">        <span class="keyword">else</span> root.left = insertIntoBST(root.left,val);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h2 id="2-学习题解代码"><a href="#2-学习题解代码" class="headerlink" title="2.学习题解代码"></a>2.学习题解代码</h2><h3 id="解决方案一：迭代"><a href="#解决方案一：迭代" class="headerlink" title="解决方案一：迭代"></a>解决方案一：迭代</h3><h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">insertIntoBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode pos = root;</span><br><span class="line">        <span class="keyword">while</span> (pos != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (val &lt; pos.val) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pos.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    pos.left = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    pos = pos.left;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (pos.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    pos.right = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    pos = pos.right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="tips"><a href="#tips" class="headerlink" title="tips:"></a>tips:</h4><ul>
<li><img src="/images/LEBST5/image-20201005133719245.png" alt="image-20201005133719245" style="zoom:80%;" />



</li>
</ul>
<blockquote>
<p>文件名：LBST5</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCodeExplore</tag>
        <tag>LeetcodeExploreBST</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉搜索树中的搜索</title>
    <url>/2020/10/05/LEBST4/</url>
    <content><![CDATA[<h1 id="题目：-二叉搜索树中的搜索-Easy"><a href="#题目：-二叉搜索树中的搜索-Easy" class="headerlink" title="题目： 二叉搜索树中的搜索   Easy"></a>题目： 二叉搜索树中的搜索   Easy</h1><h2 id="1-自己构思：递归"><a href="#1-自己构思：递归" class="headerlink" title="1.自己构思：递归"></a>1.自己构思：递归</h2><h3 id="实现代码："><a href="#实现代码：" class="headerlink" title="实现代码："></a>实现代码：</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">searchBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>( root.val &lt; val) <span class="keyword">return</span> searchBST(root.right,val);</span><br><span class="line">        <span class="keyword">if</span>( root.val &gt; val) <span class="keyword">return</span> searchBST(root.left,val);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>代码优化：参考解决方案一，三元表达式</p>
<h2 id="2-学习题解代码"><a href="#2-学习题解代码" class="headerlink" title="2.学习题解代码"></a>2.学习题解代码</h2><h3 id="解决方案一：递归"><a href="#解决方案一：递归" class="headerlink" title="解决方案一：递归"></a>解决方案一：递归</h3><h4 id="解题逻辑：递归"><a href="#解题逻辑：递归" class="headerlink" title="解题逻辑：递归"></a><strong>解题逻辑</strong>：递归</h4><h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> TreeNode <span class="title">searchBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span> || val == root.val) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> val &lt; root.val ? searchBST(root.left, val) : searchBST(root.right, val);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="tips"><a href="#tips" class="headerlink" title="tips:"></a>tips:</h4><ul>
<li><img src="/images/LEBST4/image-20201005131912379.png" alt="image-20201005131912379" style="zoom: 80%;" /></li>
<li><img src="/images/LEBST4/image-20201005131926368.png" alt="image-20201005131926368" style="zoom: 80%;" />

</li>
</ul>
<h3 id="解决方案二：迭代减小空间复杂度"><a href="#解决方案二：迭代减小空间复杂度" class="headerlink" title="解决方案二：迭代减小空间复杂度"></a>解决方案二：迭代减小空间复杂度</h3><h4 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> TreeNode <span class="title">searchBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="keyword">null</span> &amp;&amp; val != root.val)</span><br><span class="line">      root = val &lt; root.val ? root.left : root.right;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="Tips："><a href="#Tips：" class="headerlink" title="Tips："></a>Tips：</h4><ul>
<li><img src="/images/LEBST4/image-20201005132019325.png" alt="image-20201005132019325" style="zoom: 80%;" />
</li>
<li><img src="/images/LEBST4/image-20201005132037005.png" alt="image-20201005132037005" style="zoom:80%;" />



</li>
</ul>
<blockquote>
<p>文件名：LBST4</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCodeExplore</tag>
        <tag>LeetcodeExploreBST</tag>
      </tags>
  </entry>
  <entry>
    <title>大数据基础理论</title>
    <url>/2020/10/04/BigDataBasic/</url>
    <content><![CDATA[<h1 id="大数据基础理论"><a href="#大数据基础理论" class="headerlink" title="大数据基础理论"></a>大数据基础理论</h1><h2 id="三次信息化浪潮"><a href="#三次信息化浪潮" class="headerlink" title="三次信息化浪潮"></a>三次信息化浪潮</h2><p><img src="/images/BigDataBasic/image-20201004120921885.png" alt="image-20201004120921885"></p>
<p>大数据影响：</p>
<ul>
<li>全样非抽样</li>
<li>效率非精准：不存在误差放大问题，关注数据时效性</li>
<li>相关非因果：关联存在，不考虑为什么，相关性重要。买书，关注买了，但为什么不用管</li>
</ul>
<h1 id="ubuntu使用"><a href="#ubuntu使用" class="headerlink" title="ubuntu使用"></a>ubuntu使用</h1><p>采用云主机，远程连接密码：Jsq123,实例密码19980810sqSQ</p>
<p>注销当前用户 logout</p>
<p>创建hadoop用户密码hadoop</p>
<p>安装wget</p>
<p>rm 删除文件</p>
<p>cd .. 返回上一层</p>
<p>cd / 返回根目录</p>
<h1 id="vim使用操作"><a href="#vim使用操作" class="headerlink" title="vim使用操作"></a>vim使用操作</h1><p>：wq</p>
<p>:q!</p>
<p>esc</p>
<h1 id="hadoop安装"><a href="#hadoop安装" class="headerlink" title="hadoop安装"></a>hadoop安装</h1><p><img src="/images/BigDataBasic/image-20201004173851532.png" alt="image-20201004173851532"></p>
<p>解压handoop sudo tar -zxf/hadoop-2 77.tar.gz -C/usr/local    </p>
<h1 id="伪分布式安装"><a href="#伪分布式安装" class="headerlink" title="伪分布式安装"></a>伪分布式安装</h1><p>名称结点和数据结点放在一个节点上</p>
<p>gedit 需要gui</p>
<h1 id="Hadoop集群部署与使用"><a href="#Hadoop集群部署与使用" class="headerlink" title="Hadoop集群部署与使用"></a>Hadoop集群部署与使用</h1><p>namenode 目录服务器</p>
<blockquote>
<p>文件名：BigDataBasic</p>
</blockquote>
]]></content>
      <categories>
        <category>BigData</category>
      </categories>
  </entry>
  <entry>
    <title>二叉搜索树迭代器</title>
    <url>/2020/10/03/LEBST3/</url>
    <content><![CDATA[<h1 id="题目：二叉搜索树迭代器-Medium"><a href="#题目：二叉搜索树迭代器-Medium" class="headerlink" title="题目：二叉搜索树迭代器   Medium"></a>题目：<a href="https://leetcode-cn.com/problems/binary-search-tree-iterator/" target="_blank" rel="noopener">二叉搜索树迭代器</a>   Medium</h1><h3 id="解决方案一：扁平化二叉搜索树"><a href="#解决方案一：扁平化二叉搜索树" class="headerlink" title="解决方案一：扁平化二叉搜索树"></a>解决方案一：扁平化二叉搜索树</h3><h4 id="解题逻辑：使用额外的数组将二叉搜索树展开放入"><a href="#解题逻辑：使用额外的数组将二叉搜索树展开放入" class="headerlink" title="解题逻辑：使用额外的数组将二叉搜索树展开放入"></a><strong>解题逻辑</strong>：使用额外的数组将二叉搜索树展开放入</h4><img src="/images/LEBST3/image-20201003192828779.png" alt="image-20201003192828779" style="zoom:80%;" />



<h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> * int val;</span></span><br><span class="line"><span class="comment"> * TreeNode left;</span></span><br><span class="line"><span class="comment"> * TreeNode right;</span></span><br><span class="line"><span class="comment"> * TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSTIterator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;Integer&gt; nodesSorted;</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BSTIterator</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Array containing all the nodes in the sorted order</span></span><br><span class="line">        <span class="keyword">this</span>.nodesSorted = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Pointer to the next smallest element in the BST</span></span><br><span class="line">        <span class="keyword">this</span>.index = -<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Call to flatten the input binary search tree</span></span><br><span class="line">        <span class="keyword">this</span>._inorder(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">_inorder</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>._inorder(root.left);</span><br><span class="line">        <span class="keyword">this</span>.nodesSorted.add(root.val);</span><br><span class="line">        <span class="keyword">this</span>._inorder(root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the next smallest number</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.nodesSorted.get(++<span class="keyword">this</span>.index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> whether we have a next smallest number</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.index + <span class="number">1</span> &lt; <span class="keyword">this</span>.nodesSorted.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="解决方案二：中序遍历非递归函数拆分实现"><a href="#解决方案二：中序遍历非递归函数拆分实现" class="headerlink" title="解决方案二：中序遍历非递归函数拆分实现"></a>解决方案二：中序遍历非递归函数拆分实现</h3><p><strong>解题逻辑</strong>：模拟中序遍历的受控递归</p>
<img src="/images/LEBST3/image-20201003195744122.png" alt="image-20201003195744122" style="zoom:67%;" />

<h4 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> * int val;</span></span><br><span class="line"><span class="comment"> * TreeNode left;</span></span><br><span class="line"><span class="comment"> * TreeNode right;</span></span><br><span class="line"><span class="comment"> * TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSTIterator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Stack&lt;TreeNode&gt; stack;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BSTIterator</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Stack for the recursion simulation</span></span><br><span class="line">        <span class="keyword">this</span>.stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Remember that the algorithm starts with a call to the helper function</span></span><br><span class="line">        <span class="comment">// with the root node as the input</span></span><br><span class="line">        <span class="keyword">this</span>._leftmostInorder(root);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//将结点以及其左节点压入栈中即模拟中序遍历前中部分顺序</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">_leftmostInorder</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// For a given node, add all the elements in the leftmost branch of the tree</span></span><br><span class="line">        <span class="comment">// under it to the stack.</span></span><br><span class="line">        <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.stack.push(root);</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the next smallest number</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//最小值即左子树内容，出栈后则代表中间结点，此时将其右节点入栈</span></span><br><span class="line">        <span class="comment">// Node at the top of the stack is the next smallest element</span></span><br><span class="line">        TreeNode topmostNode = <span class="keyword">this</span>.stack.pop();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Need to maintain the invariant. If the node has a right child, call the </span></span><br><span class="line">        <span class="comment">// helper function for the right child</span></span><br><span class="line">        <span class="comment">//将结点右子树压入栈中模拟中序遍历后部分，记住前中结点都出栈后才轮到右节点即出栈后</span></span><br><span class="line">        <span class="keyword">if</span> (topmostNode.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>._leftmostInorder(topmostNode.right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> topmostNode.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> whether we have a next smallest number</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.stack.size() &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>文件名：LBST3</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCodeExplore</tag>
        <tag>LeetcodeExploreBST</tag>
      </tags>
  </entry>
  <entry>
    <title>验证二叉搜索树</title>
    <url>/2020/10/03/LEBST2/</url>
    <content><![CDATA[<h1 id="题目：-验证二叉搜索树-Medium"><a href="#题目：-验证二叉搜索树-Medium" class="headerlink" title="题目： 验证二叉搜索树   Medium"></a>题目： <a href="https://leetcode-cn.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">验证二叉搜索树</a>   Medium</h1><h2 id="1-自己构思"><a href="#1-自己构思" class="headerlink" title="1.自己构思"></a>1.自己构思</h2><h3 id="出现问题："><a href="#出现问题：" class="headerlink" title="出现问题："></a>出现问题：</h3><ol>
<li>隔数层验证左右定律传值出现问题</li>
</ol>
<h3 id="问题解决："><a href="#问题解决：" class="headerlink" title="问题解决："></a>问题解决：</h3><ol>
<li><p>二叉搜索树通过二叉树中序遍历可以得到一个<strong>升序的序列</strong></p>
<p>即只需要比较中序遍历下<strong>前后两个节点</strong>的大小即可判断是否为二叉搜索树</p>
</li>
</ol>
<h3 id="解决方案一"><a href="#解决方案一" class="headerlink" title="解决方案一"></a>解决方案一</h3><h4 id="解题逻辑："><a href="#解题逻辑：" class="headerlink" title="解题逻辑："></a><strong>解题逻辑</strong>：</h4><ul>
<li>中序遍历时，判断当前节点是否大于中序遍历的前一个节点，如果大于，说明满足 BST，继续遍历；否则直接返回 false。</li>
</ul>
<h4 id="代码分析："><a href="#代码分析：" class="headerlink" title="代码分析："></a>代码分析：</h4><h4 id="解决自己问题："><a href="#解决自己问题：" class="headerlink" title="解决自己问题："></a>解决自己问题：</h4><ul>
<li>比较思路混乱</li>
</ul>
<h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> pre = Long.MIN_VALUE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 访问左子树</span></span><br><span class="line">        <span class="keyword">if</span> (!isValidBST(root.left)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 访问当前节点：如果当前节点小于等于中序遍历的前一个节点，说明不满足BST，返回 false；否则继续遍历。</span></span><br><span class="line">        <span class="keyword">if</span> (root.val &lt;= pre) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = root.val;</span><br><span class="line">        <span class="comment">// 访问右子树</span></span><br><span class="line">        <span class="keyword">return</span> isValidBST(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="tips"><a href="#tips" class="headerlink" title="tips:"></a>tips:</h4><ul>
<li>极限测试用例下INT_MIN不能通过，采用更小的值 <code>Long.MIN_VALUE</code></li>
</ul>
<blockquote>
<p>文件名：LBST2</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCodeExplore</tag>
        <tag>LeetcodeExploreBST</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉搜索树</title>
    <url>/2020/10/03/LEBST1/</url>
    <content><![CDATA[<h1 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>二叉搜索树（BST）是二叉树的一种特殊表示形式，它满足如下特性：</p>
<p>每个节点中的值必须<strong>大于（</strong>或等于）存储在其左侧子树中的任何值。<br>每个节点中的值必须<strong>小于（</strong>或等于）存储在其右子树中的任何值。</p>
<p><img src="/images/LEBST1/bst_example-a1.png" alt="img" style="zoom:50%;" />、</p>
<p><strong>中序遍历</strong>是二叉搜索树中最常用的遍历方法，因为可以通过<code>中序遍历</code>得到一个<code>递增的</code>有序序列</p>
<blockquote>
<p>文件名：LBST1</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCodeExplore</tag>
        <tag>LeetcodeExploreBST</tag>
      </tags>
  </entry>
  <entry>
    <title>Model</title>
    <url>/2020/10/03/LEBST10/</url>
    <content><![CDATA[<h1 id="题目：-名字-Easy-Medium-Hard"><a href="#题目：-名字-Easy-Medium-Hard" class="headerlink" title="题目： 名字   Easy/Medium/Hard"></a>题目： 名字   Easy/Medium/Hard</h1><h2 id="1-自己构思"><a href="#1-自己构思" class="headerlink" title="1.自己构思"></a>1.自己构思</h2><h3 id="出现问题："><a href="#出现问题：" class="headerlink" title="出现问题："></a>出现问题：</h3><ol>
<li><h3 id="问题解决："><a href="#问题解决：" class="headerlink" title="问题解决："></a>问题解决：</h3></li>
<li></li>
</ol>
<h2 id="2-学习题解代码"><a href="#2-学习题解代码" class="headerlink" title="2.学习题解代码"></a>2.学习题解代码</h2><h3 id="解决方案一"><a href="#解决方案一" class="headerlink" title="解决方案一"></a>解决方案一</h3><h4 id="解题逻辑："><a href="#解题逻辑：" class="headerlink" title="解题逻辑："></a><strong>解题逻辑</strong>：</h4><ul>
<li></li>
</ul>
<h4 id="代码分析："><a href="#代码分析：" class="headerlink" title="代码分析："></a>代码分析：</h4><h4 id="解决自己问题："><a href="#解决自己问题：" class="headerlink" title="解决自己问题："></a>解决自己问题：</h4><ul>
<li><h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4></li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>



<h4 id="tips"><a href="#tips" class="headerlink" title="tips:"></a>tips:</h4><ul>
<li><h3 id="解决方案二"><a href="#解决方案二" class="headerlink" title="解决方案二"></a>解决方案二</h3></li>
</ul>
<h4 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="解决方案三"><a href="#解决方案三" class="headerlink" title="解决方案三"></a>解决方案三</h3><blockquote>
<p>文件名：LBST</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCodeExplore</tag>
        <tag>LeetcodeExploreBST</tag>
      </tags>
  </entry>
  <entry>
    <title>Model</title>
    <url>/2020/10/03/LEBST7/</url>
    <content><![CDATA[<h1 id="题目：-名字-Easy-Medium-Hard"><a href="#题目：-名字-Easy-Medium-Hard" class="headerlink" title="题目： 名字   Easy/Medium/Hard"></a>题目： 名字   Easy/Medium/Hard</h1><h2 id="1-自己构思"><a href="#1-自己构思" class="headerlink" title="1.自己构思"></a>1.自己构思</h2><h3 id="出现问题："><a href="#出现问题：" class="headerlink" title="出现问题："></a>出现问题：</h3><ol>
<li><h3 id="问题解决："><a href="#问题解决：" class="headerlink" title="问题解决："></a>问题解决：</h3></li>
<li></li>
</ol>
<h2 id="2-学习题解代码"><a href="#2-学习题解代码" class="headerlink" title="2.学习题解代码"></a>2.学习题解代码</h2><h3 id="解决方案一"><a href="#解决方案一" class="headerlink" title="解决方案一"></a>解决方案一</h3><h4 id="解题逻辑："><a href="#解题逻辑：" class="headerlink" title="解题逻辑："></a><strong>解题逻辑</strong>：</h4><ul>
<li></li>
</ul>
<h4 id="代码分析："><a href="#代码分析：" class="headerlink" title="代码分析："></a>代码分析：</h4><h4 id="解决自己问题："><a href="#解决自己问题：" class="headerlink" title="解决自己问题："></a>解决自己问题：</h4><ul>
<li><h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4></li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>



<h4 id="tips"><a href="#tips" class="headerlink" title="tips:"></a>tips:</h4><ul>
<li><h3 id="解决方案二"><a href="#解决方案二" class="headerlink" title="解决方案二"></a>解决方案二</h3></li>
</ul>
<h4 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="解决方案三"><a href="#解决方案三" class="headerlink" title="解决方案三"></a>解决方案三</h3><blockquote>
<p>文件名：LBST</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCodeExplore</tag>
        <tag>LeetcodeExploreBST</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE查漏补缺</title>
    <url>/2020/10/02/JavaSE/</url>
    <content><![CDATA[<h1 id="JavaSE查漏补缺"><a href="#JavaSE查漏补缺" class="headerlink" title="JavaSE查漏补缺"></a>JavaSE查漏补缺</h1><h2 id="编程基础"><a href="#编程基础" class="headerlink" title="编程基础"></a>编程基础</h2><h3 id="JRE-amp-JVM-amp-JDK"><a href="#JRE-amp-JVM-amp-JDK" class="headerlink" title="JRE&amp;JVM&amp;JDK"></a>JRE&amp;JVM&amp;JDK</h3><p>程序源代码不是直 接编译、链接成机器代码，而是先转化到字节码（ bytecode ） 这种特殊的中间形式，字节码再转换成机器码或系统调用。前者是传统的编译方法，生成的机器代码就不可避免地跟特殊的操作系统和特殊的机器结构相关。</p>
<p>包</p>
<p>其实就是文件夹，用于把<strong>相同的类名进行区分</strong>，全部小写，单级：liuyi，多级：cn.itcast</p>
<p>为了便于对硬盘上的文件进行管理，通常都会将文件分目录进行存放。同理，在程序开发中，也需要将编写的类在项目中分目录存放，以便于文件管理。为此，Java引入了包(package)机制，程序可以通过声明包的方式对Java类定义目录。</p>
<h3 id="java中内存分配"><a href="#java中内存分配" class="headerlink" title="java中内存分配"></a>java中内存分配</h3><img src="/images/JavaSE/image-20201001203105377.png" alt="image-20201001203105377" style="zoom: 80%;" />

<h3 id="基本数据类型与包装类"><a href="#基本数据类型与包装类" class="headerlink" title="基本数据类型与包装类"></a>基本数据类型与包装类</h3><p>为了方便操作基本数据类型值，将其封装成了对象，在对象中定义了属性和行为丰富了该数据的操作。用于描述该对象的类就称为基本数据类型对象包装类。</p>
<ul>
<li>将基本数据类型封装成对象的好处在于可以在对象中<strong>定义更多的功能方法操作该数据</strong>。</li>
<li>常用的操作之一：用于<strong>基本数据类型与字符串之间的转换</strong>。</li>
<li>基本类型和包装类的对应：Byte，Short，Integer，Long，Float，Double，Character，Boolean</li>
</ul>
<table>
<thead>
<tr>
<th>基本数据类型</th>
<th>包装数据类型</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>char</td>
<td>Character</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
</tbody></table>
<h4 id="基本数据类型包装类应用"><a href="#基本数据类型包装类应用" class="headerlink" title="基本数据类型包装类应用"></a><strong>基本数据类型包装类应用</strong></h4><p>该包装对象主要用于<strong>基本类型和字符串之间的转换</strong></p>
<h4 id="基本类型-→-字符串"><a href="#基本类型-→-字符串" class="headerlink" title="基本类型 → 字符串"></a>基本类型 → 字符串</h4><ol>
<li>基本类型数值+””</li>
<li>用String类中的静态方法valueOf(基本类型数值);</li>
</ol>
<h4 id="字符串-→-基本类型"><a href="#字符串-→-基本类型" class="headerlink" title="字符串 → 基本类型"></a>字符串 → 基本类型</h4><p>使用包装类中的静态方法xxx parseXxx(“xxx”);</p>
<ul>
<li>int parseInt(String str);</li>
<li>long parseLong(String str);</li>
<li>boolean parseBoolean(String str);</li>
<li>只有Character没有parse方法。</li>
</ul>
<h3 id="Integer类"><a href="#Integer类" class="headerlink" title="Integer类"></a><strong>Integer类</strong></h3><h4 id="Integer类概述"><a href="#Integer类概述" class="headerlink" title="Integer类概述"></a>Integer类概述</h4><p>Integer 类在对象中包装了一个基本类型 int 的值 该类提供了多个方法，能在 int 类型和 String 类型之间互相转换，还提供了处理 int 类型时非常有用的其他一些常量和方法</p>
<h4 id="int类型和String类型的相互转换"><a href="#int类型和String类型的相互转换" class="headerlink" title="int类型和String类型的相互转换"></a><strong>int类型和String类型的相互转换</strong></h4><table>
<thead>
<tr>
<th>返回值</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>int</td>
<td>intValue()</td>
<td>以 int 类型返回该 Integer 的值</td>
</tr>
<tr>
<td>int</td>
<td>parseInt(String s)</td>
<td>将字符串参数作为有符号的十进制整数进行解析</td>
</tr>
<tr>
<td>String</td>
<td>toString(int i)</td>
<td>返回一个表示指定整数的 String 对象</td>
</tr>
<tr>
<td>Integer</td>
<td>valueOf(int i)</td>
<td>返回一个表示指定的 int 值的 Integer 实例</td>
</tr>
<tr>
<td>Integer</td>
<td>valueOf(String s)</td>
<td>返回保存指定的 String 的值的 Integer 对象</td>
</tr>
</tbody></table>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerDemo</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        <span class="comment">// int -- String  </span></span><br><span class="line">        <span class="keyword">int</span> number = <span class="number">100</span>;  </span><br><span class="line">        <span class="comment">// 方式1  </span></span><br><span class="line">        String s1 = <span class="string">""</span> + number;  </span><br><span class="line">        System.out.println(<span class="string">"s1:"</span> + s1);  </span><br><span class="line">        <span class="comment">// 方式2  </span></span><br><span class="line">        String s2 = String.valueOf(number);  </span><br><span class="line">        System.out.println(<span class="string">"s2:"</span> + s2);  </span><br><span class="line">        <span class="comment">// 方式3  </span></span><br><span class="line">        <span class="comment">//#####理解包装类型与基本数据类型之间的转换####</span></span><br><span class="line">        <span class="comment">// int -- Integer -- String  </span></span><br><span class="line">        Integer i = <span class="keyword">new</span> Integer(number);  </span><br><span class="line">        String s3 = i.toString();  </span><br><span class="line">        System.out.println(<span class="string">"s3:"</span> + s3);  </span><br><span class="line">        <span class="comment">// 方式4         </span></span><br><span class="line">        <span class="comment">//*****常用*******</span></span><br><span class="line">        <span class="comment">// public static String toString(int i)  </span></span><br><span class="line">        String s4 = Integer.toString(number);     <span class="comment">//包装类直接转换</span></span><br><span class="line">        System.out.println(<span class="string">"s4:"</span> + s4);  </span><br><span class="line">        System.out.println(<span class="string">"-----------------"</span>);  </span><br><span class="line"></span><br><span class="line">        <span class="comment">// String -- int  </span></span><br><span class="line">        String s = <span class="string">"100"</span>;  </span><br><span class="line">        <span class="comment">// 方式1  </span></span><br><span class="line">        <span class="comment">// String -- Integer -- int  </span></span><br><span class="line">        <span class="comment">//#####理解包装类型与基本数据类型之间的转换####</span></span><br><span class="line">        Integer ii = <span class="keyword">new</span> Integer(s);   <span class="comment">//装箱</span></span><br><span class="line">        <span class="comment">// public int intValue()  </span></span><br><span class="line">        <span class="keyword">int</span> x = ii.intValue();     <span class="comment">//拆箱</span></span><br><span class="line">        System.out.println(<span class="string">"x:"</span> + x);  </span><br><span class="line">        <span class="comment">//方式2  </span></span><br><span class="line">        <span class="comment">//public static int parseInt(String s)  </span></span><br><span class="line">        <span class="keyword">int</span> y = Integer.parseInt(s);   <span class="comment">//包装类直接转换</span></span><br><span class="line">        System.out.println(<span class="string">"y:"</span>+y);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="Character类"><a href="#Character类" class="headerlink" title="Character类"></a>Character类</h3><p>Character 类在对象中包装一个基本类型 char 的值，此外，该类提供了几种方法，以<strong>确定字符的类别（小写字母，数字，等等）</strong>，并<strong>将字符从大写转换成小写</strong>，反之亦然</p>
<h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a><strong>常用方法</strong></h4><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>isUpperCase(char ch)</td>
<td>判断是否是大写</td>
</tr>
<tr>
<td>isLowerCase(char ch)</td>
<td>判断是否是小写</td>
</tr>
<tr>
<td>isDigit(char ch)</td>
<td>判断是否是数字</td>
</tr>
<tr>
<td>char toUpperCase(char ch)</td>
<td>转换成大写</td>
</tr>
<tr>
<td>char toLowerCase(char ch)</td>
<td>转换成小写</td>
</tr>
</tbody></table>
<p>代码示例：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast_02;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public static boolean isUpperCase(char ch):判断给定的字符是否是大写字符</span></span><br><span class="line"><span class="comment"> * public static boolean isLowerCase(char ch):判断给定的字符是否是小写字符</span></span><br><span class="line"><span class="comment"> * public static boolean isDigit(char ch):判断给定的字符是否是数字字符</span></span><br><span class="line"><span class="comment"> * public static char toUpperCase(char ch):把给定的字符转换为大写字符</span></span><br><span class="line"><span class="comment"> * public static char toLowerCase(char ch):把给定的字符转换为小写字符</span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CharacterDemo</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        <span class="comment">// public static boolean isUpperCase(char ch):判断给定的字符是否是大写字符  </span></span><br><span class="line">        System.out.println(<span class="string">"isUpperCase:"</span> + Character.isUpperCase(<span class="string">'A'</span>));  </span><br><span class="line">        System.out.println(<span class="string">"isUpperCase:"</span> + Character.isUpperCase(<span class="string">'a'</span>));  </span><br><span class="line">        System.out.println(<span class="string">"isUpperCase:"</span> + Character.isUpperCase(<span class="string">'0'</span>));  </span><br><span class="line">        System.out.println(<span class="string">"-----------------------------------------"</span>);  </span><br><span class="line">        <span class="comment">// public static boolean isLowerCase(char ch):判断给定的字符是否是小写字符  </span></span><br><span class="line">        System.out.println(<span class="string">"isLowerCase:"</span> + Character.isLowerCase(<span class="string">'A'</span>));  </span><br><span class="line">        System.out.println(<span class="string">"isLowerCase:"</span> + Character.isLowerCase(<span class="string">'a'</span>));  </span><br><span class="line">        System.out.println(<span class="string">"isLowerCase:"</span> + Character.isLowerCase(<span class="string">'0'</span>));  </span><br><span class="line">        System.out.println(<span class="string">"-----------------------------------------"</span>);  </span><br><span class="line">        <span class="comment">// public static boolean isDigit(char ch):判断给定的字符是否是数字字符  </span></span><br><span class="line">        System.out.println(<span class="string">"isDigit:"</span> + Character.isDigit(<span class="string">'A'</span>));  </span><br><span class="line">        System.out.println(<span class="string">"isDigit:"</span> + Character.isDigit(<span class="string">'a'</span>));  </span><br><span class="line">        System.out.println(<span class="string">"isDigit:"</span> + Character.isDigit(<span class="string">'0'</span>));  </span><br><span class="line">        System.out.println(<span class="string">"-----------------------------------------"</span>);  </span><br><span class="line">        <span class="comment">// public static char toUpperCase(char ch):把给定的字符转换为大写字符  </span></span><br><span class="line">        System.out.println(<span class="string">"toUpperCase:"</span> + Character.toUpperCase(<span class="string">'A'</span>));  </span><br><span class="line">        System.out.println(<span class="string">"toUpperCase:"</span> + Character.toUpperCase(<span class="string">'a'</span>));  </span><br><span class="line">        System.out.println(<span class="string">"-----------------------------------------"</span>);  </span><br><span class="line">        <span class="comment">// public static char toLowerCase(char ch):把给定的字符转换为小写字符  </span></span><br><span class="line">        System.out.println(<span class="string">"toLowerCase:"</span> + Character.toLowerCase(<span class="string">'A'</span>));  </span><br><span class="line">        System.out.println(<span class="string">"toLowerCase:"</span> + Character.toLowerCase(<span class="string">'a'</span>));  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 把字符串转换为字符数组。  </span></span><br><span class="line"><span class="keyword">char</span>[] chs = line.toCharArray();</span><br></pre></td></tr></table></figure></div>

<h2 id="面向对象OOP"><a href="#面向对象OOP" class="headerlink" title="面向对象OOP"></a>面向对象OOP</h2><p><strong>封装</strong>是面向对象的核心思想，将对象的属性和行为封装起来，不需要让外界知道具体实现细节，这就是封装思想。</p>
<p><strong>继承</strong>不仅增强了代码的复用性、提高开发效率，还为程序的维护补充提供了便利。</p>
<p><strong>多态性</strong></p>
<p>多态性指的是在程序中允许出现<strong>重名</strong>现象，它指在一个类中定义的属性和方法被其它类继承后，它们可以具有不同的数据类型或表现出不同的行为，这使得<strong>同一个属性和方法在不同的类中具有不同的语义</strong>。例如，当听到“Cut” 这个单词时，理发师的行为是剪发，演员的行为表现是停止表演，不同的对象，所表现的行为是不一样的。</p>
<h3 id="面向对象思想"><a href="#面向对象思想" class="headerlink" title="面向对象思想"></a>面向对象思想</h3><p>面向对象的思想中提出了两个概念，即<strong>类和对象</strong>。其中，类是对<strong>某一类事物的抽象描述</strong>，而对象用于表示现实中该类<strong>事物的个体</strong>。</p>
<p>使用<strong>类封装来这多个方法</strong>，将来再做数组的操作时，<strong>不用去找具体的方法，先找到这个类，然后使用这个类中的方法</strong>。这就是面向对象思想的编程方式。</p>
<h3 id="面向对象思想概述："><a href="#面向对象思想概述：" class="headerlink" title="面向对象思想概述："></a><strong>面向对象思想概述</strong>：</h3><p>面向对象是基于面向过程的编程思想，强调的是对象，然后由对象去调用功能。</p>
<h3 id="面向对象思想特点"><a href="#面向对象思想特点" class="headerlink" title="面向对象思想特点"></a>面向对象思想特点</h3><ul>
<li>是一种更符合我们思想习惯的思想</li>
<li>可以将复杂的事情简单化</li>
<li>将我们从执行者变成了指挥者，角色发生了转换</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">举例：</span><br><span class="line"></span><br><span class="line">(1) 买电脑：</span><br><span class="line">面向过程：我的了解电脑--了解我自己的需求--找对应的参数信息--去中关村买电脑--讨价还价--买回电脑</span><br><span class="line"></span><br><span class="line">面向对象：我知道我要买电脑 -- 班长去给我买 -- 班长就买回来了</span><br><span class="line"></span><br><span class="line">(2) 洗衣服：</span><br><span class="line"></span><br><span class="line">面向过程：把衣服脱下--找一个盆--放点洗衣粉--加点水--把衣服扔进去--搓一搓--清洗衣服--拧干--晾起来</span><br><span class="line"></span><br><span class="line">面向对象：把衣服脱下--打开全自动洗衣机--扔进去--一键即可--晾起来</span><br><span class="line"></span><br><span class="line">(3) 吃饭：</span><br><span class="line"></span><br><span class="line">面向过程：去超市买菜--摘菜--洗菜--切菜--炒菜--盛起来--吃</span><br><span class="line"></span><br><span class="line">面向对象：上饭店吃饭，你--服务员(点菜)--厨师(做菜)--服务员(端菜)--吃</span><br></pre></td></tr></table></figure></div>

<h3 id="面向对象开发、设计、特征"><a href="#面向对象开发、设计、特征" class="headerlink" title="面向对象开发、设计、特征"></a>面向对象开发、设计、特征</h3><p>面向对象开发：就是不断的创建对象，使用对象，指挥对象做事情。 面向对象设计：其实就是在管理和维护对象之间的关系。</p>
<p>面向对象特征</p>
<ul>
<li>封装(encapsulation)</li>
<li>继承(inheritance)</li>
<li>多态(polymorphism)</li>
</ul>
<h3 id="类与对象的关系"><a href="#类与对象的关系" class="headerlink" title="类与对象的关系"></a>类与对象的关系</h3><ul>
<li>类：是一组相关的属性和行为的集合 </li>
<li>对象：是该类事物的具体体现 </li>
<li>举例：类 学生，对象班长就是一个对象</li>
</ul>
<h3 id="对象内存图"><a href="#对象内存图" class="headerlink" title="对象内存图"></a>对象内存图</h3><p>只要是用new操作符定义的实体就会在<strong>堆内存</strong>中开辟一个新的空间，并且每一个对象中都有一份属于自己的属性。</p>
<img src="/images/JavaSE/image-20201001213320699.png" alt="image-20201001213320699" style="zoom:67%;" />

<p>3个对象的内存图：其中有两个引用指向同一个对象</p>
<img src="/images/JavaSE/image-20201001213348374.png" alt="image-20201001213348374" style="zoom:67%;" />

<h4 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h4><p>Java虚拟机会自动回收垃圾对象所占用的内存空间。</p>
<h3 id="成员变量和局部变量的区别"><a href="#成员变量和局部变量的区别" class="headerlink" title="成员变量和局部变量的区别"></a>成员变量和局部变量的区别</h3><p><img src="/images/JavaSE/image-20201001213459618.png" alt="image-20201001213459618"></p>
<h3 id="形式参数问题"><a href="#形式参数问题" class="headerlink" title="形式参数问题"></a>形式参数问题</h3><blockquote>
<p>/**<br>    形式参数的问题：<br>        基本类型：形式参数的改变不影响实际参数<br>        引用类型：形式参数的改变直接影响实际参数<br>*/</p>
</blockquote>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//形式参数是基本类型 值传递</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a + b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//形式参数是引用类型 传递类的对象即地址</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"我爱学习"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudentDemo</span> </span>&#123;</span><br><span class="line">	<span class="comment">//如果你看到了一个方法的形式参数是一个类类型(引用类型)，这里其实需要的是该类的对象。</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(Student s)</span> </span>&#123; <span class="comment">//调用的时候，把main方法中的s的地址传递到了这里 Student s = new Student();</span></span><br><span class="line">		s.show();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在java中，<strong>方法参数</strong>的传递永远都是，而这个值，对于基本数据类型，值就是你赋给变量的那个值。而对于<strong>引用数据类型</strong>，这个值是<strong>对象的引用</strong>，而不是这个对象本身。</p>
<h3 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h3><ul>
<li>this代表其所在函数所属对象的引用。换言之，<strong>this代本类对象的引用</strong>。</li>
<li>当<strong>成员变量和局部变量重名</strong>，可以用关键字this来区分，this就是所在<strong>函数所属对象的引用</strong>。</li>
<li>简单说，哪个对象调用了this所在的函数，this就代表哪个对象。一般方法调用默认加this。（方法被哪个对象调用，this就代表那个对象）</li>
</ul>
<p>什么时候使用this呢?</p>
<ul>
<li>局部变量隐藏成员变量</li>
<li>其他用法后面和super一起讲解</li>
</ul>
<h3 id="构造方法和成员变量初始化顺序"><a href="#构造方法和成员变量初始化顺序" class="headerlink" title="构造方法和成员变量初始化顺序"></a>构造方法和成员变量初始化顺序</h3><ol>
<li>执行父类静态代码</li>
<li>执行子类静态代码 </li>
<li>初始化父类成员变量（我们常说的赋值语句） </li>
<li>初始化父类构造函数</li>
<li>初始化子类成员变量 </li>
<li>初始化子类构造函数</li>
</ol>
<h3 id="重写与重载"><a href="#重写与重载" class="headerlink" title="重写与重载"></a>重写与重载</h3><ul>
<li>重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。<strong>即外壳不变，核心重写！</strong></li>
<li>重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。</li>
</ul>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a><a href="https://github.com/JackChan1999/Java_Basic_Introduction/blob/master/%E7%AC%AC3%E7%AB%A0%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3.md">抽象类</a></h3><p>Java允许在定义方法时<strong>不写方法体</strong>，<strong>不包含方法体的方法</strong>为抽象方法，抽象方法必须使用abstract关键字来修饰。、</p>
<h4 id="抽象类概述"><a href="#抽象类概述" class="headerlink" title="抽象类概述"></a>抽象类概述</h4><p>抽象定义：抽象就是从多个事物中将<strong>共性的、本质的内容</strong>抽取出来。例如：狼和狗共性都是犬科，<strong>犬科</strong>就是抽象出来的概念。</p>
<p>抽象类：Java中可以定义<strong>没有方法体</strong>的方法，该方法的具体实现由<strong>子类完成</strong>，该方法称为<strong>抽象方法</strong>，包含抽象方法的类就是抽象类。</p>
<p>抽象方法的由来：多个对象都具备相同的功能，但是功能<strong>具体内容有所不同</strong>，那么在抽取过程中，只抽取了功能定义，并未抽取功能主体，那么<strong>只有功能声明</strong>，<strong>没有功能主体</strong>的方法称为抽象方法。</p>
<p>例如：狼和狗<strong>都有吼叫的方</strong>法，可是<strong>吼叫内容是不一样</strong>的。所以抽象出来的犬科虽然有吼叫功能，但是并<strong>不明确吼叫的细节</strong>。</p>
<p>抽象类实际上是定义了一个标准和规范，等着他的子类们去实现。</p>
<h4 id="抽象类的特点"><a href="#抽象类的特点" class="headerlink" title="抽象类的特点"></a>抽象类的特点</h4><p>抽象类不能创建实例，只能当成父类来被继承。</p>
<p>抽象类体现的就是一种模板模式的设计，抽象类作为多个子类的通用模板。</p>
<p>定义抽象类时需要注意，包含抽象方法的类必须声明为抽象类,但抽象类可以不包含任何抽象方法，只需使用abstract关键字来修饰即可</p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>当一个抽象类中的<strong>方法都是抽象</strong>的时候，这时可以将该抽象类用另一种形式定义和表示，就是<strong>接口</strong>。</p>
<p>格式：interface {} 接口中的成员修饰符是固定的： 成员常量：public static final 成员函数：public abstract</p>
<p>由此得出结论，接口中的成员都是公共的权限 接口是对外暴露的规则 接口是程序的功能扩展。</p>
<ul>
<li>在java中不直接支持多继承，因为会出现调用的不确定性。</li>
<li>在java中变成了多实现，一个类可以实现多个接口，接口的出现避免了单继承的局限性。</li>
</ul>
<h3 id="抽象类和接口的异同点？"><a href="#抽象类和接口的异同点？" class="headerlink" title="抽象类和接口的异同点？"></a>抽象类和接口的异同点？</h3><p>相同点：都是<strong>不断向上抽取</strong>而来的。</p>
<p>不同点：</p>
<ol>
<li>抽象类需要被继承，而且只能<strong>单继承</strong>。接口需要被实现，而且可以<strong>多实现</strong>。</li>
<li>抽象类中可以定义抽象方法和<strong>非抽象方法</strong>，子类继承后，可以<strong>直接使用非抽象方法</strong>。接口中只能定义抽象方法，<strong>必须由子类去实现</strong>。</li>
<li>抽象类的继承，是<strong>is a</strong>关系，定义该体系的基本共性内容。接口的实现是<strong>like a关系</strong></li>
</ol>
<p>tips：关于Is-a、has-a、like-a的使用场景：</p>
<p><strong>如果A,B是Is-a关系，那么应该使用继承，</strong>例：玻璃杯、塑料杯都是杯子。</p>
<p><strong>如果A,B是has-a关系，那么应该是用聚合，</strong>例：汽车由发动机，底盘，车身，电气设备等组成，那么应该把发动机，底盘这些类聚合成汽车。</p>
<p><strong>如果A,B是like-a关系，那么应该使用组合，</strong>例：空调继承于制冷机，但它同时有加热功能，那么你应该把让空调继承制冷机类，并实现加热接口。</p>
<h3 id="Java8改进的接口"><a href="#Java8改进的接口" class="headerlink" title="Java8改进的接口"></a>Java8改进的接口</h3><p>Java 8 对接口进行了改进，允许在接口中定义默认方法，默认方法可以提供方法实现。</p>
<h3 id="深入理解Java的接口和抽象类"><a href="#深入理解Java的接口和抽象类" class="headerlink" title="深入理解Java的接口和抽象类"></a>深入理解Java的接口和抽象类</h3><h4 id="抽象类-1"><a href="#抽象类-1" class="headerlink" title="抽象类"></a>抽象类</h4><p>在《Java编程思想》一书中，将抽象类定义为“包含抽象方法的类”</p>
<p>抽象类就是为了继承而存在的，如果你定义了一个抽象类，却不去继承它，那么等于白白创建了这个抽象类</p>
<ul>
<li>抽象方法必须为public或者protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public</li>
<li>抽象类不能用来创建对象</li>
<li>如果一个类继承于一个抽象类，则子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为为abstract类</li>
</ul>
<h4 id="接口-1"><a href="#接口-1" class="headerlink" title="接口"></a>接口</h4><p>接口中可以含有 变量和方法。但是要注意，</p>
<ul>
<li>接口中的变量会被隐式地指定为public static final变量（并且只能是public static final变量，用private修饰会报编译错误）</li>
<li>方法会被隐式地指定为public abstract方法且只能是public abstract方法（用其他关键字，比如private、protected、static、 final等修饰会报编译错误</li>
<li>接口中的方法必须都是抽象方法</li>
<li>接口是一种极度抽象的类型，它比抽象类更加“抽象”，并且一般情况下不在接口中定义变量。</li>
<li>接口是一种极度抽象的类型，它比抽象类更加“抽象”，并且一般情况下不在接口中定义变量。</li>
</ul>
<p>接口定义了一种<strong>规范</strong>，接口定义了某一批类<strong>所需要遵守的规范</strong>，接口不关心这些类的内部状态数据，也不关心这些类的内部方法的实现细节，它只规定这批类里<strong>必须提供某些方法</strong>，提供这些方法的类就可满足实际需要。</p>
<p>接口体现的是<strong>规范和实现分离</strong>的设计哲学。让规范和实现分离正是接口的好处，让软件系统的各组件之间面向接口耦合，是一种<strong>松耦合</strong>的设计。</p>
<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>定义：将一个类定义在另一个类的里面，里面那个类就称为内部类（内置类，嵌套类）。</p>
<p>访问特点：内部类可以直接访问外部类中的成员，包括私有成员。而外部类要访问内部类中的成员<strong>必须要建立内部类的对象</strong>。</p>
<h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>定义：就是内部类的简化写法。前提：内部类可以继承或实现一个外部类或者接口</p>
<p> 格式：new 外部类名或者接口名(){覆盖类或者接口中的代码，(也可以自定义内容。)}</p>
<p>什么时候使用匿名内部类呢？ 通常使用方法是<strong>接口类型参数</strong>，并且该接口中的方法不超过三个，可以将匿名内部类作为参数传递。</p>
<p>好处：增强阅读性。</p>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>异常：是在运行时期发生的<strong>不正常情况</strong>。 在java中用类的形式对不正常情况进行了<strong>描述和封装对象</strong>。描述不正常的情况的类，就称为异常类。</p>
<p>其实异常就是java通过面向对象的思想将问题封装成了对象，用异常类对其进行描述。</p>
<h2 id="常用对象"><a href="#常用对象" class="headerlink" title="常用对象"></a>常用对象</h2><h3 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h3><ul>
<li>字符串是常量,它的值在创建之后不能更改</li>
<li>Java 程序中的所有字符串字面值（如 “abc” ）都作为此类的实例实现。</li>
<li>字符串如果是变量相加，先开空间，在拼接。</li>
<li>字符串如果是常量相加，是先加，然后在常量池找，如果有就直接返回，否则，就创建。</li>
</ul>
<h4 id="StringBuffer与StringBuilder的区别？"><a href="#StringBuffer与StringBuilder的区别？" class="headerlink" title="** StringBuffer与StringBuilder的区别？**"></a>** StringBuffer与StringBuilder的区别？**</h4><p>StringBuffer和StringBuilder类都表示内容可以被修改的字符串，StringBuilder是线程不安全的，运行效率高，如果一个字符串变量是在方法里面定义，这种情况只可能有一个线程访问它，不存在不安全的因素了，则用StringBuilder。如果要在类里面定义成员变量，并且这个类的实例对象会在多线程环境下使用，那么最好用StringBuffer。</p>
<p>String常用方法</p>
<p><img src="/images/JavaSE/String.png" alt=""></p>
<p>StringBuffer常用方法</p>
<img src="/images/JavaSE/stringbuffer.jpg" style="zoom:80%;" />

<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>正则表达式（Regular Expressio）：是<strong>对字符串操作</strong>的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种<strong>过滤逻辑</strong>。</p>
<h2 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h2><img src="/images/JavaSE/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6.png" style="zoom:80%;" />

<h3 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a><strong>Collection接口</strong></h3><h4 id="集合类概述"><a href="#集合类概述" class="headerlink" title="集合类概述"></a>集合类概述</h4><p>数组的长度不可变，JDK中提供了一系列特殊的类，这些类可以<strong>存储任意类型的对象</strong>，并且<strong>长度可变</strong>，在Java中这些类被统称为<strong>集合</strong>。</p>
<p>集合类都位于java.util包中</p>
<h4 id="为什么出现集合类？"><a href="#为什么出现集合类？" class="headerlink" title="为什么出现集合类？"></a>为什么出现集合类？</h4><p>面向对象语言对事物的体现都是以对象的形式，所以为了<strong>方便对多个对象的操作</strong>，Java就提供了集合类。</p>
<h4 id="数组与集合区别"><a href="#数组与集合区别" class="headerlink" title="数组与集合区别"></a>数组与集合区别</h4><img src="/images/JavaSE/image-20201002185533893.png" alt="image-20201002185533893" style="zoom:67%;" />

<h4 id="集合类的特点"><a href="#集合类的特点" class="headerlink" title="集合类的特点"></a>集合类的特点</h4><p>集合只用于<strong>存储对象</strong>，集合长度是可变的，集合可以存储<strong>不同类型的对象</strong>。</p>
<h4 id="Collection接口概述"><a href="#Collection接口概述" class="headerlink" title="Collection接口概述"></a>Collection接口概述</h4><p>Collection：单列集合类的根接口，用于存储一系列符合某种规则的元素，它有两个重要的子接口，分别是List和Set。其中，List的特点是元素有序、元素可重复。Set的特点是元素无序，而且不可重复。List接口的主要实现类有ArrayList和LinkedList，Set接口的主要实现类有HashSet和TreeSet。</p>
<img src="/images/JavaSE/Collection_04.png" style="zoom:80%;" />

<img src="/images/JavaSE/Collection_05.png" style="zoom:67%;" />

<h4 id="List接口概述"><a href="#List接口概述" class="headerlink" title="List接口概述"></a>List接口概述</h4><p>List集合的特性是：<strong>有序，可重复，元素有索引</strong>，List接口有三个实现类：</p>
<ul>
<li>ArrayList：底层数据结构是<strong>数组</strong>，查询快，增删慢，非线程安全，效率高，数据增长为原来的<strong>50%</strong></li>
<li>Vector：底层数据结构是<strong>数组，</strong>查询快，增删慢，<strong>线程安全</strong>，<strong>效率低</strong>，数据增长为原来的<strong>一倍</strong> （现在直接用<code>ArrayList</code>代替了）</li>
<li>LinkedList：底层数据结构是<strong>链表</strong>，<strong>查询慢</strong>，<strong>增删快</strong>，非线程安全，效率高</li>
</ul>
<h4 id="Set接口概述"><a href="#Set接口概述" class="headerlink" title="Set接口概述"></a>Set接口概述</h4><p>一个<strong>不包含重复</strong>元素的 collection，<strong>无序</strong>。</p>
<p>哈希表确定元素是否相同</p>
<p>1、 判断的是两个元素的<strong>哈希值</strong>是否相同。 如果相同，再判断两个<strong>对象的内容</strong>是否相同。</p>
<p>2、 判断哈希值相同，其实判断的是对象的<strong>HashCode</strong>方法。判断内容相同，用的是<strong>equals</strong>方法。</p>
<h4 id="LinkedHashSet类概述"><a href="#LinkedHashSet类概述" class="headerlink" title="LinkedHashSet类概述"></a>LinkedHashSet类概述</h4><p>元素有序唯一，由链表保证元素有序，由哈希表保证元素唯一。</p>
<h4 id="TreeSet类概述"><a href="#TreeSet类概述" class="headerlink" title="TreeSet类概述"></a>TreeSet类概述</h4><p>使用元素的自然顺序对元素进行排序，或者根据创建 set 时提供的 Comparator 进行排序，具体取决于使用的构造方法。</p>
<h3 id="集合的遍历"><a href="#集合的遍历" class="headerlink" title="集合的遍历"></a>集合的遍历</h3><p>在程序开发中，经常需要遍历集合中的所有元素。针对这种需求，JDK专门提供了一个接口Iterator。</p>
<p>Iterator主要用于迭代访问（即遍历）Collection中的元素，因此Iterator对象也被称为迭代器。</p>
<p>需要特别说明的是，当通过迭代器获取ArrayList集合中的元素时，都会将这些元素当做Object类型来看待，如果想得到特定类型的元素，则需要进行<strong>强制类型转换</strong>。</p>
<p>迭代：是取出集合中元素的一种方式。</p>
<p>而每一个容器的数据结构不同，所以取出的动作细节也不一样。但是都具有共性内容： 判断和取出。那么就可以将这些共性抽取。那么这些内部类都符合一个规则（或者说都抽取出来一个规则）。该规则就是Iterator。通过一个对外提供的方法：iterator();，来获取集合的取出对象。因为Collection中有iterator方法，所以<strong>每一个子类集合对象都具备迭代器</strong>。</p>
<h3 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a>Collections工具类</h3><h4 id="Collections类概述"><a href="#Collections类概述" class="headerlink" title="Collections类概述"></a>Collections类概述</h4><p>针对集合操作 的工具类，里面的方法都是静态的，可以对集合进行排序、二分查找、反转、混排等。</p>
<h4 id="Collection和Collections的区别"><a href="#Collection和Collections的区别" class="headerlink" title="Collection和Collections的区别"></a>Collection和Collections的区别</h4><ol>
<li>Collection:是单列集合的顶层接口，有子接口List和Set。</li>
<li>Collections:是针对集合操作的工具类，有对集合进行排序和二分查找等方法</li>
</ol>
<h4 id="Arrays工具类"><a href="#Arrays工具类" class="headerlink" title="Arrays工具类"></a>Arrays工具类</h4><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>此类包含用来操作数组（比如排序和搜索）的各种方法。此类还包含一个允许将数组作为列表来查看的静态工厂。</p>
<h3 id="Map接口概述"><a href="#Map接口概述" class="headerlink" title="Map接口概述"></a>Map接口概述</h3><p>Map：双列集合类的根接口，用于<strong>存储具有键(Key)、值(Value)映射关系</strong>的元素，每个元素都包含<strong>一对键值</strong>，在使用Map集合时可以通过指定的<strong>Key找到对应的Value</strong>，例如根据一个学生的学号就可以找到对应的学生。Map接口的主要实现类有HashMap和TreeMap。</p>
<p>Map常用的子类：</p>
<ul>
<li>Hashtable：内部结构是哈希表，是同步的。不允许null作为键，null作为值。</li>
<li>Properties：用来存储键值对型的配置文件的信息，可以和IO技术相结合。</li>
<li>HashMap：内部结构式哈希表，不是同步的。允许null作为键，null作为值。</li>
<li>TreeMap：内部结构式二叉树，不是同步的。可以对Map结合中的键进行排序。</li>
<li>HashSet实现Set接口，由哈希表（实际上是一个HashMap实例）支持。</li>
</ul>
<blockquote>
<p>文件名： JavaSE</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>运用递归解决树的问题</title>
    <url>/2020/09/23/LEBT2/</url>
    <content><![CDATA[<h1 id="题目：-运用递归解决树的问题"><a href="#题目：-运用递归解决树的问题" class="headerlink" title="题目： 运用递归解决树的问题"></a>题目： <a href="https://leetcode-cn.com/leetbook/read/data-structure-binary-tree/xefb4e/" target="_blank" rel="noopener">运用递归解决树的问题</a></h1><ul>
<li><p>树可以以递归的方式定义为一个节点（根节点），它包括一个值和一个指向其他节点指针的列表。</p>
</li>
<li><p>递归是<strong>树的特性之一</strong>。 因此，许多树问题可以通过递归的方式来解决。</p>
</li>
<li><p>对于每个递归层级，我们只能关注<strong>单个节点内的问题</strong>，并通过<strong>递归调用函数</strong>来解决其<strong>子节点问题</strong>。</p>
</li>
<li><p>通常，我们可以通过 “<strong>自顶向下</strong>” 或 “<strong>自底向上”</strong> 的递归来解决树问题。</p>
<p>以<em>给定一个二叉树，请寻找它的最大深度</em>为例</p>
</li>
</ul>
<ol>
<li>「<strong>自顶向下</strong>」: 注意我们刚才画的递归树（或者说图），是从上向下延伸，都是从一个规模较大的原问题比如说 <code>f(20)</code>，向下逐渐分解规模，直到 <code>f(1)</code> 和 <code>f(2)</code> 这两个 base case，然后<strong>逐层返回答案</strong>，这就叫「自顶向下」。</li>
<li>「自底向上」:反过来，我们直接从最底下，最简单，问题规模最小的 <code>f(1)</code> 和 <code>f(2)</code> 开始<strong>往上推</strong>，直到推到我们想要的答案 <code>f(20)</code>，这就是动态规划的思路，这也是为什么动态规划一般都<strong>脱离了递归</strong>，而是由循环迭代完成计算。</li>
</ol>
<h2 id="自顶向下"><a href="#自顶向下" class="headerlink" title="自顶向下"></a>自顶向下</h2><p>核心：每个递归层级，我们将首先<strong>访问节点</strong>来计算一些值，并在递归调用函数时将这些值<strong>传递到子节点</strong>。</p>
<p><strong>TIPS:</strong> 从大规模问题，向下分解规模到base case，然后逐层返回答案</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> answer;		<span class="comment">// don't forget to initialize answer before call maximum_depth</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">maximum_depth</span><span class="params">(TreeNode root, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">        answer = Math.max(answer, depth);</span><br><span class="line">    &#125;</span><br><span class="line">    maximum_depth(root.left, depth + <span class="number">1</span>);</span><br><span class="line">    maximum_depth(root.right, depth + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="自底向上"><a href="#自底向上" class="headerlink" title="自底向上"></a>自底向上</h2><p>核心：在每个递归层次上，我们首先对所有子节点递归地调用函数，然后<strong>根据返回值</strong>和根节点本身的值得到答案。</p>
<p>*<em>TIPs: *</em>从最小规模往上推</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximum_depth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;                                   <span class="comment">// return 0 for null node</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> left_depth = maximum_depth(root.left);</span><br><span class="line">	<span class="keyword">int</span> right_depth = maximum_depth(root.right);</span><br><span class="line">	<span class="keyword">return</span> Math.max(left_depth, right_depth) + <span class="number">1</span>;	<span class="comment">// return depth of the subtree rooted at root</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<blockquote>
<p>文件名：LBT2</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCodeExplore</tag>
        <tag>LeetcodeExploreBT</tag>
      </tags>
  </entry>
  <entry>
    <title>算法学习笔记（一）</title>
    <url>/2020/07/26/Algorithm1/</url>
    <content><![CDATA[<h1 id="算法基础"><a href="#算法基础" class="headerlink" title="算法基础"></a>算法基础</h1><h2 id="数据结构的存储方式"><a href="#数据结构的存储方式" class="headerlink" title="数据结构的存储方式"></a><a href="https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/xue-xi-shu-ju-jie-gou-he-suan-fa-de-gao-xiao-fang-fa#yi-shu-ju-jie-gou-de-cun-chu-fang-shi" target="_blank" rel="noopener">数据结构的存储方式</a></h2><h3 id="底层基础数据储存方式：数组、链表。"><a href="#底层基础数据储存方式：数组、链表。" class="headerlink" title="底层基础数据储存方式：数组、链表。"></a>底层基础数据储存方式：<strong>数组、链表</strong>。</h3><p>优缺点比较：</p>
<ul>
<li>数组：紧凑连续存储，随机访问，节约空间；需要一次分配足够大的空间，否则需要扩容操作，插入删除操作需要挪动保证连续O(n)。</li>
<li>链表：存储元素不连续，无扩容问题，知道前驱后驱，可直接插入O(1)；无法根据索引得到地址，不能随机访问，指针消耗存储空间。</li>
</ul>
<h3 id="高级数据结构"><a href="#高级数据结构" class="headerlink" title="高级数据结构"></a>高级数据结构</h3><p><strong>图</strong>：两种表示方法：<strong>邻接表</strong>-&gt;链表，<strong>邻接矩阵</strong>-&gt;二维数组</p>
<p><strong>散列表</strong>：</p>
<ul>
<li><p>定义：散列函数把键映射到一个大数组。</p>
</li>
<li><p>解决散列冲突：拉链法，线性探查法。</p>
</li>
</ul>
<p><strong>树</strong>：两种表示方法：堆（完全二叉树）-&gt;数组存储；链表衍生-&gt;二叉搜索树、AVL 树、红黑树、区间树、B 树等</p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>Java常用方法</title>
    <url>/2020/09/30/JavaMethod/</url>
    <content><![CDATA[<h1 id="Java常用方法"><a href="#Java常用方法" class="headerlink" title="Java常用方法"></a>Java常用方法</h1><h3 id=""><a href="#" class="headerlink" title=""></a></h3><blockquote>
<p>文件名：JavaMethod</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaWeb(一)</title>
    <url>/2020/07/25/javaweb1/</url>
    <content><![CDATA[<h1 id="HTML-amp-CSS"><a href="#HTML-amp-CSS" class="headerlink" title="HTML&amp;CSS"></a>HTML&amp;CSS</h1><h2 id="B-S软件结构"><a href="#B-S软件结构" class="headerlink" title="B/S软件结构"></a>B/S软件结构</h2><h2 id="一些标签"><a href="#一些标签" class="headerlink" title="一些标签"></a>一些标签</h2><h4 id="table"><a href="#table" class="headerlink" title="table"></a>table</h4><ul>
<li><p><strong>tr</strong>   table data row</p>
</li>
<li><p><strong>td</strong>  table data cell</p>
</li>
<li><p><strong>th</strong> table header cell</p>
</li>
</ul>
<h2 id="css-选择器"><a href="#css-选择器" class="headerlink" title="css 选择器"></a>css 选择器</h2><ol>
<li>标签名选择器  div{ }</li>
<li>id选择器 <strong>#</strong>id { } id=””</li>
<li>class选择器 <strong>.</strong>class{ }  class=””</li>
<li>组合选择器  1，2，3…{ }</li>
</ol>
<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>JS是弱类型语言，定义变量的时候类型不确定可变。</p>
<h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><ol>
<li>交互（浏览器页面信息动态交互，用户输入与客户端反馈）</li>
<li>安全性（不允许直接访问本地硬盘）</li>
<li>跨平台性（只要是可以解释JS的浏览器都可以执行，平台无关）</li>
</ol>
<h2 id="与Html结合"><a href="#与Html结合" class="headerlink" title="与Html结合"></a>与Html结合</h2><ol>
<li>直接在body，head 中用<script>标签引入</li>
<li>单独写在js文件中，用<script>引入</li>
</ol>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><h3 id="文本和属性"><a href="#文本和属性" class="headerlink" title="文本和属性"></a><a href="https://zh.javascript.info/object#wen-ben-he-shu-xing" target="_blank" rel="noopener">文本和属性</a></h3><p>我们可以在创建对象的时候，立即将一些属性以键值对的形式放到 <code>{...}</code> 中。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;     <span class="comment">// 一个对象</span></span><br><span class="line">  name: <span class="string">"John"</span>,  <span class="comment">// 键 "name"，值 "John"</span></span><br><span class="line">  age: <span class="number">30</span>        <span class="comment">// 键 "age"，值 30</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>属性有键（或者也可以叫做“名字”或“标识符”），位于冒号 <code>&quot;:&quot;</code> 的前面，值在冒号的右边。</p>
<p>在 <code>user</code> 对象中，有两个属性：</p>
<ol>
<li>第一个的键是 <code>&quot;name&quot;</code>，值是 <code>&quot;John&quot;</code>。</li>
<li>第二个的键是 <code>&quot;age&quot;</code>，值是 <code>30</code>。</li>
</ol>
<p>生成的 <code>user</code> 对象可以被想象为一个放置着两个标记有 “name” 和 “age” 的文件的柜子。</p>
<p>我们可以随时添加、删除和读取文件。</p>
<p>可以使用点符号访问属性值：</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>自动扩容</p>
<h3 id="数组可以存储任何类型的元素。"><a href="#数组可以存储任何类型的元素。" class="headerlink" title="数组可以存储任何类型的元素。"></a>数组可以存储任何类型的元素。</h3><p>例如:</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 混合值</span></span><br><span class="line"><span class="keyword">let</span> arr = [ <span class="string">'Apple'</span>, &#123; <span class="attr">name</span>: <span class="string">'John'</span> &#125;, <span class="literal">true</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; alert(<span class="string">'hello'</span>); &#125; ];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取索引为 1 的对象然后显示它的 name</span></span><br><span class="line">alert( arr[<span class="number">1</span>].name ); <span class="comment">// John</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取索引为 3 的函数并执行</span></span><br><span class="line">arr[<span class="number">3</span>](); <span class="comment">// hello</span></span><br></pre></td></tr></table></figure></div>

<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="定义方式"><a href="#定义方式" class="headerlink" title="定义方式"></a>定义方式</h3><ol>
<li><code>function fun() {}</code> 直接加return 代表有返回值</li>
<li><code>var fun =fuction() { }</code></li>
</ol>
<h3 id="js函数不能重载，只会覆盖上层定义"><a href="#js函数不能重载，只会覆盖上层定义" class="headerlink" title="js函数不能重载，只会覆盖上层定义"></a>js函数不能重载，只会覆盖上层定义</h3><h3 id="arguments隐形参数（只在function内部，无需定义）"><a href="#arguments隐形参数（只在function内部，无需定义）" class="headerlink" title="arguments隐形参数（只在function内部，无需定义）"></a>arguments隐形参数（只在function内部，无需定义）</h3><p>类似于传入参数的可变长数组集合</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">fun(<span class="number">1</span>,<span class="string">"a"</span>,<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">alert(<span class="built_in">arguments</span>[<span class="number">0</span>]) <span class="comment">//1</span></span><br><span class="line">alert(<span class="built_in">arguments</span>[<span class="number">1</span>]) <span class="comment">//"a"</span></span><br><span class="line">alert(<span class="built_in">arguments</span>[<span class="number">2</span>])  <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">亦可进行遍历</span><br><span class="line"></span><br><span class="line">js中+ 不同类型为字符串拼接</span><br></pre></td></tr></table></figure></div>

<h3 id="自定义对象"><a href="#自定义对象" class="headerlink" title="自定义对象"></a>自定义对象</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="keyword">new</span> object()</span><br><span class="line">name.value = value;</span><br><span class="line">name.fun =<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">访问</span><br><span class="line">name.value</span><br><span class="line"></span><br><span class="line">&#123;&#125; <span class="comment">//自定义空对象 object类</span></span><br><span class="line"><span class="keyword">var</span> variable =&#123;</span><br><span class="line">    name1:value,</span><br><span class="line">    name2,value,</span><br><span class="line">    name_of_function : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="js事件"><a href="#js事件" class="headerlink" title="js事件"></a>js事件</h3><h4 id="常用事件"><a href="#常用事件" class="headerlink" title="常用事件"></a>常用事件</h4><ul>
<li><strong>onload</strong> ：浏览器解析完自动触发事件</li>
<li><strong>onclick</strong> :   常用于按钮的点击响应操作。</li>
<li><strong>onblur</strong> : 失去焦点事件： 常用用于输入框失去焦点后验证其输入内容是否合法。</li>
<li><strong>onchange</strong> : 内容发生改变事件： 常用于下拉列表和输入框内容发生改变后操作</li>
<li><strong>onsubmit</strong>  : 表单提交事件： 常用于表单提交前，验证所有表单项是否合法</li>
</ul>
<h4 id="静态注册和动态注册"><a href="#静态注册和动态注册" class="headerlink" title="静态注册和动态注册"></a>静态注册和动态注册</h4><p>注册：告诉浏览器，当时间响应后执行哪些操作代码，叫事件注册</p>
<p>静态：html事件属性直接赋值于事件响应后的代码 【标签中添加】</p>
<p>动态：通过js代码得到标签的dom对象，通过dom对象.事件名 = functiong(){} 赋予事件响应后代码 【通过id获取 然后通过标签进行】</p>
<p>动态注册<strong>基本步骤</strong>：</p>
<ol>
<li>获取标签对象</li>
<li>标签对象.事件名= functiong(){}</li>
</ol>
<p><strong>onload</strong> 加载完成事件</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// onload 事件动态注册。是固定写法</span></span><br><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">alert(<span class="string">" 动态注册的 onload  事件"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态注册 onload 事件</span></span><br><span class="line"><span class="comment">//onload 事件是浏览器解析完页面之后就会自动触发的事件</span></span><br><span class="line">&lt;body onload=<span class="string">"onloadFun();"</span>&gt;</span><br></pre></td></tr></table></figure></div>

<p> <strong>onclick</strong> 单击事件</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 动态注册 onclick 事件</span></span><br><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">// 1 获取标签对象</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* document 是 JavaScript 语言提供的一个对象（文档） &lt;br/&gt;</span></span><br><span class="line"><span class="comment">* getElementById 通过 id 属性获取标签对象</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">var</span> btnObj = <span class="built_in">document</span>.getElementById(<span class="string">"btn01"</span>);</span><br><span class="line"><span class="comment">// alert( btnObj );</span></span><br><span class="line"><span class="comment">// 2 通过标签对象 . 事件名 = function()&#123;&#125;</span></span><br><span class="line">btnObj.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">alert(<span class="string">" 动态注册的 onclick  事件"</span>);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">  &lt;!-- 静态注册 onClick 事件 --&gt;</span><br><span class="line">&lt;button onclick=<span class="string">"onclickFun();"</span>&gt;按钮 <span class="number">1</span> &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&lt;button id="btn01"&gt;按钮 2&lt;/</span>button&gt;</span><br></pre></td></tr></table></figure></div>

<p><strong>onblur</strong> 失去焦点事件</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 静态注册失去焦点事件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onblurFun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">// console 是控制台对象，是由 JavaScript 语言提供，专门用来向浏览器的控制器打印输出， 用于测试使用</span></span><br><span class="line"><span class="comment">// log() 是打印的方法</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">" 静态注册失去焦点事件"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态注册 onblur 事件 利用id获取</span></span><br><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">//1 获取标签对象</span></span><br><span class="line"><span class="keyword">var</span> passwordObj = <span class="built_in">document</span>.getElementById(<span class="string">"password"</span>);</span><br><span class="line"><span class="comment">// alert(passwordObj);</span></span><br><span class="line"><span class="comment">//2 通过标签对象 . 事件名 = function()&#123;&#125;;</span></span><br><span class="line">passwordObj.onblur = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">" 动态注册失去焦点事件"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">用户名:<span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">onblur</span>=<span class="string">"onblurFun();"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span></span><br><span class="line">密码:&lt;input id="password" type="text" &gt;&lt;br/&gt;</span><br></pre></td></tr></table></figure></div>

<p><strong>onchange</strong> 内容发生改变事件</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onchangeFun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">alert(<span class="string">" 女神已经改变了"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">//1 获取标签对象</span></span><br><span class="line"><span class="keyword">var</span> selObj = <span class="built_in">document</span>.getElementById(<span class="string">"sel01"</span>);</span><br><span class="line"><span class="comment">// alert( selObj );</span></span><br><span class="line"><span class="comment">//2 通过标签对象 . 事件名 = function()&#123;&#125;</span></span><br><span class="line">selObj.onchange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">alert(<span class="string">" 男神已经改变了"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;!-- 静态注册 onchange 事件 --&gt;</span></span><br><span class="line"><span class="regexp">&lt;select onchange="onchangeFun();"&gt;</span></span><br><span class="line"><span class="regexp">&lt;option&gt;--女神--&lt;/</span>option&gt;</span><br><span class="line">&lt;option&gt;芳芳&lt;<span class="regexp">/option&gt;</span></span><br><span class="line"><span class="regexp">&lt;option&gt;佳佳&lt;/</span>option&gt;</span><br><span class="line">&lt;option&gt;娘娘&lt;<span class="regexp">/option&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>select&gt;</span><br><span class="line"></span><br><span class="line">请选择你心中的男神：</span><br><span class="line">&lt;select id=<span class="string">"sel01"</span>&gt;</span><br><span class="line">&lt;option&gt;--男神--&lt;<span class="regexp">/option&gt;</span></span><br><span class="line"><span class="regexp">&lt;option&gt;国哥&lt;/</span>option&gt;</span><br><span class="line">&lt;option&gt;华仔&lt;<span class="regexp">/option&gt;</span></span><br><span class="line"><span class="regexp">&lt;option&gt;富城&lt;/</span>option&gt;</span><br><span class="line">&lt;<span class="regexp">/select&gt;</span></span><br></pre></td></tr></table></figure></div>

<p><strong>onsubmit</strong>  : 表单提交事件</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span> &gt;</span><br><span class="line"><span class="comment">// 静态注册表单提交事务</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onsubmitFun</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">// 要验证所有表单项是否合法，如果，有一个不合法就阻止表单提交</span></span><br><span class="line">alert(<span class="string">" 静态注册表单提交事件---- 发现不合法"</span>);</span><br><span class="line"><span class="keyword">return</span> flase;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">//1 获取标签对象</span></span><br><span class="line"><span class="keyword">var</span> formObj = <span class="built_in">document</span>.getElementById(<span class="string">"form01"</span>);</span><br><span class="line"><span class="comment">//2 通过标签对象 . 事件名 = function()&#123;&#125;</span></span><br><span class="line">formObj.onsubmit = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">// 要验证所有表单项是否合法，如果，有一个不合法就阻止表单提交</span></span><br><span class="line">alert(<span class="string">" 动态注册表单提交事件---- 发现不合法"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;!--return false 可以阻止 表单提交 --&gt;</span></span><br><span class="line"><span class="regexp">&lt;form action="http:/</span><span class="regexp">/localhost:8080" method="get" onsubmit="return onsubmitFun();"&gt;</span></span><br><span class="line"><span class="regexp">&lt;input type="submit" value=" 静态注册"/</span>&gt;</span><br><span class="line">&lt;<span class="regexp">/form&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;form action="http:/</span><span class="regexp">/localhost:8080" id="form01"&gt;</span></span><br><span class="line"><span class="regexp">&lt;input type="submit" value=" 动态注册"/</span>&gt;</span><br><span class="line">&lt;<span class="regexp">/form&gt;</span></span><br></pre></td></tr></table></figure></div>

<h2 id="JavaScript-HTML-DOM"><a href="#JavaScript-HTML-DOM" class="headerlink" title="JavaScript HTML DOM"></a>JavaScript HTML DOM</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><strong>DOM</strong> 全称是 Document Object Model 文档对象模型<br>把文档中的标签，属性，文本，<strong>转换成为对象管理。</strong></p>
<p><img src="/images/javaweb1/pic_htmltree.gif" alt="DOM HTML tree"></p>
<h3 id="Document-对象中的方法介绍"><a href="#Document-对象中的方法介绍" class="headerlink" title="Document  对象中的方法介绍"></a>Document  对象中的方法介绍</h3><ul>
<li><p>document.getElementBy<strong>Id</strong>(elementId)<br>通过标签的 id 属性查找标签 dom 对象，elementId 是标签的 id 属性值，</p>
</li>
<li><p>document.getElementsBy<a href="https://www.runoob.com/jsref/met-doc-getelementsbyname.html" target="_blank" rel="noopener"><strong>Name</strong></a>(elementName)<br>通过标签的 name 属性查找标签 dom 对象，elementName 标签的 name 属性值, 返回对象集合</p>
</li>
<li><p>document.getElementsBy<strong>TagName</strong>(tagname)<br>通过标签名查找标签 dom 对象。tagname 是标签名，, 返回对象集合</p>
</li>
<li><p>document.<strong>createElement(</strong> tagName)<br>方法，通过给定的标签名，创建一个标签对象。tagName 是要创建的标签名</p>
<p>注：优先用id查询其余依次往后范围扩大。</p>
<p>返回对象为空时考虑页面加载完后显示：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;如 document.body</span><br><span class="line"></span><br><span class="line">window.onload &#x3D; function() &#123;</span><br><span class="line"></span><br><span class="line">document.body.appendChild(divobject);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; window.onload 为DOM时间对象通常用于 &lt;body&gt; 元素，在页面完全载入后(包括图片、css文件等等。)执行脚本代码。</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;appendChild 为DOM元素对象</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



</li>
</ul>
<h4 id="document-getElementById-elementId"><a href="#document-getElementById-elementId" class="headerlink" title="document.getElementById(elementId)"></a>document.getElementBy<strong>Id</strong>(elementId)</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> usernameSpanObj = <span class="built_in">document</span>.getElementById(<span class="string">"usernameSpan"</span>);</span><br><span class="line"><span class="comment">// innerHTML 表示起始标签和结束标签中的内容</span></span><br><span class="line"><span class="comment">// innerHTML 这个属性可读，可写</span></span><br><span class="line">usernameSpanObj.innerHTML = <span class="string">""</span>;</span><br><span class="line">usernameSpanObj.innerHTML = <span class="string">"&lt;img src=\"right.png\" width=\"18\" height=\"18\"&gt;"</span>;</span><br><span class="line"><span class="comment">//可放如图片等标签内容验证搜索</span></span><br></pre></td></tr></table></figure></div>







<h3 id="JavaScript-RegExp-对象-正则表达式"><a href="#JavaScript-RegExp-对象-正则表达式" class="headerlink" title="JavaScript RegExp 对象[正则表达式]"></a><a href="https://www.runoob.com/jsref/jsref-obj-regexp.html" target="_blank" rel="noopener">JavaScript RegExp 对象[正则表达式]</a></h3><ul>
<li>语法</li>
<li>修饰符</li>
<li>方括号</li>
<li>元字符</li>
<li>量词</li>
<li>对象方法</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> patt = <span class="regexp">/^\w&#123;5,12&#125;$/</span>;</span><br><span class="line"><span class="comment">// 大意：必须由字母，数字。下划线组成。并且长度是 5 到 12 位</span></span><br><span class="line"><span class="comment">// /^a/,以a打头;</span></span><br><span class="line"><span class="comment">// /a$/,以a结尾;</span></span><br><span class="line"><span class="comment">// /^a$/,从头到尾都是a,即“a”</span></span><br><span class="line"><span class="comment">// \w 单词字符</span></span><br><span class="line"><span class="comment">// &#123;5，12&#125; 5到12位</span></span><br></pre></td></tr></table></figure></div>

<h1 id="JQuery"><a href="#JQuery" class="headerlink" title="JQuery"></a>JQuery</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="什么是-jQuery"><a href="#什么是-jQuery" class="headerlink" title="什么是 jQuery ?"></a>什么是 jQuery ?</h3><p>jQuery，顾名思义，也就是 JavaScript 和查询（Query），它就是辅助 JavaScript 开发的 <strong>js 类库</strong>。</p>
<p>jQuery  <strong>核心思想</strong><br>它的核心思想是 write less,do more(写得更少,做得更多)，所以它实现了很多浏览器的兼容问题。</p>
<p>jQuery  <strong>好处</strong><br>jQuery 是免费、开源的，jQuery 的语法设计可以使开发更加便捷，例如操作文档对象、选择 DOM 元素、制作动画效果、事件处理、使用 Ajax 以及其他功能。</p>
<h2 id="第一个单击事件程序"><a href="#第一个单击事件程序" class="headerlink" title="第一个单击事件程序"></a>第一个单击事件程序</h2><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入下载好的JQuery包</span></span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"../script/jquery-1.7.2.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">$(function () &#123; /</span><span class="regexp">/ 表示页面加载完成 之后，相当 window.onload = function () &#123;&#125;</span></span><br><span class="line"><span class="regexp">var $btnObj = $("#btnId"); /</span><span class="regexp">/ 表示按 id 查询标签对象</span></span><br><span class="line"><span class="regexp">$btnObj.click(function () &#123; /</span><span class="regexp">/ 绑定单击事件</span></span><br><span class="line"><span class="regexp">alert("jQuery  的单击事件");</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br></pre></td></tr></table></figure></div>

<h2 id="jQuery-核心函数"><a href="#jQuery-核心函数" class="headerlink" title="jQuery  核心函数"></a>jQuery  核心函数</h2><p><code>$</code> 是 jQuery 的核心函数，能完成 jQuery 的很多功能。<code>$()</code> 调用<code>$</code>这个函数</p>
<ol>
<li><p>传入参数为 [ 函数 ] 时：<br>表示页面加载完成之后。相当于 <code>window.onload = function(){}</code></p>
</li>
<li><p>传入参数为 [ HTML 字符串 ] 时：<br>会对我们创建这个 html 标签对象<img src="/images/javaweb1/image-20200731202713780.png" alt="image-20200731202713780"></p>
</li>
<li><p>传入参数为 [ 选择器字符串 ] 时：<br><code>$(“#id 属性值”);</code>       id 选择器，根据 id 查询标签对象<br><code>$(“标签名”);</code>               标签名选择器，根据指定的标签名查询标签对象<br><code>$(“.class 属性值”);</code> 类型选择器，可以根据 class 属性查询标签对象</p>
</li>
<li><p>传入参数为 [ DOM 对象 ] 时：<br>会把这个 dom 对象转换为 jQuery 对象</p>
</li>
</ol>
<h1 id="IDEA使用"><a href="#IDEA使用" class="headerlink" title="IDEA使用"></a>IDEA使用</h1><h2 id="配置Maven项目"><a href="#配置Maven项目" class="headerlink" title="配置Maven项目"></a>配置Maven项目</h2><p><a href="https://how2j.cn/k/maven/maven-download-config/1329.html" target="_blank" rel="noopener">maven教程</a></p>
<ol>
<li><p><a href="https://blog.csdn.net/kangshuangzhu/article/details/100718142" target="_blank" rel="noopener">maven用IDEA社区版创建web项目</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/hongmoshui/p/10762272.html" target="_blank" rel="noopener">Maven全局配置文件settings.xml详解</a></p>
<p>a.<a href="https://blog.csdn.net/qq_45309297/article/details/106436535" target="_blank" rel="noopener">idea创建Maven报错</a></p>
<p>b.<a href="https://blog.csdn.net/weixin_42683077/article/details/105310649" target="_blank" rel="noopener">Maven更新问题</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>从中序与后序遍历序列构造二叉树</title>
    <url>/2020/09/24/LEBT5/</url>
    <content><![CDATA[<h1 id="题目：-从中序与后序遍历序列构造二叉树-Medium"><a href="#题目：-从中序与后序遍历序列构造二叉树-Medium" class="headerlink" title="题目： 从中序与后序遍历序列构造二叉树   Medium"></a>题目： <a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/" target="_blank" rel="noopener">从中序与后序遍历序列构造二叉树</a>   Medium</h1><h3 id="解决方案一-：递归建树"><a href="#解决方案一-：递归建树" class="headerlink" title="解决方案一 ：递归建树"></a>解决方案一 ：递归建树</h3><h4 id="解题逻辑：根据中序和后序遍历结果还原二叉树"><a href="#解题逻辑：根据中序和后序遍历结果还原二叉树" class="headerlink" title="解题逻辑：根据中序和后序遍历结果还原二叉树"></a><strong>解题逻辑</strong>：根据中序和后序遍历结果还原二叉树</h4><ol>
<li><h4 id="中序遍历和后续遍历的特性"><a href="#中序遍历和后续遍历的特性" class="headerlink" title="中序遍历和后续遍历的特性"></a>中序遍历和后续遍历的特性</h4><ol>
<li><p>在后序遍历序列中,最后一个元素为树的<strong>根节点</strong></p>
</li>
<li><p>在中序遍历序列中,根节点的左边为<strong>左子树</strong>，根节点的右边为<strong>右子树</strong></p>
<p><img src="/images/LEBT5/3293e7ccb41baaf52adca7e13cc0f258e1c83a4c588f9b6cb3e86410a540f298-%E6%A0%91%E7%9A%84%E7%89%B9%E6%80%A7.png" alt="树的特性.png"></p>
</li>
</ol>
</li>
<li><h4 id="树的还原过程描述"><a href="#树的还原过程描述" class="headerlink" title="树的还原过程描述"></a>树的还原过程描述</h4><ol>
<li><p>首先在后序遍历序列中找到<strong>根节点</strong>(最后一个元素)<br>根据根节点在中序遍历序列中找到<strong>根节点的位置</strong><br>根据根节点的位置将中序遍历序列分为<strong>左子树</strong>和<strong>右子树</strong><br>根据根节点的位置确定左子树和右子树在中序数组和后续数组中的<strong>左右边界位置</strong><br>递归构造左子树和右子树<br>返回根节点结束</p>
<p><img src="/images/LEBT5/image-20200924161625705.png" alt="image-20200924161625705"></p>
</li>
<li><p>​    <strong>核心</strong>：找到根节点，确定左右子树，确定根节点的左右孩子，确定边界，递归左右子树。【通过中序遍历确定后序遍历中左右子树的分界点从而能确定找到下个递归的左右根节点，即当前根节点的左右结点】</p>
</li>
<li><p><strong>HashMap</strong>  需要一个哈希表来保存中序遍历序列中,元素和索引的位置关系.因为从后序序列中拿到根节点后，要在中序序列中查找<strong>对应的位置</strong>,从而将数组分为*左子树和右子树。</p>
</li>
</ol>
</li>
</ol>
<h4 id="代码分析："><a href="#代码分析：" class="headerlink" title="代码分析："></a>代码分析：</h4><h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    HashMap&lt;Integer,Integer&gt; memo = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span>[] post;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; inorder.length; i++) memo.put(inorder[i], i);</span><br><span class="line">        post = postorder;</span><br><span class="line">        TreeNode root = buildTree(<span class="number">0</span>, inorder.length - <span class="number">1</span>, <span class="number">0</span>, post.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span> is, <span class="keyword">int</span> ie, <span class="keyword">int</span> ps, <span class="keyword">int</span> pe)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ie &lt; is || pe &lt; ps) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		<span class="comment">//核心计算后序遍历中左子树的边界，</span></span><br><span class="line">        <span class="comment">//已知中序遍历左子树的ri位置得左子树长度ri-is</span></span><br><span class="line">        <span class="comment">//得中序遍历右子树的起始位置ps+ri-is</span></span><br><span class="line">        <span class="comment">//则中序遍历左子树的终点位置为ps+ri-is-1</span></span><br><span class="line">        <span class="keyword">int</span> root = post[pe];</span><br><span class="line">        <span class="keyword">int</span> ri = memo.get(root);</span><br><span class="line"></span><br><span class="line">        TreeNode node = <span class="keyword">new</span> TreeNode(root);</span><br><span class="line">        node.left = buildTree(is, ri - <span class="number">1</span>, ps, ps + ri - is - <span class="number">1</span>);</span><br><span class="line">        node.right = buildTree(ri + <span class="number">1</span>, ie, ps + ri - is, pe - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="同类题：从前序与中序遍历序列构造二叉树-Medium"><a href="#同类题：从前序与中序遍历序列构造二叉树-Medium" class="headerlink" title="同类题：从前序与中序遍历序列构造二叉树  Medium"></a>同类题：<a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener">从前序与中序遍历序列构造二叉树 </a> Medium</h1><h2 id="Tips-必须有中序参与才能建立唯一二叉树"><a href="#Tips-必须有中序参与才能建立唯一二叉树" class="headerlink" title="Tips: 必须有中序参与才能建立唯一二叉树"></a>Tips: 必须有中序参与才能建立唯一二叉树</h2><p>原因：只有存在中序才能确定左右子树</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">//换汤不换药</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    HashMap&lt;Integer,Integer&gt; mem = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span>[] pre;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;preorder.length;i++) mem.put(inorder[i],i);</span><br><span class="line">        pre = preorder;</span><br><span class="line">        <span class="keyword">return</span> buildTree(<span class="number">0</span>,inorder.length-<span class="number">1</span>,<span class="number">0</span>,pre.length-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span> is ,<span class="keyword">int</span> ie,<span class="keyword">int</span> ps,<span class="keyword">int</span> pe)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ie&lt;is||pe&lt;ps) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode node = <span class="keyword">new</span> TreeNode(pre[ps]);</span><br><span class="line">        <span class="keyword">int</span> root = mem.get(pre[ps]);</span><br><span class="line">        node.left = buildTree(is,root-<span class="number">1</span>,ps+<span class="number">1</span>,ps+root-is);</span><br><span class="line">        node.right = buildTree(root+<span class="number">1</span>,ie,ps+root-is+<span class="number">1</span>,pe);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<blockquote>
<p>文件名：LBT5</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCodeExplore</tag>
        <tag>LeetcodeExploreBT</tag>
      </tags>
  </entry>
  <entry>
    <title>Model</title>
    <url>/2020/09/14/LEBT11/</url>
    <content><![CDATA[<h1 id="题目：-名字-Easy-Medium-Hard"><a href="#题目：-名字-Easy-Medium-Hard" class="headerlink" title="题目： 名字   Easy/Medium/Hard"></a>题目： 名字   Easy/Medium/Hard</h1><h2 id="1-自己构思"><a href="#1-自己构思" class="headerlink" title="1.自己构思"></a>1.自己构思</h2><h3 id="出现问题："><a href="#出现问题：" class="headerlink" title="出现问题："></a>出现问题：</h3><ol>
<li><h3 id="问题解决："><a href="#问题解决：" class="headerlink" title="问题解决："></a>问题解决：</h3></li>
<li></li>
</ol>
<h2 id="2-学习题解代码"><a href="#2-学习题解代码" class="headerlink" title="2.学习题解代码"></a>2.学习题解代码</h2><h3 id="解决方案一"><a href="#解决方案一" class="headerlink" title="解决方案一"></a>解决方案一</h3><h4 id="解题逻辑："><a href="#解题逻辑：" class="headerlink" title="解题逻辑："></a><strong>解题逻辑</strong>：</h4><ul>
<li></li>
</ul>
<h4 id="代码分析："><a href="#代码分析：" class="headerlink" title="代码分析："></a>代码分析：</h4><h4 id="解决自己问题："><a href="#解决自己问题：" class="headerlink" title="解决自己问题："></a>解决自己问题：</h4><ul>
<li><h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4></li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>



<h4 id="tips"><a href="#tips" class="headerlink" title="tips:"></a>tips:</h4><ul>
<li><h3 id="解决方案二"><a href="#解决方案二" class="headerlink" title="解决方案二"></a>解决方案二</h3></li>
</ul>
<h4 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="解决方案三"><a href="#解决方案三" class="headerlink" title="解决方案三"></a>解决方案三</h3><blockquote>
<p>文件名：LBT</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCodeExplore</tag>
        <tag>LeetcodeExploreBT</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的序列化与反序列化</title>
    <url>/2020/09/27/LEBT9/</url>
    <content><![CDATA[<h1 id="题目：-二叉树的序列化与反序列化-Hard"><a href="#题目：-二叉树的序列化与反序列化-Hard" class="headerlink" title="题目： 二叉树的序列化与反序列化   Hard"></a>题目： <a href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/" target="_blank" rel="noopener">二叉树的序列化与反序列化</a>   Hard</h1><h3 id="解决方案一-DFS-递归"><a href="#解决方案一-DFS-递归" class="headerlink" title="解决方案一: DFS 递归"></a>解决方案一: DFS 递归</h3><h4 id="解题逻辑："><a href="#解题逻辑：" class="headerlink" title="解题逻辑："></a><strong>解题逻辑</strong>：</h4><img src="/images/LEBT9/image-20200927144739272.png" alt="image-20200927144739272" style="zoom: 67%;" />

<h4 id="代码分析："><a href="#代码分析：" class="headerlink" title="代码分析："></a>代码分析：</h4><ul>
<li><p>序列化部分：遇到null结点 则添加“NONE”字符串代表</p>
</li>
<li><p>反序列化部分：遇NONE 返回null</p>
</li>
<li><p>.split（）将字符串按照分隔符分成字符数组</p>
</li>
<li><p>Arrays.asList（）将字符数组转化为list</p>
</li>
<li><p>+= “ ” 连接生成新字符串</p>
</li>
<li><p><strong>Integer.valueOf（）</strong>字符串转化为整形  <code>Integer.valueOf(l.get(0))</code></p>
<p><strong>String.valueOf(int i)</strong> : 将 int 变量 i 转换成字符串 <code>str.valueOf(root.val)</code></p>
</li>
<li><p>equals()</p>
</li>
</ul>
<h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">rserialize</span><span class="params">(TreeNode root, String str)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//注意逗号</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            str += <span class="string">"None,"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            str += str.valueOf(root.val) + <span class="string">","</span>;</span><br><span class="line">            str = rserialize(root.left, str);</span><br><span class="line">            str = rserialize(root.right, str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rserialize(root, <span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">//通过删除列表头元素并且查找头元素满足先序遍历条件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">rdeserialize</span><span class="params">(List&lt;String&gt; l)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l.get(<span class="number">0</span>).equals(<span class="string">"None"</span>)) &#123;</span><br><span class="line">            l.remove(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(Integer.valueOf(l.get(<span class="number">0</span>)));</span><br><span class="line">        l.remove(<span class="number">0</span>);</span><br><span class="line">        root.left = rdeserialize(l);</span><br><span class="line">        root.right = rdeserialize(l);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        String[] data_array = data.split(<span class="string">","</span>);</span><br><span class="line">        <span class="comment">//使用linkedlist 方便删除读取数据</span></span><br><span class="line">        List&lt;String&gt; data_list = <span class="keyword">new</span> LinkedList&lt;String&gt;(Arrays.asList(data_array));</span><br><span class="line">        <span class="keyword">return</span> rdeserialize(data_list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>文件名：LBT9</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCodeExplore</tag>
        <tag>LeetcodeExploreBT</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的最近公共祖先</title>
    <url>/2020/09/27/LEBT7/</url>
    <content><![CDATA[<h1 id="题目：-二叉树的最近公共祖先-Medium"><a href="#题目：-二叉树的最近公共祖先-Medium" class="headerlink" title="题目：  二叉树的最近公共祖先  Medium"></a>题目： <a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank" rel="noopener"> 二叉树的最近公共祖先</a>  Medium</h1><h3 id="解决方案一-：递归"><a href="#解决方案一-：递归" class="headerlink" title="解决方案一 ：递归"></a>解决方案一 ：递归</h3><h4 id="解题逻辑：分解情况判断root位置"><a href="#解题逻辑：分解情况判断root位置" class="headerlink" title="解题逻辑：分解情况判断root位置"></a><strong>解题逻辑</strong>：分解情况判断root位置</h4><ol>
<li><p>最近公共祖先定义：设节点 rootroot 为节点 p, q的某公共祖先，若其左子节点 root.left和右子节点root.right 都不是 p,q的公共祖先，则称 root是 “最近的公共祖先” 。</p>
<ul>
<li>情况分析：<ul>
<li>p 和 q 在 root 的子树中，且分列 root 的 异侧（即分别在左、右子树中）；</li>
<li>p = root，且 q 在 root的左或右子树中；</li>
<li>q = root，且 p在 root 的左或右子树中；</li>
</ul>
</li>
</ul>
</li>
<li><p>核心思想：通过递归对二叉树进行<strong>后序遍历</strong>，当遇到节点 p 或 q时返回。从底至顶回溯，当节点 p, q 在节点 root 的异侧时，节点 root 即为最近公共祖先，则向上返回 root 。</p>
<ul>
<li>后序遍历的遍历顺序很好的方便对回溯上来的左右结点值进行处理，然后再向上层进行结果返回。</li>
<li>该题目中的递归返回结果就是公共祖先的值，root or null</li>
</ul>
</li>
</ol>
<h4 id="代码分析："><a href="#代码分析：" class="headerlink" title="代码分析："></a>代码分析：</h4><img src="/images/LEBT7/image-20200927142149446.png" alt="image-20200927142149446" style="zoom: 67%;" />

<h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span> || root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode left = lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        TreeNode right = lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        <span class="comment">// if(left == null &amp;&amp; right == null) return null; // 1.情况可以合并到下面3. 4.情况中 都是返回null</span></span><br><span class="line">        <span class="keyword">if</span>(left == <span class="keyword">null</span>) <span class="keyword">return</span> right; <span class="comment">//3.</span></span><br><span class="line">        <span class="keyword">if</span>(right == <span class="keyword">null</span>) <span class="keyword">return</span> left; <span class="comment">//4.</span></span><br><span class="line">        <span class="keyword">return</span> root; <span class="comment">// 2. if(left != null and right != null)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>文件名：LBT7</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCodeExplore</tag>
        <tag>LeetcodeExploreBT</tag>
      </tags>
  </entry>
  <entry>
    <title>路径总和</title>
    <url>/2020/09/23/LEBT4/</url>
    <content><![CDATA[<h1 id="题目：-路径总和-Easy"><a href="#题目：-路径总和-Easy" class="headerlink" title="题目： 路径总和   Easy"></a>题目： <a href="https://leetcode-cn.com/problems/path-sum/" target="_blank" rel="noopener">路径总和</a>   Easy</h1><h2 id="1-自己构思"><a href="#1-自己构思" class="headerlink" title="1.自己构思"></a>1.自己构思</h2><h3 id="出现问题："><a href="#出现问题：" class="headerlink" title="出现问题："></a>出现问题：</h3><ol>
<li>根节点为0情况未考虑</li>
<li>对叶子节点的判断失误</li>
<li>对sum的计算顺序失误</li>
</ol>
<h3 id="问题解决：精简自底向上-递归-见方案二"><a href="#问题解决：精简自底向上-递归-见方案二" class="headerlink" title="问题解决：精简自底向上 递归 见方案二"></a>问题解决：精简自底向上 递归 见方案二</h3><ol>
<li>增加对根节点为null的判断</li>
<li>修改叶子结点临界的判断</li>
<li>优先计算sum</li>
</ol>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        pathSum(root,<span class="number">0</span>,sum);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pathSum</span><span class="params">(TreeNode node,<span class="keyword">int</span> sum,<span class="keyword">int</span> Target)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        sum = sum + node.val;</span><br><span class="line">        <span class="keyword">if</span>(node.left == <span class="keyword">null</span> &amp;&amp; node.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum == Target)</span><br><span class="line">              result = <span class="keyword">true</span>;  </span><br><span class="line">            <span class="keyword">return</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)</span><br><span class="line">        pathSum(node.left,sum,Target);</span><br><span class="line">        <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)</span><br><span class="line">        pathSum(node.right,sum,Target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="2-学习题解代码"><a href="#2-学习题解代码" class="headerlink" title="2.学习题解代码"></a>2.学习题解代码</h2><h3 id="解决方案一：双队列-BFS"><a href="#解决方案一：双队列-BFS" class="headerlink" title="解决方案一：双队列 BFS"></a>解决方案一：双队列 BFS</h3><h4 id="解题逻辑：BFS"><a href="#解题逻辑：BFS" class="headerlink" title="解题逻辑：BFS"></a><strong>解题逻辑</strong>：BFS</h4><ul>
<li>使用两个队列，分别存储将要遍历的节点，以及根节点到这些节点的路径和即可。</li>
</ul>
<h4 id="代码分析："><a href="#代码分析：" class="headerlink" title="代码分析："></a>代码分析：</h4><h4 id="实现代码："><a href="#实现代码：" class="headerlink" title="实现代码："></a>实现代码：</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; queNode = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        Queue&lt;Integer&gt; queVal = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        queNode.offer(root);</span><br><span class="line">        queVal.offer(root.val);</span><br><span class="line">        <span class="keyword">while</span> (!queNode.isEmpty()) &#123;</span><br><span class="line">            TreeNode now = queNode.poll();</span><br><span class="line">            <span class="keyword">int</span> temp = queVal.poll();</span><br><span class="line">            <span class="keyword">if</span> (now.left == <span class="keyword">null</span> &amp;&amp; now.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (temp == sum) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (now.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queNode.offer(now.left);</span><br><span class="line">                queVal.offer(now.left.val + temp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (now.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queNode.offer(now.right);</span><br><span class="line">                queVal.offer(now.right.val + temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="解决方案二-：递归"><a href="#解决方案二-：递归" class="headerlink" title="解决方案二 ：递归"></a>解决方案二 ：递归</h3><h4 id="解题逻辑："><a href="#解题逻辑：" class="headerlink" title="解题逻辑："></a>解题逻辑：</h4><ul>
<li>询问是否存在从当前节点 <code>root</code> 到叶子节点的路径，满足其路径和为 <code>sum</code>。</li>
<li>假定从根节点到当前节点的值之和为 <code>val</code>，我们可以将这个<strong><em>大问题转化为一个小问题</em></strong>：<ul>
<li>是否存在从当前节点的子节点到叶子的路径，满足其路径和为 <code>sum - val</code>。</li>
</ul>
</li>
</ul>
<p>不难发现这满足递归的性质，若当前节点就是叶子节点，那么我们<strong>直接判断 sum 是否等于 val</strong> 即可（因为路径和已经确定，就是当前节点的值，我们只需要判断该路径和是否满足条件）。若当前节点不是叶子节点，我们只需要递归地询问它的子节点是否能满足条件即可。</p>
<h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> sum == root.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="解决方案三"><a href="#解决方案三" class="headerlink" title="解决方案三"></a>解决方案三</h3><blockquote>
<p>文件名：LBT4</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCodeExplore</tag>
        <tag>LeetcodeExploreBT</tag>
      </tags>
  </entry>
  <entry>
    <title>填充每个节点的下一个右侧节点指针</title>
    <url>/2020/09/24/LEBT6/</url>
    <content><![CDATA[<h1 id="题目：-填充每个节点的下一个右侧节点指针-Medium"><a href="#题目：-填充每个节点的下一个右侧节点指针-Medium" class="headerlink" title="题目： 填充每个节点的下一个右侧节点指针 Medium"></a>题目： <a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/" target="_blank" rel="noopener">填充每个节点的下一个右侧节点指针</a> Medium</h1><h2 id="1-自己构思"><a href="#1-自己构思" class="headerlink" title="1.自己构思"></a>1.自己构思</h2><h3 id="思想：队列进行层次遍历，指派指针"><a href="#思想：队列进行层次遍历，指派指针" class="headerlink" title="思想：队列进行层次遍历，指派指针"></a>思想：队列进行层次遍历，指派指针</h3><h3 id="代码优化：根据方案一"><a href="#代码优化：根据方案一" class="headerlink" title="代码优化：根据方案一"></a>代码优化：根据方案一</h3><ul>
<li>指派指针时不需要记录前面指针然后等后面指针出列后指派<ul>
<li>直接使用peekFirst（）查询队首指针</li>
<li>到达最右边指针后无需判断因为默认就是null指针</li>
</ul>
</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public Node left;</span></span><br><span class="line"><span class="comment">    public Node right;</span></span><br><span class="line"><span class="comment">    public Node next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node() &#123;&#125;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    public Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val, Node _left, Node _right, Node _next) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        left = _left;</span></span><br><span class="line"><span class="comment">        right = _right;</span></span><br><span class="line"><span class="comment">        next = _next;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">connect</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        Deque&lt;Node&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        q.addLast(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">            Node pre= <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">int</span> len = q.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">                Node nodei = q.pop();</span><br><span class="line">                <span class="keyword">if</span>(i == len-<span class="number">1</span>) nodei.next = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span>(pre != <span class="keyword">null</span>) pre.next = nodei;</span><br><span class="line">                pre = nodei;</span><br><span class="line">                <span class="keyword">if</span>(nodei.left!=<span class="keyword">null</span>)</span><br><span class="line">                q.addLast(nodei.left);</span><br><span class="line">                <span class="keyword">if</span>(nodei.right!=<span class="keyword">null</span>)</span><br><span class="line">                q.addLast(nodei.right);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h2 id="2-学习题解代码"><a href="#2-学习题解代码" class="headerlink" title="2.学习题解代码"></a>2.学习题解代码</h2><h3 id="解决方案一-：层次遍历"><a href="#解决方案一-：层次遍历" class="headerlink" title="解决方案一 ：层次遍历"></a>解决方案一 ：层次遍历</h3><h4 id="解题逻辑：层次遍历-同自己解法"><a href="#解题逻辑：层次遍历-同自己解法" class="headerlink" title="解题逻辑：层次遍历,同自己解法"></a><strong>解题逻辑</strong>：层次遍历,同自己解法</h4><h4 id="代码分析："><a href="#代码分析：" class="headerlink" title="代码分析："></a>代码分析：</h4><h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">connect</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Initialize a queue data structure which contains</span></span><br><span class="line">        <span class="comment">// just the root of the tree</span></span><br><span class="line">        Queue&lt;Node&gt; Q = <span class="keyword">new</span> LinkedList&lt;Node&gt;(); </span><br><span class="line">        Q.add(root);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Outer while loop which iterates over </span></span><br><span class="line">        <span class="comment">// each level</span></span><br><span class="line">        <span class="keyword">while</span> (Q.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Note the size of the queue</span></span><br><span class="line">            <span class="keyword">int</span> size = Q.size();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Iterate over all the nodes on the current level</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// Pop a node from the front of the queue</span></span><br><span class="line">                Node node = Q.poll();</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// This check is important. We don't want to</span></span><br><span class="line">                <span class="comment">// establish any wrong connections. The queue will</span></span><br><span class="line">                <span class="comment">// contain nodes from 2 levels at most at any</span></span><br><span class="line">                <span class="comment">// point in time. This check ensures we only </span></span><br><span class="line">                <span class="comment">// don't establish next pointers beyond the end</span></span><br><span class="line">                <span class="comment">// of a level</span></span><br><span class="line">                <span class="keyword">if</span> (i &lt; size - <span class="number">1</span>) &#123;</span><br><span class="line">                    node.next = Q.peek();</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// Add the children, if any, to the back of</span></span><br><span class="line">                <span class="comment">// the queue</span></span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    Q.add(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    Q.add(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Since the tree has now been modified, return the root node</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="解决方案二：迭代指派孩子结点"><a href="#解决方案二：迭代指派孩子结点" class="headerlink" title="解决方案二：迭代指派孩子结点"></a>解决方案二：迭代指派孩子结点</h3><img src="/images/LEBT6/img11.png" alt="img" style="zoom:33%;" />

<h3 id="复杂度："><a href="#复杂度：" class="headerlink" title="复杂度："></a>复杂度：</h3><p>空间复杂度：O(N)。这是一棵完美二叉树，它的最后一个层级包含 N/2 个节点。广度优先遍历的复杂度取决于一个层级上的最大元素数量。这种情况下空间复杂度为 O(N)O(N)。</p>
<p>作者：LeetCode</p>
<h4 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">connect</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Start with the root node. There are no next pointers</span></span><br><span class="line">        <span class="comment">// that need to be set up on the first level</span></span><br><span class="line">        Node leftmost = root;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Once we reach the final level, we are done</span></span><br><span class="line">        <span class="keyword">while</span> (leftmost.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Iterate the "linked list" starting from the head</span></span><br><span class="line">            <span class="comment">// node and using the next pointers, establish the </span></span><br><span class="line">            <span class="comment">// corresponding links for the next level</span></span><br><span class="line">            Node head = leftmost;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// CONNECTION 1</span></span><br><span class="line">                head.left.next = head.right;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// CONNECTION 2</span></span><br><span class="line">                <span class="keyword">if</span> (head.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    head.right.next = head.next.left;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// Progress along the list (nodes on the current level)</span></span><br><span class="line">                head = head.next;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Move onto the next level</span></span><br><span class="line">            leftmost = leftmost.left;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="解决方案三：递归指派孩子结点"><a href="#解决方案三：递归指派孩子结点" class="headerlink" title="解决方案三：递归指派孩子结点"></a>解决方案三：递归指派孩子结点</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node left, Node right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="keyword">null</span> || right == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        left.next = right;</span><br><span class="line">        dfs(left.left, left.right);</span><br><span class="line">        dfs(right.left, right.right);</span><br><span class="line">        dfs(left.right, right.left);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">connect</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        dfs(root.left, root.right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>文件名：LBT6</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCodeExplore</tag>
        <tag>LeetcodeExploreBT</tag>
      </tags>
  </entry>
  <entry>
    <title>队列构造与内置用法</title>
    <url>/2020/08/11/LEQS2/</url>
    <content><![CDATA[<h1 id="java-内置队列库实现常见队列操作"><a href="#java-内置队列库实现常见队列操作" class="headerlink" title="java 内置队列库实现常见队列操作"></a>java 内置队列库实现常见队列操作</h1><ol>
<li>Queue<T>  q  = new LinkedList();</li>
<li>q.size() // 获取队列元素数量</li>
<li>q.offer();/add();</li>
<li>q.poll();/remove();</li>
<li>//add()和remove()方法在失败的时候会抛出异常(不推荐)</li>
<li><img src="/images/LEQS2/image-20200903170626591.png" alt="image-20200903170626591" style="zoom: 80%;" />

</li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// "static void main" must be defined in a public class.</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. Initialize a queue.</span></span><br><span class="line">        Queue&lt;Integer&gt; q = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        <span class="comment">// 2. Get the first element - return null if queue is empty.</span></span><br><span class="line">        System.out.println(<span class="string">"The first element is: "</span> + q.peek());</span><br><span class="line">        <span class="comment">// 3. Push new element.</span></span><br><span class="line">        q.offer(<span class="number">5</span>);</span><br><span class="line">        q.offer(<span class="number">13</span>);</span><br><span class="line">        q.offer(<span class="number">8</span>);</span><br><span class="line">        q.offer(<span class="number">6</span>);</span><br><span class="line">        <span class="comment">// 4. Pop an element.</span></span><br><span class="line">        q.poll();</span><br><span class="line">        <span class="comment">// 5. Get the first element.</span></span><br><span class="line">        System.out.println(<span class="string">"The first element is: "</span> + q.peek());</span><br><span class="line">        <span class="comment">// 7. Get the size of the queue.</span></span><br><span class="line">        System.out.println(<span class="string">"The size is: "</span> + q.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol>
<li>java.util.* 代表导入util包下的所有类不包含接口</li>
<li>queue为接口需要重新导入</li>
<li><a href="https://cloud.tencent.com/developer/article/1515562" target="_blank" rel="noopener">阅读</a></li>
<li>java14,util包在javabase/java/util</li>
</ol>
<h1 id="低效率列表实现"><a href="#低效率列表实现" class="headerlink" title="低效率列表实现"></a>低效率列表实现</h1><h2 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h2><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// "static void main" must be defined in a public class.</span></span><br><span class="line"><span class="comment">//低效率浪费空间</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>&#123;</span><br><span class="line">    <span class="comment">// store elements</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; data;         </span><br><span class="line">    <span class="comment">// a pointer to indicate the start position</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> p_start;            </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        data = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        p_start = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** Insert an element into the queue. Return true if the operation is successful. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">enQueue</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        data.add(x);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;;    </span><br><span class="line">    <span class="comment">/** Delete an element from the queue. Return true if the operation is successful. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">deQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty() == <span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p_start++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** Get the front item from the queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data.get(p_start);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** Checks whether the queue is empty or not. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p_start &gt;= data.size();</span><br><span class="line">    &#125;     </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyQueue q = <span class="keyword">new</span> MyQueue();</span><br><span class="line">        q.enQueue(<span class="number">5</span>);</span><br><span class="line">        q.enQueue(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">if</span> (q.isEmpty() == <span class="keyword">false</span>) &#123;</span><br><span class="line">            System.out.println(q.Front());</span><br><span class="line">        &#125;</span><br><span class="line">        q.deQueue();</span><br><span class="line">        <span class="keyword">if</span> (q.isEmpty() == <span class="keyword">false</span>) &#123;</span><br><span class="line">            System.out.println(q.Front());</span><br><span class="line">        &#125;</span><br><span class="line">        q.deQueue();</span><br><span class="line">        <span class="keyword">if</span> (q.isEmpty() == <span class="keyword">false</span>) &#123;</span><br><span class="line">            System.out.println(q.Front());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="循环队列数组实现"><a href="#循环队列数组实现" class="headerlink" title="循环队列数组实现"></a>循环队列数组实现</h1><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><ul>
<li>计算队尾指针位置<img src="/images/LEQS2/image-20200822155337704.png" alt="image-20200822155337704" style="zoom:50%;" /></li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCircularQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] queue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> headIndex;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. Set the size of the queue to be k. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyCircularQueue</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = k;</span><br><span class="line">        <span class="keyword">this</span>.queue =  <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        <span class="keyword">this</span>.headIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Insert an element into the circular queue. Return true if the operation is successful. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">enQueue</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.count == <span class="keyword">this</span>.capacity) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">this</span>.count++;</span><br><span class="line">        <span class="keyword">this</span>.queue[(<span class="keyword">this</span>.headIndex + <span class="keyword">this</span>.count -<span class="number">1</span>) % <span class="keyword">this</span>.capacity] = value;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Delete an element from the circular queue. Return true if the operation is successful. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">deQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.count == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">this</span>.headIndex = (<span class="keyword">this</span>.headIndex + <span class="number">1</span>) % <span class="keyword">this</span>.capacity;</span><br><span class="line">        <span class="keyword">this</span>.count--;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the front item from the queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.count == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.queue[<span class="keyword">this</span>.headIndex];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the last item from the queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Rear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.count == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.queue[(<span class="keyword">this</span>.headIndex + <span class="keyword">this</span>.count -<span class="number">1</span>) % <span class="keyword">this</span>.capacity];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">/** Checks whether the circular queue is empty or not. */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span>.count == <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Checks whether the circular queue is full or not. */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span>.count == <span class="keyword">this</span>.capacity);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyCircularQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyCircularQueue obj = new MyCircularQueue(k);</span></span><br><span class="line"><span class="comment"> * boolean param_1 = obj.enQueue(value);</span></span><br><span class="line"><span class="comment"> * boolean param_2 = obj.deQueue();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.Front();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj.Rear();</span></span><br><span class="line"><span class="comment"> * boolean param_5 = obj.isEmpty();</span></span><br><span class="line"><span class="comment"> * boolean param_6 = obj.isFull();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>文件名：LEQS2</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCodeExplore</tag>
        <tag>LeetcodeExploreQ&amp;S</tag>
      </tags>
  </entry>
  <entry>
    <title>对称二叉树</title>
    <url>/2020/09/23/LEBT3/</url>
    <content><![CDATA[<h1 id="题目：-对称二叉树-Easy"><a href="#题目：-对称二叉树-Easy" class="headerlink" title="题目： 对称二叉树 Easy"></a>题目： <a href="https://leetcode-cn.com/problems/symmetric-tree/solution/dui-cheng-er-cha-shu-by-leetcode-solution/" target="_blank" rel="noopener">对称二叉树</a> Easy</h1><h3 id="解决方案一-递归-双指针"><a href="#解决方案一-递归-双指针" class="headerlink" title="解决方案一 : 递归 双指针"></a>解决方案一 : 递归 双指针</h3><h4 id="解题逻辑：深度自底向上"><a href="#解题逻辑：深度自底向上" class="headerlink" title="解题逻辑：深度自底向上"></a><strong>解题逻辑</strong>：深度自底向上</h4><ul>
<li>过「同步移动」<strong>两个指针</strong>的方法来遍历这棵树，pp指针和 q 指针一开始都指向这棵树的根，随后 p 右移时，q左移，p 左移时，q右移。每次检查当前 p 和 q节点的值是否相等，如果相等再判断左右子树是否对称。</li>
</ul>
<h4 id="代码分析："><a href="#代码分析：" class="headerlink" title="代码分析："></a>代码分析：</h4><h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> check(root, root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> &amp;&amp; q == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> || q == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p.val == q.val &amp;&amp; check(p.left, q.right) &amp;&amp; check(p.right, q.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="解决方案二：-队列迭代，双结点"><a href="#解决方案二：-队列迭代，双结点" class="headerlink" title="解决方案二： 队列迭代，双结点"></a>解决方案二： 队列迭代，双结点</h3><p>重点：队列可以offer入null元素，并且完整出列</p>
<h4 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> check(root, root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(TreeNode u, TreeNode v)</span> </span>&#123;</span><br><span class="line">     Deque&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">     queue.offerLast(u);queue.offerLast(v);</span><br><span class="line">     <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">         u = queue.pollFirst();</span><br><span class="line">         v = queue.pollFirst();</span><br><span class="line">         <span class="keyword">if</span>(u==<span class="keyword">null</span> &amp;&amp; v==<span class="keyword">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">         <span class="keyword">if</span>(u == <span class="keyword">null</span> || v==<span class="keyword">null</span> || u.val != v.val ) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         queue.offerLast(u.left);</span><br><span class="line">         queue.offerLast(v.right);</span><br><span class="line">         queue.offerLast(u.right);</span><br><span class="line">         queue.offerLast(v.left);                        </span><br><span class="line">     &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<blockquote>
<p>文件名：LBT3</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCodeExplore</tag>
        <tag>LeetcodeExploreBT</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA配置</title>
    <url>/2020/09/22/IDEA/</url>
    <content><![CDATA[<p><a href="https://how2j.cn/k/idea/idea-config-place/1360.html" target="_blank" rel="noopener">更改配置文件位置</a></p>
<p>同时修改plugins 和 log 的path</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCodeExplore</tag>
        <tag>LeetcodeExploreBT</tag>
      </tags>
  </entry>
  <entry>
    <title>Excel操作</title>
    <url>/2020/07/03/Excel/</url>
    <content><![CDATA[<h1 id="Excel操作"><a href="#Excel操作" class="headerlink" title="Excel操作"></a>Excel操作</h1><h2 id="保持某个单元格不改变"><a href="#保持某个单元格不改变" class="headerlink" title="保持某个单元格不改变"></a>保持某个单元格不改变</h2><p><strong>$</strong> 符号</p>
<p>例子：实现excel后一行减前一行得数的公式输入</p>
<p><img src="../images/Excel/image-20200919202128258.png" alt="image-20200919202128258"></p>
]]></content>
      <categories>
        <category>Excel操作</category>
      </categories>
  </entry>
  <entry>
    <title>设计链表</title>
    <url>/2020/09/07/LEL2/</url>
    <content><![CDATA[<h1 id="题目：设计链表-Easy"><a href="#题目：设计链表-Easy" class="headerlink" title="题目：设计链表 Easy"></a>题目：设计链表 Easy</h1><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><ul>
<li>链表时一个包含零个或多个元素的数据结构。</li>
<li>每个元素都包含一个值和到另一个元素的链接。</li>
<li>根据<strong>链接数</strong>的不同，可以分为<strong>单链表</strong>，<strong>双链表</strong>和多重链表。</li>
</ul>
<h2 id="单双链表"><a href="#单双链表" class="headerlink" title="单双链表"></a>单双链表</h2><ul>
<li>单链表是最简单的一种，它提供了在常数时间内的 <code>addAtHead</code> 操作和在线性时间内的 <code>addAtTail</code> 的操作。</li>
<li>双链表是最常用的一种，因为它提供了在常数时间内的 <code>addAtHead</code> 和 <code>addAtTail</code> 操作，并且<strong>优化的插入和删除</strong>。</li>
</ul>
<h2 id="链表结构"><a href="#链表结构" class="headerlink" title="链表结构"></a>链表结构</h2><p>双链表在 Java 中的实现为 LinkedList，在 Python 中为 list。这些结构都比较常用，有两个要点：</p>
<ul>
<li><p>哨兵节点：<br>哨兵节点在树和链表中被广泛用作伪头、伪尾等，通常不保存任何数据。</p>
<p>我们将使用伪头来简化我们<strong>简化插入和删除</strong>。在接下来的两种方法中应用此方法。</p>
</li>
<li><p>双链表的双向搜索：我们可以从头部或尾部进行搜索。</p>
</li>
</ul>
<h3 id="设计方案一：单链表之伪头节点"><a href="#设计方案一：单链表之伪头节点" class="headerlink" title="设计方案一：单链表之伪头节点"></a>设计方案一：单链表之伪头节点</h3><h4 id="解题逻辑："><a href="#解题逻辑：" class="headerlink" title="解题逻辑："></a><strong>解题逻辑</strong>：</h4><ul>
<li>哨兵节点被用作伪头始终存在，这样结构中永远不为空，它将至少包含一个伪头</li>
</ul>
<h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> val;</span><br><span class="line">  ListNode next;</span><br><span class="line">  ListNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLinkedList</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> size;</span><br><span class="line">  ListNode head;  <span class="comment">// sentinel node as pseudo-head</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MyLinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">    head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// if index is invalid</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    ListNode curr = head;</span><br><span class="line">    <span class="comment">// index steps needed </span></span><br><span class="line">    <span class="comment">// to move from sentinel node to wanted index</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index + <span class="number">1</span>; i++) curr = curr.next;</span><br><span class="line">    <span class="keyword">return</span> curr.val;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAtHead</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    addAtIndex(<span class="number">0</span>, val);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Append a node of value val to the last element of the linked list. */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAtTail</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    addAtIndex(size, val);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// If index is greater than the length, </span></span><br><span class="line">    <span class="comment">// the node will not be inserted.</span></span><br><span class="line">    <span class="keyword">if</span> (index &gt; size) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// [so weird] If index is negative, </span></span><br><span class="line">    <span class="comment">// the node will be inserted at the head of the list.</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span>) index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    ++size;</span><br><span class="line">    <span class="comment">// find predecessor of the node to be added</span></span><br><span class="line">    ListNode pred = head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++) pred = pred.next; <span class="comment">//++i 让指针遍历到index</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// node to be added</span></span><br><span class="line">    ListNode toAdd = <span class="keyword">new</span> ListNode(val);</span><br><span class="line">    <span class="comment">// insertion itself</span></span><br><span class="line">    toAdd.next = pred.next;</span><br><span class="line">    pred.next = toAdd;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Delete the index-th node in the linked list, if the index is valid. */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// if the index is invalid, do nothing</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    size--;</span><br><span class="line">    <span class="comment">// find predecessor of the node to be deleted</span></span><br><span class="line">    ListNode pred = head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++) pred = pred.next; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// delete pred.next </span></span><br><span class="line">    pred.next = pred.next.next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="tips"><a href="#tips" class="headerlink" title="tips:"></a>tips:</h4><ul>
<li>在<strong>Java中i++语句是需要一个临时变量取存储返回自增前的值，而++i不需要</strong>。这样就导致使用i++时系统需要先申请一段内存空间，然后将值赛如进去，最后不用了才去释放。多了这么一系列操作时间当然多了。</li>
<li>i++ 在循环内部代码块执行完毕后再执行</li>
</ul>
<h3 id="解决方案二：双链表"><a href="#解决方案二：双链表" class="headerlink" title="解决方案二：双链表"></a>解决方案二：双链表</h3><p><img src="/images/LEL2/ffb51bf8583d324c68afb3c5b5f9fe0f61f3fa65167d462d6f8549566c3c8f33-file_1578973150884" alt="在这里插入图片描述"></p>
<h4 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> val;</span><br><span class="line">  ListNode next;</span><br><span class="line">  ListNode prev;</span><br><span class="line">  ListNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLinkedList</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> size;</span><br><span class="line">  <span class="comment">// sentinel nodes as pseudo-head and pseudo-tail</span></span><br><span class="line">  ListNode head, tail;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MyLinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">    head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    tail = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    head.next = tail;</span><br><span class="line">    tail.prev = head;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// if index is invalid</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// choose the fastest way: to move from the head</span></span><br><span class="line">    <span class="comment">// or to move from the tail</span></span><br><span class="line">    ListNode curr = head;</span><br><span class="line">    <span class="keyword">if</span> (index + <span class="number">1</span> &lt; size - index)</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index + <span class="number">1</span>; ++i) curr = curr.next;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      curr = tail;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size - index; ++i) curr = curr.prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> curr.val;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAtHead</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    ListNode pred = head, succ = head.next; <span class="comment">//获取前后结点</span></span><br><span class="line"></span><br><span class="line">    ++size;</span><br><span class="line">    ListNode toAdd = <span class="keyword">new</span> ListNode(val);</span><br><span class="line">    toAdd.prev = pred;</span><br><span class="line">    toAdd.next = succ;</span><br><span class="line">    pred.next = toAdd;</span><br><span class="line">    succ.prev = toAdd;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Append a node of value val to the last element of the linked list. */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAtTail</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    ListNode succ = tail, pred = tail.prev;</span><br><span class="line"></span><br><span class="line">    ++size;</span><br><span class="line">    ListNode toAdd = <span class="keyword">new</span> ListNode(val);</span><br><span class="line">    toAdd.prev = pred;</span><br><span class="line">    toAdd.next = succ;</span><br><span class="line">    pred.next = toAdd;</span><br><span class="line">    succ.prev = toAdd;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// If index is greater than the length, </span></span><br><span class="line">    <span class="comment">// the node will not be inserted.</span></span><br><span class="line">    <span class="keyword">if</span> (index &gt; size) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// [so weird] If index is negative, </span></span><br><span class="line">    <span class="comment">// the node will be inserted at the head of the list.</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span>) index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find predecessor and successor of the node to be added</span></span><br><span class="line">    ListNode pred, succ; </span><br><span class="line">    <span class="keyword">if</span> (index &lt; size - index) &#123;</span><br><span class="line">      pred = head;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; ++i) pred = pred.next;</span><br><span class="line">      succ = pred.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      succ = tail;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size - index; ++i) succ = succ.prev;</span><br><span class="line">      pred = succ.prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// insertion itself</span></span><br><span class="line">    ++size;</span><br><span class="line">    ListNode toAdd = <span class="keyword">new</span> ListNode(val);</span><br><span class="line">    toAdd.prev = pred;</span><br><span class="line">    toAdd.next = succ;</span><br><span class="line">    pred.next = toAdd;</span><br><span class="line">    succ.prev = toAdd;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Delete the index-th node in the linked list, if the index is valid. */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// if the index is invalid, do nothing</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find predecessor and successor of the node to be deleted</span></span><br><span class="line">    ListNode pred, succ;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; size - index) &#123;</span><br><span class="line">      pred = head;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; ++i) pred = pred.next;</span><br><span class="line">      succ = pred.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      succ = tail;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size - index - <span class="number">1</span>; ++i) succ = succ.prev;</span><br><span class="line">      pred = succ.prev.prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// delete pred.next </span></span><br><span class="line">    --size;</span><br><span class="line">    pred.next = succ;</span><br><span class="line">    succ.prev = pred;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="解决方案三"><a href="#解决方案三" class="headerlink" title="解决方案三"></a>解决方案三</h3><blockquote>
<p>文件名：LEL2</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCodeExplore</tag>
        <tag>LeetcodeExploreLL</tag>
      </tags>
  </entry>
  <entry>
    <title>56 合并区间 medium</title>
    <url>/2020/06/08/LEA1/</url>
    <content><![CDATA[<h1 id="56-合并区间-medium"><a href="#56-合并区间-medium" class="headerlink" title="#56 合并区间 medium"></a>#56 <a href="https://leetcode-cn.com/problems/merge-intervals/" target="_blank" rel="noopener">合并区间</a> medium</h1><h2 id="1-自己构思"><a href="#1-自己构思" class="headerlink" title="1.自己构思"></a>1.自己构思</h2><p>无法解决：</p>
<ul>
<li>二维数组排序，自己想像冒泡那样移动</li>
<li>合并后另外开一个数组的大小自己没办法掌握</li>
</ul>
<p>总结： JAVA语法和Arrays函数不熟练</p>
<h2 id="2-学习题解代码"><a href="#2-学习题解代码" class="headerlink" title="2.学习题解代码"></a>2.学习<a href="https://leetcode-cn.com/problems/merge-intervals/solution/chi-jing-ran-yi-yan-miao-dong-by-sweetiee/" target="_blank" rel="noopener">题解</a>代码</h2><h3 id="合并逻辑："><a href="#合并逻辑：" class="headerlink" title="合并逻辑："></a><strong>合并逻辑</strong>：</h3><p> <strong>第一个区间的起始位置 ≤ 第二个区间的起始位置</strong>，如果不满足这个假设，交换这两个区间</p>
<img src="/images/LEA/91d75169b1cdb15560d361f8cb7050adfe7906c955afbe8846b92d1beba8a0d7-image.png" alt="image.png" style="zoom:33%;" />

<h3 id="代码分析："><a href="#代码分析：" class="headerlink" title="代码分析："></a>代码分析：</h3><h4 id="解决自己问题："><a href="#解决自己问题：" class="headerlink" title="解决自己问题："></a>解决自己问题：</h4><ol>
<li><p>排序数组（sort是调优后的快排） 【按照区间起始值比较整个区间】</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line">Arrays.sort(intervals, (v1, v2) -&gt; v1[<span class="number">0</span>] - v2[<span class="number">0</span>])</span><br></pre></td></tr></table></figure></div>

<p>其中【不懂坑先记住】 <code>(v1, v2) -&gt; v1[0] - v2[0])</code> 是lambda表达式，传入一个自定义比较器Comparator</p>
<p>逻辑：假设传来两个值，<code>v1</code> 与 <code>v2</code>，那么他们的先后顺序以 <code>v1[0]</code> 比 <code>v2[0]</code> 的结果为准，即：若 <code>v1[0] &lt; v2[0]</code> 则 <code>v1 &lt; v2</code>，若 <code>=</code> 则 <code>=</code>，若 <code>&gt;</code> 则 <code>&gt;</code></p>
</li>
<li><p>合并逻辑</p>
<p>反向思考：<strong>排序后不合并的情况少</strong></p>
</li>
<li><p>拷贝数组，返回结果</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line">Arrays.copyOf(res, idx + <span class="number">1</span>)</span><br></pre></td></tr></table></figure></div>

<p>实现现数组的复制，返回复制后的数组，参数是被复制的数组和复制的长度</p>
</li>
</ol>
<h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><h4 id="第一种：排序"><a href="#第一种：排序" class="headerlink" title="第一种：排序"></a>第一种：排序</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//简洁代码</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] merge(<span class="keyword">int</span>[][] intervals) &#123;</span><br><span class="line">        <span class="comment">// 先按照区间起始位置排序</span></span><br><span class="line">        Arrays.sort(intervals, (v1, v2) -&gt; v1[<span class="number">0</span>] - v2[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// 遍历区间</span></span><br><span class="line">        <span class="keyword">int</span>[][] res = <span class="keyword">new</span> <span class="keyword">int</span>[intervals.length][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> idx = -<span class="number">1</span>;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] interval: intervals) &#123;</span><br><span class="line">            <span class="comment">// 如果结果数组是空的，或者当前区间的起始位置 &gt; 结果数组中最后区间的终止位置，</span></span><br><span class="line">            <span class="comment">// 则不合并，直接将当前区间加入结果数组。</span></span><br><span class="line">            <span class="keyword">if</span> (idx == -<span class="number">1</span> || interval[<span class="number">0</span>] &gt; res[idx][<span class="number">1</span>]) &#123;</span><br><span class="line">                res[++idx] = interval;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 反之将当前区间合并至结果数组的最后区间</span></span><br><span class="line">                res[idx][<span class="number">1</span>] = Math.max(res[idx][<span class="number">1</span>], interval[<span class="number">1</span>]);</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOf(res, idx + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="第二种：枚举【遍历】"><a href="#第二种：枚举【遍历】" class="headerlink" title="第二种：枚举【遍历】"></a>第二种：枚举【遍历】</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类似冒泡，枚举所有可能</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] merge(<span class="keyword">int</span>[][] intervals) &#123;</span><br><span class="line">    <span class="keyword">int</span> len = intervals.length;</span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">2</span>) <span class="keyword">return</span> intervals;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>; <span class="comment">// 合并次数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (intervals[i][<span class="number">0</span>] &lt;= intervals[j][<span class="number">1</span>] &amp;&amp; intervals[i][<span class="number">1</span>] &gt;= intervals[j][<span class="number">0</span>]) &#123;</span><br><span class="line">                intervals[j][<span class="number">0</span>] = Math.min(intervals[j][<span class="number">0</span>], intervals[i][<span class="number">0</span>]);</span><br><span class="line">                intervals[j][<span class="number">1</span>] = Math.max(intervals[j][<span class="number">1</span>], intervals[i][<span class="number">1</span>]);</span><br><span class="line">                intervals[i] = <span class="keyword">null</span>; <span class="comment">// 清空前者</span></span><br><span class="line">                cnt++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][] res = <span class="keyword">new</span> <span class="keyword">int</span>[len - cnt][<span class="number">2</span>]; <span class="comment">// len - cnt 合并后个数</span></span><br><span class="line">    <span class="keyword">int</span> ri = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] pair : intervals) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pair != <span class="keyword">null</span>) res[ri++] = pair;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h4 id="tips"><a href="#tips" class="headerlink" title="tips:"></a>tips:</h4><ul>
<li><p>if语句判断-1情况，后面越界可忽略</p>
</li>
<li><p><code>intervals[j] = new int []{start,end};</code>新建一维数组的3种方法</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">a[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">a[<span class="number">1</span>] = <span class="number">3</span>;</span><br></pre></td></tr></table></figure></div>






</li>
</ul>
<blockquote>
<p>文件名：LEA1</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCodeExplore</tag>
        <tag>LeetcodeExploreA&amp;S</tag>
      </tags>
  </entry>
  <entry>
    <title>旋转链表</title>
    <url>/2020/09/13/LEL14/</url>
    <content><![CDATA[<h1 id="题目：-旋转链表-Medium"><a href="#题目：-旋转链表-Medium" class="headerlink" title="题目： 旋转链表 Medium"></a>题目： <a href="https://leetcode-cn.com/problems/rotate-list/" target="_blank" rel="noopener">旋转链表</a> Medium</h1><h3 id="解决方案一-直觉成环断开"><a href="#解决方案一-直觉成环断开" class="headerlink" title="解决方案一: 直觉成环断开"></a>解决方案一: 直觉成环断开</h3><h4 id="解题逻辑："><a href="#解题逻辑：" class="headerlink" title="解题逻辑："></a><strong>解题逻辑</strong>：</h4><ul>
<li><img src="/images/LEL14/image-20200913213620333.png" alt="image-20200913213620333" style="zoom: 67%;" /></li>
<li><img src="/images/LEL14/image-20200913213640669.png" alt="image-20200913213640669"></li>
</ul>
<h4 id="代码分析："><a href="#代码分析：" class="headerlink" title="代码分析："></a>代码分析：</h4><h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> ListNode <span class="title">rotateRight</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base cases</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// close the linked list into the ring</span></span><br><span class="line">    <span class="comment">//巧妙即找到了尾结点又计算出链表长度</span></span><br><span class="line">    ListNode old_tail = head;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">for</span>(n = <span class="number">1</span>; old_tail.next != <span class="keyword">null</span>; n++)</span><br><span class="line">      old_tail = old_tail.next;</span><br><span class="line">    old_tail.next = head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find new tail : (n - k % n - 1)th node</span></span><br><span class="line">    <span class="comment">// and new head : (n - k % n)th node</span></span><br><span class="line">    ListNode new_tail = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - k % n - <span class="number">1</span>; i++)</span><br><span class="line">      new_tail = new_tail.next;</span><br><span class="line">    ListNode new_head = new_tail.next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// break the ring</span></span><br><span class="line">    new_tail.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> new_head;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<blockquote>
<p>文件名：LEL14</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCodeExplore</tag>
        <tag>LeetcodeExploreLL</tag>
      </tags>
  </entry>
  <entry>
    <title>复制带随机指针的链表</title>
    <url>/2020/09/13/LEL13/</url>
    <content><![CDATA[<h1 id="题目：-复制带随机指针的链表-Medium"><a href="#题目：-复制带随机指针的链表-Medium" class="headerlink" title="题目： 复制带随机指针的链表 Medium"></a>题目： <a href="https://leetcode-cn.com/problems/copy-list-with-random-pointer/" target="_blank" rel="noopener">复制带随机指针的链表</a> Medium</h1><h3 id="解决方案一：递归回溯"><a href="#解决方案一：递归回溯" class="headerlink" title="解决方案一：递归回溯"></a>解决方案一：递归回溯</h3><h4 id="解题逻辑：递归回溯"><a href="#解题逻辑：递归回溯" class="headerlink" title="解题逻辑：递归回溯"></a><strong>解题逻辑</strong>：递归回溯</h4><ul>
<li>回溯算法的第一想法是将链表想象成一张图。链表中每个节点都有 2 个指针（图中的边）。因为随机指针给图结构添加了随机性，所以我们可能会访问相同的节点多次，这样就形成了环。</li>
<li>此方法中，我们只需要遍历整个图并拷贝它。拷贝的意思是每当遇到一个新的未访问过的节点，你都需要创造一个新的节点。遍历按照深度优先进行。我们需要在回溯的过程中<strong>记录</strong>已经访问过的节点，否则因为随机指针的存在我们可能会产生死循环</li>
</ul>
<h4 id="代码分析："><a href="#代码分析：" class="headerlink" title="代码分析："></a>代码分析：</h4><h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public Node next;</span></span><br><span class="line"><span class="comment">    public Node random;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val,Node _next,Node _random) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        next = _next;</span></span><br><span class="line"><span class="comment">        random = _random;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="comment">// HashMap which holds old nodes as keys and new nodes as its values.</span></span><br><span class="line">  HashMap&lt;Node, Node&gt; visitedHash = <span class="keyword">new</span> HashMap&lt;Node, Node&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Node <span class="title">copyRandomList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we have already processed the current node, then we simply return the cloned version of</span></span><br><span class="line">    <span class="comment">// it.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.visitedHash.containsKey(head)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.visitedHash.get(head);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a new node with the value same as old node. (i.e. copy the node)</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(head.val, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Save this value in the hash map. This is needed since there might be</span></span><br><span class="line">    <span class="comment">// loops during traversal due to randomness of random pointers and this would help us avoid</span></span><br><span class="line">    <span class="comment">// them.</span></span><br><span class="line">    <span class="keyword">this</span>.visitedHash.put(head, node);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Recursively copy the remaining linked list starting once from the next pointer and then from</span></span><br><span class="line">    <span class="comment">// the random pointer.</span></span><br><span class="line">    <span class="comment">// Thus we have two independent recursive calls.</span></span><br><span class="line">    <span class="comment">// Finally we update the next and random pointers for the new node created.</span></span><br><span class="line">    node.next = <span class="keyword">this</span>.copyRandomList(head.next);</span><br><span class="line">    node.random = <span class="keyword">this</span>.copyRandomList(head.random);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="解决方案二：空间O-n-迭代"><a href="#解决方案二：空间O-n-迭代" class="headerlink" title="解决方案二：空间O(n)迭代"></a>解决方案二：空间O(n)迭代</h3><p><img src="/images/LEL13/image-20200913205350291.png" alt="image-20200913205350291"></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public Node next;</span></span><br><span class="line"><span class="comment">    public Node random;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val,Node _next,Node _random) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        next = _next;</span></span><br><span class="line"><span class="comment">        random = _random;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="comment">// HashMap which holds old nodes as keys and new nodes as its values.</span></span><br><span class="line">  HashMap&lt;Node, Node&gt; visitedHash = <span class="keyword">new</span> HashMap&lt;Node, Node&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Node <span class="title">copyRandomList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we have already processed the current node, then we simply return the cloned version of</span></span><br><span class="line">    <span class="comment">// it.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.visitedHash.containsKey(head)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.visitedHash.get(head);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a new node with the value same as old node. (i.e. copy the node)</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(head.val, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Save this value in the hash map. This is needed since there might be</span></span><br><span class="line">    <span class="comment">// loops during traversal due to randomness of random pointers and this would help us avoid</span></span><br><span class="line">    <span class="comment">// them.</span></span><br><span class="line">    <span class="keyword">this</span>.visitedHash.put(head, node);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Recursively copy the remaining linked list starting once from the next pointer and then from</span></span><br><span class="line">    <span class="comment">// the random pointer.</span></span><br><span class="line">    <span class="comment">// Thus we have two independent recursive calls.</span></span><br><span class="line">    <span class="comment">// Finally we update the next and random pointers for the new node created.</span></span><br><span class="line">    node.next = <span class="keyword">this</span>.copyRandomList(head.next);</span><br><span class="line">    node.random = <span class="keyword">this</span>.copyRandomList(head.random);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="解决方案三-O-1-迭代"><a href="#解决方案三-O-1-迭代" class="headerlink" title="解决方案三:O(1)迭代"></a>解决方案三:O(1)迭代</h3><ol>
<li>遍历原来的链表并拷贝每一个节点，将拷贝节点放在原来节点的旁边，创造出一个旧节点和新节点交错的链表。</li>
<li>迭代这个新旧节点交错的链表，并用旧节点的 <code>random</code> 指针去更新对应新节点的 <code>random</code> 指针</li>
<li>现在 <code>random</code> 指针已经被赋值给正确的节点， <code>next</code> 指针也需要被正确赋值，以便将新的节点正确链接同时将旧节点重新正确链接。</li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public Node next;</span></span><br><span class="line"><span class="comment">    public Node random;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val,Node _next,Node _random) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        next = _next;</span></span><br><span class="line"><span class="comment">        random = _random;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Node <span class="title">copyRandomList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Creating a new weaved list of original and copied nodes.</span></span><br><span class="line">    Node ptr = head;</span><br><span class="line">    <span class="keyword">while</span> (ptr != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Cloned node</span></span><br><span class="line">      Node newNode = <span class="keyword">new</span> Node(ptr.val);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Inserting the cloned node just next to the original node.</span></span><br><span class="line">      <span class="comment">// If A-&gt;B-&gt;C is the original linked list,</span></span><br><span class="line">      <span class="comment">// Linked list after weaving cloned nodes would be A-&gt;A'-&gt;B-&gt;B'-&gt;C-&gt;C'</span></span><br><span class="line">      newNode.next = ptr.next;</span><br><span class="line">      ptr.next = newNode;</span><br><span class="line">      ptr = newNode.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ptr = head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Now link the random pointers of the new nodes created.</span></span><br><span class="line">    <span class="comment">// Iterate the newly created list and use the original nodes' random pointers,</span></span><br><span class="line">    <span class="comment">// to assign references to random pointers for cloned nodes.</span></span><br><span class="line">    <span class="keyword">while</span> (ptr != <span class="keyword">null</span>) &#123;</span><br><span class="line">      ptr.next.random = (ptr.random != <span class="keyword">null</span>) ? ptr.random.next : <span class="keyword">null</span>;</span><br><span class="line">      ptr = ptr.next.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Unweave the linked list to get back the original linked list and the cloned list.</span></span><br><span class="line">    <span class="comment">// i.e. A-&gt;A'-&gt;B-&gt;B'-&gt;C-&gt;C' would be broken to A-&gt;B-&gt;C and A'-&gt;B'-&gt;C'</span></span><br><span class="line">    Node ptr_old_list = head; <span class="comment">// A-&gt;B-&gt;C</span></span><br><span class="line">    Node ptr_new_list = head.next; <span class="comment">// A'-&gt;B'-&gt;C'</span></span><br><span class="line">    Node head_old = head.next;</span><br><span class="line">    <span class="keyword">while</span> (ptr_old_list != <span class="keyword">null</span>) &#123;</span><br><span class="line">      ptr_old_list.next = ptr_old_list.next.next;</span><br><span class="line">      ptr_new_list.next = (ptr_new_list.next != <span class="keyword">null</span>) ? ptr_new_list.next.next : <span class="keyword">null</span>;</span><br><span class="line">      ptr_old_list = ptr_old_list.next;</span><br><span class="line">      ptr_new_list = ptr_new_list.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head_old;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<blockquote>
<p>文件名：LEL13</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCodeExplore</tag>
        <tag>LeetcodeExploreLL</tag>
      </tags>
  </entry>
  <entry>
    <title>回文链表</title>
    <url>/2020/09/10/LEL9/</url>
    <content><![CDATA[<h1 id="题目：-回文链表-Easy"><a href="#题目：-回文链表-Easy" class="headerlink" title="题目： 回文链表   Easy"></a>题目： <a href="https://leetcode-cn.com/problems/palindrome-linked-list/" target="_blank" rel="noopener">回文链表</a>   Easy</h1><h3 id="解决方案一-：将值复制到数组中后用双指针法"><a href="#解决方案一-：将值复制到数组中后用双指针法" class="headerlink" title="解决方案一 ：将值复制到数组中后用双指针法"></a>解决方案一 ：将值复制到数组中后用双指针法</h3><h4 id="解题逻辑："><a href="#解题逻辑：" class="headerlink" title="解题逻辑："></a><strong>解题逻辑</strong>：</h4><ul>
<li>分为两个步骤：<ol>
<li>复制链表值到数组列表中。</li>
<li>使用双指针法判断是否为回文。</li>
</ol>
</li>
</ul>
<h4 id="代码分析："><a href="#代码分析：" class="headerlink" title="代码分析："></a>代码分析：</h4><h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; vals = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Convert LinkedList into ArrayList.</span></span><br><span class="line">        ListNode currentNode = head;</span><br><span class="line">        <span class="keyword">while</span> (currentNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            vals.add(currentNode.val);</span><br><span class="line">            currentNode = currentNode.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Use two-pointer technique to check for palindrome.</span></span><br><span class="line">        <span class="keyword">int</span> front = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> back = vals.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (front &lt; back) &#123;</span><br><span class="line">            <span class="comment">// Note that we must use ! .equals instead of !=</span></span><br><span class="line">            <span class="comment">// because we are comparing Integer, not int.</span></span><br><span class="line">            <span class="keyword">if</span> (!vals.get(front).equals(vals.get(back))) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            front++;</span><br><span class="line">            back--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="解决方案二：递归"><a href="#解决方案二：递归" class="headerlink" title="解决方案二：递归"></a>解决方案二：递归</h3><h4 id="代码分析：-1"><a href="#代码分析：-1" class="headerlink" title="代码分析："></a>代码分析：</h4><p><img src="/images/LEL9/image-20200910172938313.png" alt="image-20200910172938313"></p>
<h4 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ListNode frontPointer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">recursivelyCheck</span><span class="params">(ListNode currentNode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (currentNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//深入到尾结点</span></span><br><span class="line">            <span class="keyword">if</span> (!recursivelyCheck(currentNode.next)) <span class="keyword">return</span> <span class="keyword">false</span>; </span><br><span class="line">            <span class="comment">//从后往前比较</span></span><br><span class="line">            <span class="keyword">if</span> (currentNode.val != frontPointer.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            frontPointer = frontPointer.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        frontPointer = head;</span><br><span class="line">        <span class="keyword">return</span> recursivelyCheck(head);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="解决方案三：改变表反转后部分比较"><a href="#解决方案三：改变表反转后部分比较" class="headerlink" title="解决方案三：改变表反转后部分比较"></a>解决方案三：改变表反转后部分比较</h3><h4 id="代码分析：-2"><a href="#代码分析：-2" class="headerlink" title="代码分析："></a>代码分析：</h4><ol>
<li>将链表的后半部分反转（修改链表结构），然后将前半部分和后半部分进行比较。</li>
<li>比较完成后我们应该将链表恢复原样。</li>
</ol>
<h4 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a>实现代码</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Find the end of first half and reverse second half.</span></span><br><span class="line">        ListNode firstHalfEnd = endOfFirstHalf(head);</span><br><span class="line">        ListNode secondHalfStart = reverseList(firstHalfEnd.next);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check whether or not there is a palindrome.</span></span><br><span class="line">        ListNode p1 = head;</span><br><span class="line">        ListNode p2 = secondHalfStart;</span><br><span class="line">        <span class="comment">//result记录答案，以便restore 列表</span></span><br><span class="line">        <span class="keyword">boolean</span> result = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (result &amp;&amp; p2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p1.val != p2.val) result = <span class="keyword">false</span>;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125;        </span><br><span class="line"></span><br><span class="line">        <span class="comment">// Restore the list and return the result.</span></span><br><span class="line">        firstHalfEnd.next = reverseList(secondHalfStart);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//反转链表算法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode prev = <span class="keyword">null</span>;</span><br><span class="line">        ListNode curr = head;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ListNode nextTemp = curr.next;</span><br><span class="line">            curr.next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = nextTemp;</span><br><span class="line">        &#125;</span><br><span class="line">     <span class="comment">//while(cur != null )&#123;</span></span><br><span class="line">        <span class="comment">//     ListNode temp = cur;</span></span><br><span class="line">        <span class="comment">//     cur = cur.next;</span></span><br><span class="line">        <span class="comment">//     temp.next = prev;</span></span><br><span class="line">        <span class="comment">//     prev = temp;</span></span><br><span class="line">        <span class="comment">// &#125;   </span></span><br><span class="line">        <span class="comment">//自己写的更好！哼！</span></span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//找到中间结点，若链表有奇数个结点，则中间结点包含在前面部分</span></span><br><span class="line">    <span class="comment">//在比较遍历时，中间结点不会参与比较，因为在此之前p2部分遍历完毕，整体结束</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">endOfFirstHalf</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast.next != <span class="keyword">null</span> &amp;&amp; fast.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>文件名：LEL9</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCodeExplore</tag>
        <tag>LeetcodeExploreLL</tag>
      </tags>
  </entry>
  <entry>
    <title>删除链表的倒数第N个节点</title>
    <url>/2020/09/09/LEL5/</url>
    <content><![CDATA[<h1 id="题目：-删除链表的倒数第N个节点-Medium"><a href="#题目：-删除链表的倒数第N个节点-Medium" class="headerlink" title="题目： 删除链表的倒数第N个节点   Medium"></a>题目： <a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">删除链表的倒数第N个节点</a>   Medium</h1><h2 id="1-自己构思：双指针"><a href="#1-自己构思：双指针" class="headerlink" title="1.自己构思：双指针"></a>1.自己构思：双指针</h2><h3 id="出现问题："><a href="#出现问题：" class="headerlink" title="出现问题："></a>出现问题：</h3><ol>
<li>直接新键node指向head，对list很短情况如<code>[1]</code>出现边界问题</li>
</ol>
<h3 id="问题解决："><a href="#问题解决：" class="headerlink" title="问题解决："></a>问题解决：</h3><ol>
<li>采用<strong>头部哨兵结点</strong>dummy保证不为空，方便处理list全部删除情况</li>
</ol>
<h2 id="2-学习题解代码"><a href="#2-学习题解代码" class="headerlink" title="2.学习题解代码"></a>2.学习题解代码</h2><h3 id="解决方案一：双指针"><a href="#解决方案一：双指针" class="headerlink" title="解决方案一：双指针"></a>解决方案一：双指针</h3><img src="/images/LEL5/4e134986ba59f69042b2769b84e3f2682f6745033af7bcabcab42922a58091ba-file_1555694482088" alt="Remove the nth element from a list" style="zoom:67%;" />

<h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    dummy.next = head;</span><br><span class="line">    ListNode first = dummy;</span><br><span class="line">    ListNode second = dummy;</span><br><span class="line">    <span class="comment">// Advances first pointer so that the gap between first and second is n nodes apart</span></span><br><span class="line">    <span class="comment">// n + 1 间隔，让second结点指向被删除结点之前的结点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n + <span class="number">1</span> ; i++) &#123;</span><br><span class="line">        first = first.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Move first to the end, maintaining the gap</span></span><br><span class="line">    <span class="keyword">while</span> (first != <span class="keyword">null</span>) &#123;</span><br><span class="line">        first = first.next;</span><br><span class="line">        second = second.next;</span><br><span class="line">    &#125;</span><br><span class="line">    second.next = second.next.next;</span><br><span class="line">        <span class="comment">//返回真头结点</span></span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="Tips："><a href="#Tips：" class="headerlink" title="Tips："></a>Tips：</h4><ol>
<li><p>在调用 next 字段之前，始终<strong>检查节点是否为空</strong>。</p>
<p>获取空节点的下一个节点将导致空指针错误。例如，在我们运行 fast = fast.next.next 之前，需要检查 <code>fast</code> 和 <code>fast.next</code> 不为空。</p>
</li>
<li><p>仔细定义循环的<strong>结束条件</strong>。</p>
<p> 运行几个示例，以确保你的结束条件不会导致无限循环。在定义结束条件时，你必须考虑我们的第一点提示。</p>
</li>
</ol>
<h3 id="解决方案二"><a href="#解决方案二" class="headerlink" title="解决方案二"></a>解决方案二</h3><h3 id="解决方案三"><a href="#解决方案三" class="headerlink" title="解决方案三"></a>解决方案三</h3><blockquote>
<p>文件名：LEL5</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCodeExplore</tag>
        <tag>LeetcodeExploreLL</tag>
      </tags>
  </entry>
  <entry>
    <title>扁平化多级双向链表</title>
    <url>/2020/09/13/LEL12/</url>
    <content><![CDATA[<h1 id="题目：-扁平化多级双向链表-Medium"><a href="#题目：-扁平化多级双向链表-Medium" class="headerlink" title="题目： 扁平化多级双向链表   Medium"></a>题目： <a href="https://leetcode-cn.com/problems/flatten-a-multilevel-doubly-linked-list/" target="_blank" rel="noopener">扁平化多级双向链表</a>   Medium</h1><h3 id="解决方案一：递归DFS"><a href="#解决方案一：递归DFS" class="headerlink" title="解决方案一：递归DFS"></a>解决方案一：递归DFS</h3><h4 id="解题逻辑："><a href="#解题逻辑：" class="headerlink" title="解题逻辑："></a><strong>解题逻辑</strong>：</h4><ul>
<li><img src="/images/LEL12/image-20200913173853571.png" alt="image-20200913173853571" style="zoom: 67%;" /></li>
<li><img src="/images/LEL12/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvNDMwLzQzMF9kZnNfdHJlZS5wbmc" alt="在这里插入图片描述" style="zoom:67%;" />

</li>
</ul>
<h4 id="代码分析："><a href="#代码分析：" class="headerlink" title="代码分析："></a>代码分析：</h4><h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public Node prev;</span></span><br><span class="line"><span class="comment">    public Node next;</span></span><br><span class="line"><span class="comment">    public Node child;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val,Node _prev,Node _next,Node _child) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        prev = _prev;</span></span><br><span class="line"><span class="comment">        next = _next;</span></span><br><span class="line"><span class="comment">        child = _child;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Node <span class="title">flatten</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="comment">// pseudo head to ensure the `prev` pointer is never none</span></span><br><span class="line">    Node pseudoHead = <span class="keyword">new</span> Node(<span class="number">0</span>, <span class="keyword">null</span>, head, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    flattenDFS(pseudoHead, head);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// detach the pseudo head from the real head</span></span><br><span class="line">    <span class="comment">//关键</span></span><br><span class="line">    pseudoHead.next.prev = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> pseudoHead.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* return the tail of the flatten list */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Node <span class="title">flattenDFS</span><span class="params">(Node prev, Node curr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (curr == <span class="keyword">null</span>) <span class="keyword">return</span> prev;</span><br><span class="line">    curr.prev = prev;</span><br><span class="line">    prev.next = curr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the curr.next would be tempered in the recursive function</span></span><br><span class="line">    Node tempNext = curr.next;</span><br><span class="line"></span><br><span class="line">    Node tail = flattenDFS(curr, curr.child);</span><br><span class="line">    <span class="comment">//把父节点的child在形成链表时置NULL</span></span><br><span class="line">    curr.child = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> flattenDFS(tail, tempNext);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="解决方案二：栈迭代DFS"><a href="#解决方案二：栈迭代DFS" class="headerlink" title="解决方案二：栈迭代DFS"></a>解决方案二：栈迭代DFS</h3><p><img src="/images/LEL12/image-20200913174049971.png" alt="image-20200913174049971"></p>
<h4 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public Node prev;</span></span><br><span class="line"><span class="comment">    public Node next;</span></span><br><span class="line"><span class="comment">    public Node child;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val,Node _prev,Node _next,Node _child) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        prev = _prev;</span></span><br><span class="line"><span class="comment">        next = _next;</span></span><br><span class="line"><span class="comment">        child = _child;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Node <span class="title">flatten</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">    Node pseudoHead = <span class="keyword">new</span> Node(<span class="number">0</span>, <span class="keyword">null</span>, head, <span class="keyword">null</span>);</span><br><span class="line">    Node curr, prev = pseudoHead;</span><br><span class="line"></span><br><span class="line">    Deque&lt;Node&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    stack.push(head);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">      curr = stack.pop();</span><br><span class="line">      prev.next = curr;</span><br><span class="line">      curr.prev = prev;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (curr.next != <span class="keyword">null</span>) stack.push(curr.next);</span><br><span class="line">      <span class="keyword">if</span> (curr.child != <span class="keyword">null</span>) &#123;</span><br><span class="line">        stack.push(curr.child);</span><br><span class="line">        <span class="comment">// don't forget to remove all child pointers.</span></span><br><span class="line">        curr.child = <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      prev = curr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// detach the pseudo node from the result</span></span><br><span class="line">    pseudoHead.next.prev = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> pseudoHead.next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="解决方案三"><a href="#解决方案三" class="headerlink" title="解决方案三"></a>解决方案三</h3><blockquote>
<p>文件名：LEL12</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCodeExplore</tag>
        <tag>LeetcodeExploreLL</tag>
      </tags>
  </entry>
  <entry>
    <title>两数相加</title>
    <url>/2020/09/11/LEL11/</url>
    <content><![CDATA[<h1 id="题目：-两数相加-Medium"><a href="#题目：-两数相加-Medium" class="headerlink" title="题目： 两数相加  Medium"></a>题目： <a href="https://leetcode-cn.com/problems/add-two-numbers/" target="_blank" rel="noopener">两数相加</a>  Medium</h1><h2 id="1-自己构思"><a href="#1-自己构思" class="headerlink" title="1.自己构思"></a>1.自己构思</h2><h3 id="出现问题："><a href="#出现问题：" class="headerlink" title="出现问题："></a>出现问题：</h3><ol>
<li>链表末尾判断进位刚开始有点模糊</li>
</ol>
<h3 id="问题解决："><a href="#问题解决：" class="headerlink" title="问题解决："></a>问题解决：</h3><ol>
<li>增加while循环判断进位情况</li>
</ol>
<h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="keyword">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span>(l2 == <span class="keyword">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>) , prev = dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> carry = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode temp  = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(carry)</span><br><span class="line">                temp.val = l1.val + l2.val + <span class="number">1</span>;                        </span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                temp.val = l1.val + l2.val;</span><br><span class="line">            <span class="keyword">if</span>(temp.val &gt;= <span class="number">10</span>)</span><br><span class="line">            &#123;</span><br><span class="line">              temp.val -= <span class="number">10</span>; </span><br><span class="line">              carry = <span class="keyword">true</span> ;  </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> carry =<span class="keyword">false</span>;  </span><br><span class="line">            l1 = l1.next;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">            prev.next = temp;</span><br><span class="line">            prev = prev.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断末尾情况</span></span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(carry)&#123;</span><br><span class="line">                prev.next = l2;</span><br><span class="line">                l2.val = l2.val + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(prev.next.val &lt; <span class="number">10</span>) carry = <span class="keyword">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            prev.next = l2;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(l1 != <span class="keyword">null</span> &amp;&amp; l2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(carry)&#123;</span><br><span class="line">                prev.next = l1;</span><br><span class="line">                l1.val = l1.val + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(prev.next.val &lt; <span class="number">10</span>) carry = <span class="keyword">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            prev.next = l1;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(carry)&#123;</span><br><span class="line">                ListNode temp  = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">                prev.next = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            carry = <span class="keyword">false</span>;</span><br><span class="line">        &#125;	</span><br><span class="line">        <span class="comment">//判断持续进位情况</span></span><br><span class="line">        <span class="keyword">while</span>(carry)</span><br><span class="line">        &#123;</span><br><span class="line">            prev = prev.next;</span><br><span class="line">            prev.val -= <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span>(prev.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">                ListNode temp  = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">                prev.next = temp;</span><br><span class="line">                carry = <span class="keyword">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(++prev.next.val &lt; <span class="number">10</span>) carry =<span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h2 id="2-学习题解代码"><a href="#2-学习题解代码" class="headerlink" title="2.学习题解代码"></a>2.学习题解代码</h2><h3 id="解决方案一"><a href="#解决方案一" class="headerlink" title="解决方案一"></a>解决方案一</h3><h4 id="解题逻辑："><a href="#解题逻辑：" class="headerlink" title="解题逻辑："></a><strong>解题逻辑</strong>：</h4><img src="/images/LEL11/image-20200911171832713.png" alt="image-20200911171832713" style="zoom: 80%;" />

<h4 id="代码分析："><a href="#代码分析：" class="headerlink" title="代码分析："></a>代码分析：</h4><h4 id="解决自己问题："><a href="#解决自己问题：" class="headerlink" title="解决自己问题："></a>解决自己问题：</h4><ul>
<li>增加一个进位变量carry 以及将首先遍历到null的列表的值设为0，保证了基本的加法运算循环进行</li>
</ul>
<h4 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    ListNode dummyHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode p = l1, q = l2, curr = dummyHead;</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span> || q != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = (p != <span class="keyword">null</span>) ? p.val : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> y = (q != <span class="keyword">null</span>) ? q.val : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = carry + x + y;</span><br><span class="line">        carry = sum / <span class="number">10</span>;</span><br><span class="line">        curr.next = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">        curr = curr.next;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="keyword">null</span>) p = p.next;</span><br><span class="line">        <span class="keyword">if</span> (q != <span class="keyword">null</span>) q = q.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (carry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        curr.next = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="解决方案二：递归"><a href="#解决方案二：递归" class="headerlink" title="解决方案二：递归"></a>解决方案二：递归</h3><h4 id="实现代码："><a href="#实现代码：" class="headerlink" title="实现代码："></a>实现代码：</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    ListNode head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    helper(head, l1, l2, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> head.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(ListNode result, ListNode l1, ListNode l2, <span class="keyword">int</span> carry)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l1 == <span class="keyword">null</span> &amp;&amp; l2 == <span class="keyword">null</span> &amp;&amp; carry == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = (l1 != <span class="keyword">null</span> ? l1.val : <span class="number">0</span>) + (l2 != <span class="keyword">null</span> ? l2.val : <span class="number">0</span>) + carry;</span><br><span class="line">    result.next = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    result.next.val = sum % <span class="number">10</span>;</span><br><span class="line">    carry = sum / <span class="number">10</span>;</span><br><span class="line">    helper(result.next, l1 != <span class="keyword">null</span> ? l1.next : <span class="keyword">null</span>, l2 != <span class="keyword">null</span> ? l2.next : <span class="keyword">null</span>, carry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="解决方案三"><a href="#解决方案三" class="headerlink" title="解决方案三"></a>解决方案三</h3><blockquote>
<p>文件名：LEL11</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCodeExplore</tag>
        <tag>LeetcodeExploreLL</tag>
      </tags>
  </entry>
  <entry>
    <title>合并两个有序链表</title>
    <url>/2020/09/11/LEL10/</url>
    <content><![CDATA[<h1 id="题目：-合并两个有序链表-Easy"><a href="#题目：-合并两个有序链表-Easy" class="headerlink" title="题目：  合并两个有序链表   Easy"></a>题目： <a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener"> 合并两个有序链表</a>   Easy</h1><h3 id="解决方案一：迭代"><a href="#解决方案一：迭代" class="headerlink" title="解决方案一：迭代"></a>解决方案一：迭代</h3><h4 id="解题逻辑："><a href="#解题逻辑：" class="headerlink" title="解题逻辑："></a><strong>解题逻辑</strong>：</h4><ul>
<li>用迭代的方法来实现。当 l1 和 l2 都不是空链表时，判断 l1 和 l2 哪一个链表的头节点的值更小，将较小值的节点添加到结果里，当一个节点被添加到结果里之后，将对应链表中的节点向后移一位。</li>
<li>看成重新构建一个新的列表，通过筛选排列节点顺序通过prev来进行连接遍历</li>
</ul>
<h4 id="代码分析："><a href="#代码分析：" class="headerlink" title="代码分析："></a>代码分析：</h4><h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//看成重新构建一个新的列表，通过筛选排列节点顺序通过prev来进行连接遍历</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>), prev = dummy;</span><br><span class="line">        <span class="keyword">while</span>(l2 != <span class="keyword">null</span> &amp;&amp; l1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1.val &lt;= l2.val)&#123;</span><br><span class="line">                prev.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                prev.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = prev.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        prev.next = l1 == <span class="keyword">null</span>? l2:l1;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="解决方案二：递归"><a href="#解决方案二：递归" class="headerlink" title="解决方案二：递归"></a>解决方案二：递归</h3><img src="/images/LEL10/image-20200911154812012.png" alt="image-20200911154812012" style="zoom:67%;" />

<h4 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//处理边界</span></span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (l2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125; <span class="comment">//递归到尾部进行判断选择连接，</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">            l1.next = mergeTwoLists(l1.next, l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            l2.next = mergeTwoLists(l1, l2.next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>文件名：LEL10</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCodeExplore</tag>
        <tag>LeetcodeExploreLL</tag>
      </tags>
  </entry>
  <entry>
    <title>奇偶链表</title>
    <url>/2020/09/10/LEL8/</url>
    <content><![CDATA[<h1 id="题目：-奇偶链表-Medium"><a href="#题目：-奇偶链表-Medium" class="headerlink" title="题目： 奇偶链表   Medium"></a>题目： <a href="https://leetcode-cn.com/problems/odd-even-linked-list/" target="_blank" rel="noopener">奇偶链表</a>   Medium</h1><h2 id="1-自己构思"><a href="#1-自己构思" class="headerlink" title="1.自己构思"></a>1.自己构思</h2><h3 id="出现问题："><a href="#出现问题：" class="headerlink" title="出现问题："></a>出现问题：</h3><ol>
<li>循环遍历链表空指针异常</li>
</ol>
<h3 id="问题解决："><a href="#问题解决：" class="headerlink" title="问题解决："></a>问题解决：</h3><ol>
<li>对走在前面的even结点及其next结点进行null判断</li>
</ol>
<h2 id="2-学习题解代码"><a href="#2-学习题解代码" class="headerlink" title="2.学习题解代码"></a>2.学习题解代码</h2><h3 id="解决方案一：奇偶双指针拼接链表"><a href="#解决方案一：奇偶双指针拼接链表" class="headerlink" title="解决方案一：奇偶双指针拼接链表"></a>解决方案一：奇偶双指针拼接链表</h3><h4 id="解题逻辑："><a href="#解题逻辑：" class="headerlink" title="解题逻辑："></a><strong>解题逻辑</strong>：</h4><ul>
<li>将奇节点放在一个链表里，偶链表放在另一个链表里。然后把偶链表接在奇链表的尾部。</li>
<li><img src="/images/LEL8/00bd1d974b5a2e6d7d4faf0d5baad1c691f4ed8963cb1b7133d1112bad4c5e86-image.png" alt="image.png" style="zoom:50%;" />

</li>
</ul>
<h4 id="代码分析："><a href="#代码分析：" class="headerlink" title="代码分析："></a>代码分析：</h4><h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">oddEvenList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode odd = head, even = head.next, evenHead = even;</span><br><span class="line">        <span class="keyword">while</span> (even != <span class="keyword">null</span> &amp;&amp; even.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            odd.next = even.next;</span><br><span class="line">            odd = odd.next;</span><br><span class="line">            even.next = odd.next;</span><br><span class="line">            even = even.next;</span><br><span class="line">        &#125;</span><br><span class="line">        odd.next = evenHead;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>文件名：LEL8</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCodeExplore</tag>
        <tag>LeetcodeExploreLL</tag>
      </tags>
  </entry>
  <entry>
    <title>移除链表元素</title>
    <url>/2020/09/10/LEL7/</url>
    <content><![CDATA[<h1 id="题目：-移除链表元素-Easy"><a href="#题目：-移除链表元素-Easy" class="headerlink" title="题目： 移除链表元素   Easy"></a>题目： <a href="https://leetcode-cn.com/problems/remove-linked-list-elements/" target="_blank" rel="noopener">移除链表元素</a>   Easy</h1><h2 id="1-自己构思"><a href="#1-自己构思" class="headerlink" title="1.自己构思"></a>1.自己构思</h2><p>只设置一个哨兵结点，未设置前置结点，直接next.next</p>
<h4 id="实现代码："><a href="#实现代码：" class="headerlink" title="实现代码："></a>实现代码：</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeElements</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        head = dummy;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(head.next !=<span class="keyword">null</span> &amp;&amp; head.next.val == val)&#123;</span><br><span class="line">                head.next = head.next.next;</span><br><span class="line">            &#125;<span class="keyword">else</span> head = head.next;               </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="tips："><a href="#tips：" class="headerlink" title="tips："></a>tips：</h4><ul>
<li>设置哨兵结点</li>
<li>对head判断</li>
</ul>
<h2 id="2-学习题解代码"><a href="#2-学习题解代码" class="headerlink" title="2.学习题解代码"></a>2.学习题解代码</h2><h3 id="解决方案一：哨兵加前置结点"><a href="#解决方案一：哨兵加前置结点" class="headerlink" title="解决方案一：哨兵加前置结点"></a>解决方案一：哨兵加前置结点</h3><h4 id="解题逻辑："><a href="#解题逻辑：" class="headerlink" title="解题逻辑："></a><strong>解题逻辑</strong>：</h4><ul>
<li><img src="/images/LEL7/c650a78cb34caf9a00469651abfc14181c474e2c6152e87273092e7dfd331f19-file_1578026286317" alt="在这里插入图片描述" style="zoom: 33%;" />
</li>
<li><img src="/images/LEL7/image-20200910111239667.png" alt="image-20200910111239667" style="zoom: 67%;" />

</li>
</ul>
<h4 id="代码分析："><a href="#代码分析：" class="headerlink" title="代码分析："></a>代码分析：</h4><h4 id="解决自己问题："><a href="#解决自己问题：" class="headerlink" title="解决自己问题："></a>解决自己问题：</h4><ul>
<li>增加前置结点，更清晰</li>
</ul>
<h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeElements</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    ListNode sentinel = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    sentinel.next = head;</span><br><span class="line"></span><br><span class="line">    ListNode prev = sentinel, curr = head;</span><br><span class="line">    <span class="keyword">while</span> (curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (curr.val == val) prev.next = curr.next;</span><br><span class="line">      <span class="keyword">else</span> prev = curr;</span><br><span class="line">      curr = curr.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sentinel.next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="解决方案二：递归"><a href="#解决方案二：递归" class="headerlink" title="解决方案二：递归"></a>解决方案二：递归</h3><p>通过递归遍历并且重构next结点指向，达到删除目的</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">removeElements</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (head.val == val) &#123;</span><br><span class="line">            head.next = removeElements(head.next, val);</span><br><span class="line">            <span class="keyword">return</span> head.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            head.next = removeElements(head.next, val);</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="解决方案三"><a href="#解决方案三" class="headerlink" title="解决方案三"></a>解决方案三</h3><blockquote>
<p>文件名：LEL7</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCodeExplore</tag>
        <tag>LeetcodeExploreLL</tag>
      </tags>
  </entry>
  <entry>
    <title>反转链表</title>
    <url>/2020/09/10/LEL6/</url>
    <content><![CDATA[<h1 id="题目：-反转链表-Easy"><a href="#题目：-反转链表-Easy" class="headerlink" title="题目： 反转链表   Easy"></a>题目： <a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">反转链表</a>   Easy</h1><h2 id="1-自己构思"><a href="#1-自己构思" class="headerlink" title="1.自己构思"></a>1.自己构思</h2><h3 id="出现问题："><a href="#出现问题：" class="headerlink" title="出现问题："></a>出现问题：</h3><ol>
<li>过于复杂的头插法操作</li>
</ol>
<h3 id="问题解决："><a href="#问题解决：" class="headerlink" title="问题解决："></a>问题解决：</h3><ol>
<li>直接反向next链接即可，注意存储上一个元素</li>
</ol>
<h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next ==<span class="keyword">null</span>) <span class="keyword">return</span> head; </span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>), ha = head , nd = head.next, ni=head.next;</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        <span class="keyword">int</span> length=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(ha != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ha = ha.next;</span><br><span class="line">            length++;</span><br><span class="line">        &#125;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(--length &gt;<span class="number">0</span>)</span><br><span class="line">        &#123;   </span><br><span class="line">            <span class="keyword">if</span>(ni != <span class="keyword">null</span>)</span><br><span class="line">            ni = ni.next;</span><br><span class="line">            nd.next = dummy.next;</span><br><span class="line">            dummy.next = nd;</span><br><span class="line">            nd = ni;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="2-学习题解代码"><a href="#2-学习题解代码" class="headerlink" title="2.学习题解代码"></a>2.学习题解代码</h2><h3 id="解决方案一：迭代"><a href="#解决方案一：迭代" class="headerlink" title="解决方案一：迭代"></a>解决方案一：迭代</h3><h4 id="解题逻辑：迭代法"><a href="#解题逻辑：迭代法" class="headerlink" title="解题逻辑：迭代法"></a><strong>解题逻辑</strong>：迭代法</h4><ul>
<li>在遍历列表时，将当前节点的 <code>next</code> 指针改为指向前一个元素。</li>
<li>由于节点没有引用其上一个节点，因此必须事先存储其前一个元素。在更改引用之前，还需要另一个指针来存储下一个节点。</li>
<li>不要忘记在最后返回新的头引用</li>
</ul>
<h4 id="代码分析："><a href="#代码分析：" class="headerlink" title="代码分析："></a>代码分析：</h4><h4 id="解决自己问题："><a href="#解决自己问题：" class="headerlink" title="解决自己问题："></a>解决自己问题：</h4><ul>
<li>过于复杂的头插法操作</li>
</ul>
<h4 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode prev = <span class="keyword">null</span>;</span><br><span class="line">    ListNode curr = head;</span><br><span class="line">    <span class="keyword">while</span> (curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ListNode nextTemp = curr.next;</span><br><span class="line">        curr.next = prev;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = nextTemp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="解决方案二：递归"><a href="#解决方案二：递归" class="headerlink" title="解决方案二：递归"></a>解决方案二：递归</h3><img src="/images/LEL6/image-20200910103646227.png" alt="image-20200910103646227" style="zoom:67%;" />

<h4 id="实现代码："><a href="#实现代码：" class="headerlink" title="实现代码："></a>实现代码：</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">    ListNode p = reverseList(head.next);</span><br><span class="line">    head.next.next = head;</span><br><span class="line">    head.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="tips："><a href="#tips：" class="headerlink" title="tips："></a>tips：</h4><ul>
<li>当前指针next指向null保证链表无循环</li>
</ul>
<h3 id="解决方案三"><a href="#解决方案三" class="headerlink" title="解决方案三"></a>解决方案三</h3><blockquote>
<p>文件名：LEL6</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCodeExplore</tag>
        <tag>LeetcodeExploreLL</tag>
      </tags>
  </entry>
  <entry>
    <title>相交链表</title>
    <url>/2020/09/09/LEL4/</url>
    <content><![CDATA[<h1 id="题目：-相交链表-Easy"><a href="#题目：-相交链表-Easy" class="headerlink" title="题目： 相交链表   Easy"></a>题目： <a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/" target="_blank" rel="noopener">相交链表</a>   Easy</h1><h3 id="解决方案一-双指针【最优】"><a href="#解决方案一-双指针【最优】" class="headerlink" title="解决方案一 : 双指针【最优】"></a>解决方案一 : 双指针【最优】</h3><h4 id="解题逻辑："><a href="#解题逻辑：" class="headerlink" title="解题逻辑："></a><strong>解题逻辑</strong>：</h4><ul>
<li><img src="/images/LEL4/image-20200909171617870.png" alt="image-20200909171617870"></li>
</ul>
<h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        ListNode ha = headA, hb = headB;</span><br><span class="line">        <span class="keyword">while</span> (ha != hb) &#123;</span><br><span class="line">            ha = ha != <span class="keyword">null</span> ? ha.next : headB;</span><br><span class="line">            hb = hb != <span class="keyword">null</span> ? hb.next : headA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ha;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="解决方案二：暴力"><a href="#解决方案二：暴力" class="headerlink" title="解决方案二：暴力"></a>解决方案二：暴力</h3><h4 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        ListNode ha = headA, hb = headB;</span><br><span class="line">        <span class="keyword">while</span>(ha != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(hb != <span class="keyword">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                    <span class="keyword">if</span>(ha == hb) <span class="keyword">return</span> ha;</span><br><span class="line">                    hb = hb.next;</span><br><span class="line">            &#125;</span><br><span class="line">            ha = ha.next;</span><br><span class="line">            hb = headB;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="解决方案三：hashset"><a href="#解决方案三：hashset" class="headerlink" title="解决方案三：hashset"></a>解决方案三：hashset</h3><h4 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a>实现代码</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        Set&lt;ListNode&gt; nodeA = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        ListNode ha = headA, hb = headB;</span><br><span class="line">        <span class="keyword">while</span>(ha != <span class="keyword">null</span>)&#123;</span><br><span class="line">            nodeA.add(ha);</span><br><span class="line">            ha = ha.next; </span><br><span class="line">        &#125;</span><br><span class="line">             </span><br><span class="line">        <span class="keyword">while</span>(hb != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nodeA.contains(hb)) <span class="keyword">return</span> hb;</span><br><span class="line">            hb = hb.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<blockquote>
<p>文件名：LEL4</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCodeExplore</tag>
        <tag>LeetcodeExploreLL</tag>
      </tags>
  </entry>
  <entry>
    <title>环形链表I&amp;II</title>
    <url>/2020/09/09/LEL3/</url>
    <content><![CDATA[<h1 id="题目：环形链表-Easy"><a href="#题目：环形链表-Easy" class="headerlink" title="题目：环形链表 Easy"></a>题目：<a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener">环形链表 </a>Easy</h1><h3 id="解决方案一：HashSet"><a href="#解决方案一：HashSet" class="headerlink" title="解决方案一：HashSet"></a>解决方案一：HashSet</h3><h4 id="解题逻辑："><a href="#解题逻辑：" class="headerlink" title="解题逻辑："></a><strong>解题逻辑</strong>：</h4><ul>
<li>通过检查一个结点此前是否被访问过来判断链表是否为环形链表</li>
</ul>
<h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    Set&lt;ListNode&gt; nodesSeen = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nodesSeen.contains(head)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nodesSeen.add(head);</span><br><span class="line">        &#125;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="解决方案二：快慢双指针"><a href="#解决方案二：快慢双指针" class="headerlink" title="解决方案二：快慢双指针"></a>解决方案二：快慢双指针</h3><h4 id="解题逻辑：-1"><a href="#解题逻辑：-1" class="headerlink" title="解题逻辑："></a>解题逻辑：</h4><ul>
<li>通过使用具有 不同速度 的快、慢两个指针遍历链表，空间复杂度可以被降低至 O(1)。慢指针每次移动一步，而快指针每次移动两步。</li>
</ul>
<ol>
<li>如果列表中不存在环，最终快指针将会最先到达尾部，此时我们可以返回 false。</li>
<li>现在考虑一个环形链表，把慢指针和快指针想象成两个在环形赛道上跑步的运动员（分别称之为慢跑者与快跑者）。而快跑者最终一定会追上慢跑者。</li>
</ol>
<h4 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode slow = head;</span><br><span class="line">    ListNode fast = head.next;</span><br><span class="line">    <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fast == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="题目：环形链表-II-Medium"><a href="#题目：环形链表-II-Medium" class="headerlink" title="题目：环形链表 II  Medium"></a>题目：<a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">环形链表 II</a>  Medium</h1><h3 id="解决方案一：HashSet-1"><a href="#解决方案一：HashSet-1" class="headerlink" title="解决方案一：HashSet"></a>解决方案一：HashSet</h3><h4 id="解题逻辑：-2"><a href="#解题逻辑：-2" class="headerlink" title="解题逻辑："></a><strong>解题逻辑</strong>：</h4><ul>
<li>用一个 <code>Set</code> 保存已经访问过的节点，则可以遍历整个列表并返回第一个出现重复的节点。</li>
</ul>
<h4 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a>实现代码</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        Set&lt;ListNode&gt; visited = <span class="keyword">new</span> HashSet&lt;ListNode&gt;();</span><br><span class="line"></span><br><span class="line">        ListNode node = head;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited.contains(node)) &#123;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">            visited.add(node);</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="解决方案二：快慢指针"><a href="#解决方案二：快慢指针" class="headerlink" title="解决方案二：快慢指针"></a>解决方案二：快慢指针</h3><h4 id="解题逻辑：-3"><a href="#解题逻辑：-3" class="headerlink" title="解题逻辑："></a><strong>解题逻辑</strong>：</h4><ul>
<li><p>先找到快慢指针相遇时的交点</p>
</li>
<li><p>【相遇节点找环入口】通过数学推导得，从头指针与交点同时出发相遇于环的入口</p>
</li>
<li><p>有<code>F = b</code></p>
<p><img src="/images/LEL3/99987d4e679fdfbcfd206a4429d9b076b46ad09bd2670f886703fb35ef130635-image.png" alt="image.png"></p>
</li>
</ul>
<h4 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a>实现代码</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">getIntersect</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode tortoise = head;</span><br><span class="line">        ListNode hare = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// A fast pointer will either loop around a cycle and meet the slow</span></span><br><span class="line">        <span class="comment">// pointer or reach the `null` at the end of a non-cyclic list.</span></span><br><span class="line">        <span class="keyword">while</span> (hare != <span class="keyword">null</span> &amp;&amp; hare.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            tortoise = tortoise.next;</span><br><span class="line">            hare = hare.next.next;</span><br><span class="line">            <span class="keyword">if</span> (tortoise == hare) &#123;</span><br><span class="line">                <span class="keyword">return</span> tortoise;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If there is a cycle, the fast/slow pointers will intersect at some</span></span><br><span class="line">        <span class="comment">// node. Otherwise, there is no cycle, so we cannot find an e***ance to</span></span><br><span class="line">        <span class="comment">// a cycle.</span></span><br><span class="line">        ListNode intersect = getIntersect(head);</span><br><span class="line">        <span class="keyword">if</span> (intersect == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// To find the e***ance to the cycle, we have two pointers traverse at</span></span><br><span class="line">        <span class="comment">// the same speed -- one from the front of the list, and the other from</span></span><br><span class="line">        <span class="comment">// the point of intersection.</span></span><br><span class="line">        ListNode ptr1 = head;</span><br><span class="line">        ListNode ptr2 = intersect;</span><br><span class="line">        <span class="keyword">while</span> (ptr1 != ptr2) &#123;</span><br><span class="line">            ptr1 = ptr1.next;</span><br><span class="line">            ptr2 = ptr2.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ptr1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><blockquote>
<p>文件名：LEL3</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCodeExplore</tag>
        <tag>LeetcodeExploreLL</tag>
      </tags>
  </entry>
  <entry>
    <title>最长公共前缀</title>
    <url>/2020/07/03/LEAS1/</url>
    <content><![CDATA[<h1 id="题目：-最长公共前缀-Easy"><a href="#题目：-最长公共前缀-Easy" class="headerlink" title="题目： 最长公共前缀  Easy"></a>题目： <a href="https://leetcode-cn.com/problems/longest-common-prefix/" target="_blank" rel="noopener">最长公共前缀</a>  Easy</h1><h3 id="解决方案一"><a href="#解决方案一" class="headerlink" title="解决方案一"></a>解决方案一</h3><h4 id="解题逻辑："><a href="#解题逻辑：" class="headerlink" title="解题逻辑："></a><strong>解题逻辑</strong>：</h4><ul>
<li><strong>横向扫描</strong>，依次遍历每个字符串，更新最长公共前缀</li>
</ul>
<h4 id="代码分析："><a href="#代码分析：" class="headerlink" title="代码分析："></a>代码分析：</h4><h4 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h4><ul>
<li><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">charAt</span><span class="params">(<span class="keyword">int</span> index)</span><span class="comment">//返回指定字符</span></span>
<span class="function"><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- &#96;&#96;&#96;java</span><br><span class="line">  public String substring(int beginIndex, int endIndex)&#x2F;&#x2F;返回子串 begin与end相等返回&quot;&quot;</span><br></pre></td></tr></table></figure></div></span>
<span class="function"></span></code></pre>
</li>
</ul>
<h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (strs == <span class="keyword">null</span> || strs.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        String prefix = strs[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> count = strs.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; count; i++) &#123;</span><br><span class="line">            prefix = longestCommonPrefix(prefix, strs[i]);</span><br><span class="line">            <span class="keyword">if</span> (prefix.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prefix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = Math.min(str1.length(), str2.length());</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; length &amp;&amp; str1.charAt(index) == str2.charAt(index)) &#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str1.substring(<span class="number">0</span>, index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="tips"><a href="#tips" class="headerlink" title="tips:"></a>tips:</h4><ul>
<li>substring返回子串 begin与end相等返回””</li>
</ul>
<h3 id="解决方案二"><a href="#解决方案二" class="headerlink" title="解决方案二"></a>解决方案二</h3><h4 id="解题逻辑：-1"><a href="#解题逻辑：-1" class="headerlink" title="解题逻辑："></a><strong>解题逻辑</strong>：</h4><ul>
<li><p><strong>纵向扫描</strong>从前往后遍历所有字符串的每一列，比较相同列上的字符是否相同，如果相同则继续对下一列进行比较，如果不相同则当前列不再属于公共前缀，当前列之前的部分为最长公共前缀。</p>
<p><img src="/images/LEAS1/14_fig2.png" alt="fig2"></p>
</li>
</ul>
<h4 id="代码分析：-1"><a href="#代码分析：-1" class="headerlink" title="代码分析："></a>代码分析：</h4><h4 id="重点-1"><a href="#重点-1" class="headerlink" title="重点"></a>重点</h4><ul>
<li>临界值判断之一：被比较字符串长度超过初始字符串长度时停止</li>
</ul>
<h4 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (strs == <span class="keyword">null</span> || strs.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> length = strs[<span class="number">0</span>].length();</span><br><span class="line">        <span class="keyword">int</span> count = strs.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = strs[<span class="number">0</span>].charAt(i);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; count; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == strs[j].length() || strs[j].charAt(i) != c) &#123;</span><br><span class="line">                    <span class="keyword">return</span> strs[<span class="number">0</span>].substring(<span class="number">0</span>, i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="tips-1"><a href="#tips-1" class="headerlink" title="tips:"></a>tips:</h4><h3 id="解决方案三"><a href="#解决方案三" class="headerlink" title="解决方案三"></a>解决方案三</h3><p><strong>解题逻辑</strong>：</p>
<ul>
<li>分治算法</li>
</ul>
<h3 id="解决方案四"><a href="#解决方案四" class="headerlink" title="解决方案四"></a>解决方案四</h3><p><strong>解题逻辑</strong>：</p>
<ul>
<li>二分查找</li>
<li><img src="/images/LEAS1/14_fig4.png" alt="fig4"></li>
</ul>
<h5 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a>实现代码</h5><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (strs == <span class="keyword">null</span> || strs.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> minLength = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (String str : strs) &#123;</span><br><span class="line">            minLength = Math.min(minLength, str.length());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = minLength;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (high - low + <span class="number">1</span>) / <span class="number">2</span> + low;</span><br><span class="line">            <span class="keyword">if</span> (isCommonPrefix(strs, mid)) &#123;</span><br><span class="line">                low = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>].substring(<span class="number">0</span>, low);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCommonPrefix</span><span class="params">(String[] strs, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        String str0 = strs[<span class="number">0</span>].substring(<span class="number">0</span>, length);</span><br><span class="line">        <span class="keyword">int</span> count = strs.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; count; i++) &#123;</span><br><span class="line">            String str = strs[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (str0.charAt(j) != str.charAt(j)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<blockquote>
<p>文件名：LAS1</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCodeExplore</tag>
        <tag>LeetcodeExploreA&amp;S</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵</title>
    <url>/2020/09/06/LEQS15/</url>
    <content><![CDATA[<h1 id="题目：-矩阵-Medium"><a href="#题目：-矩阵-Medium" class="headerlink" title="题目：  矩阵   Medium"></a>题目： <a href="https://leetcode-cn.com/problems/01-matrix/" target="_blank" rel="noopener"> 矩阵</a>   Medium</h1><h3 id="解决方案一"><a href="#解决方案一" class="headerlink" title="解决方案一"></a>解决方案一</h3><h4 id="解题逻辑：BFS"><a href="#解题逻辑：BFS" class="headerlink" title="解题逻辑：BFS"></a><strong>解题逻辑</strong>：BFS</h4><ul>
<li><img src="/images/LEQS15/image-20200907093328374.png" alt="image-20200907093328374"></li>
<li>然后将修改过的1入栈，后面第二轮遍历到的1值到0的距离就是修改过的1值加一，后面几轮依此类推可保证当修改1值的时候为最短距离</li>
</ul>
<h4 id="代码分析："><a href="#代码分析：" class="headerlink" title="代码分析："></a>代码分析：</h4><h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] updateMatrix(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line">        <span class="comment">// 首先将所有的 0 都入队，并且将 1 的位置设置成 -1，表示该位置是 未被访问过的 1</span></span><br><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;i, j&#125;);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    matrix[i][j] = -<span class="number">1</span>;</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] dx = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;-<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] dy = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] point = queue.poll();</span><br><span class="line">            <span class="keyword">int</span> x = point[<span class="number">0</span>], y = point[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> newX = x + dx[i];</span><br><span class="line">                <span class="keyword">int</span> newY = y + dy[i];</span><br><span class="line">                <span class="comment">// 如果四邻域的点是 -1，表示这个点是未被访问过的 1</span></span><br><span class="line">                <span class="comment">// 所以这个点到 0 的距离就可以更新成 matrix[x][y] + 1。</span></span><br><span class="line">                <span class="keyword">if</span> (newX &gt;= <span class="number">0</span> &amp;&amp; newX &lt; m &amp;&amp; newY &gt;= <span class="number">0</span> &amp;&amp; newY &lt; n </span><br><span class="line">                        &amp;&amp; matrix[newX][newY] == -<span class="number">1</span>) &#123;</span><br><span class="line">                    matrix[newX][newY] = matrix[x][y] + <span class="number">1</span>;</span><br><span class="line">                    queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;newX, newY&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> matrix;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h4 id="tips"><a href="#tips" class="headerlink" title="tips:"></a>tips:</h4><ul>
<li>入栈直接创建一维数组：<code>new int[] {i,j}</code></li>
<li>遍历上下左右四邻域可采用两个一维数组循环操作</li>
</ul>
<h3 id="解决方案二"><a href="#解决方案二" class="headerlink" title="解决方案二"></a>解决方案二</h3><h3 id="解决方案三"><a href="#解决方案三" class="headerlink" title="解决方案三"></a>解决方案三</h3><blockquote>
<p>文件名：LEQS15</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCodeExplore</tag>
        <tag>LeetcodeExploreQ&amp;S</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的中序遍历</title>
    <url>/2020/09/02/LEQS12/</url>
    <content><![CDATA[<h1 id="题目：-二叉树的中序遍历-Medium"><a href="#题目：-二叉树的中序遍历-Medium" class="headerlink" title="题目： 二叉树的中序遍历   Medium"></a>题目： <a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">二叉树的中序遍历</a>   Medium</h1><h2 id="1-自己构思-递归实现中序遍历"><a href="#1-自己构思-递归实现中序遍历" class="headerlink" title="1.自己构思 : 递归实现中序遍历"></a>1.自己构思 : 递归实现中序遍历</h2><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dfs(root,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode node , List&lt;Integer&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        dfs(node.left , res);</span><br><span class="line">        res.add(node.val);</span><br><span class="line">        dfs(node.right ,res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h2 id="2-学习题解代码"><a href="#2-学习题解代码" class="headerlink" title="2.学习题解代码"></a>2.学习题解代码</h2><h3 id="解决方案一-基于栈遍历"><a href="#解决方案一-基于栈遍历" class="headerlink" title="解决方案一: 基于栈遍历"></a>解决方案一: 基于栈遍历</h3><h4 id="解题逻辑："><a href="#解题逻辑：" class="headerlink" title="解题逻辑："></a><strong>解题逻辑</strong>：</h4><ul>
<li>通过栈结构，先遍历左子树入栈，当左节点为空时，出栈加入队列。</li>
<li>此时出栈顺序是后进的左节点先出，然后是根节点，最后是右节点</li>
</ul>
<h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List &lt; Integer &gt; inorderTraversal(TreeNode root) &#123;</span><br><span class="line">        List &lt; Integer &gt; res = <span class="keyword">new</span> ArrayList &lt; &gt; ();</span><br><span class="line">        Stack &lt; TreeNode &gt; stack = <span class="keyword">new</span> Stack &lt; &gt; ();</span><br><span class="line">        TreeNode curr = root;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//遍历左子树，压栈</span></span><br><span class="line">            <span class="keyword">while</span> (curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(curr);</span><br><span class="line">                curr = curr.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//不存在左节点后，向上出栈并记录，并将右节点入栈</span></span><br><span class="line">            <span class="comment">//右节点弹出后，栈顶元素为向上的第二个根节点</span></span><br><span class="line">            curr = stack.pop();</span><br><span class="line">            res.add(curr.val);	</span><br><span class="line">            curr = curr.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="解决方案二"><a href="#解决方案二" class="headerlink" title="解决方案二"></a>解决方案二</h3><h3 id="解决方案三"><a href="#解决方案三" class="headerlink" title="解决方案三"></a>解决方案三</h3><blockquote>
<p>文件名：LEQS12</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCodeExplore</tag>
        <tag>LeetcodeExploreQ&amp;S</tag>
      </tags>
  </entry>
  <entry>
    <title>逆波兰表达式求值</title>
    <url>/2020/08/30/LEQS9/</url>
    <content><![CDATA[<h1 id="题目：逆波兰表达式求值-Medium"><a href="#题目：逆波兰表达式求值-Medium" class="headerlink" title="题目：逆波兰表达式求值   Medium"></a>题目：<a href="https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/" target="_blank" rel="noopener">逆波兰表达式求值</a>   Medium</h1><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="逆波兰表达式："><a href="#逆波兰表达式：" class="headerlink" title="逆波兰表达式："></a>逆波兰表达式：</h3><p>逆波兰表达式是一种<strong>后缀表达式</strong>，所谓后缀就是指算符写在后面。</p>
<ul>
<li>平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) * ( 3 + 4 ) 。</li>
<li>该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) * ) 。</li>
</ul>
<p>逆波兰表达式主要有以下两个优点：</p>
<ul>
<li>去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。</li>
<li>适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中。</li>
</ul>
<h2 id="1-自己构思"><a href="#1-自己构思" class="headerlink" title="1.自己构思"></a>1.自己构思</h2><h3 id="出现问题："><a href="#出现问题：" class="headerlink" title="出现问题："></a>出现问题：</h3><ol>
<li>判断运算符和数字函数，并进行运算</li>
</ol>
<h3 id="问题解决："><a href="#问题解决：" class="headerlink" title="问题解决："></a>问题解决：</h3><ol>
<li><p>采用switch代替if-else，效率优化，进行对运算符和数字的判断</p>
</li>
<li><p><code>valueOf(s)</code> 返回保存指定的 String 的值的 Integer 对象，（<a href="https://blog.csdn.net/wufaliang003/article/details/82347077" target="_blank" rel="noopener">需要拆装箱</a>）</p>
<p><code>**parseInt(String s)**</code>返回用十进制参数表示的整数值。</p>
</li>
</ol>
<h2 id="2-学习题解代码"><a href="#2-学习题解代码" class="headerlink" title="2.学习题解代码"></a>2.学习题解代码</h2><h3 id="解决方案一：栈实现"><a href="#解决方案一：栈实现" class="headerlink" title="解决方案一：栈实现"></a>解决方案一：栈实现</h3><h4 id="代码分析："><a href="#代码分析：" class="headerlink" title="代码分析："></a>代码分析：</h4><h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 栈实现   </span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(String[] tokens)</span> </span>&#123;</span><br><span class="line">		Deque&lt;Integer&gt; numStack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">		Integer op1, op2;</span><br><span class="line">		<span class="keyword">for</span> (String s : tokens) &#123;</span><br><span class="line">			<span class="keyword">switch</span> (s) &#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">"+"</span>:</span><br><span class="line">				op2 = numStack.pop();</span><br><span class="line">				op1 = numStack.pop();</span><br><span class="line">				numStack.push(op1 + op2);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">"-"</span>:</span><br><span class="line">				op2 = numStack.pop();</span><br><span class="line">				op1 = numStack.pop();</span><br><span class="line">				numStack.push(op1 - op2);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">"*"</span>:</span><br><span class="line">				op2 = numStack.pop();</span><br><span class="line">				op1 = numStack.pop();</span><br><span class="line">				numStack.push(op1 * op2);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">"/"</span>:</span><br><span class="line">				op2 = numStack.pop();</span><br><span class="line">				op1 = numStack.pop();</span><br><span class="line">				numStack.push(op1 / op2);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				numStack.push(Integer.valueOf(s));</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> numStack.pop();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="解法二：数组模拟栈结构"><a href="#解法二：数组模拟栈结构" class="headerlink" title="解法二：数组模拟栈结构"></a>解法二：数组模拟栈结构</h2><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="comment">//纯数组模拟栈实现</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(String[] tokens)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] numStack = <span class="keyword">new</span> <span class="keyword">int</span>[tokens.length / <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (String s : tokens) &#123;</span><br><span class="line">			<span class="keyword">switch</span> (s) &#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">"+"</span>:</span><br><span class="line">				numStack[index - <span class="number">2</span>] += numStack[--index];</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">"-"</span>:</span><br><span class="line">				numStack[index - <span class="number">2</span>] -= numStack[--index];</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">"*"</span>:</span><br><span class="line">				numStack[index - <span class="number">2</span>] *= numStack[--index];</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">"/"</span>:</span><br><span class="line">				numStack[index - <span class="number">2</span>] /= numStack[--index];</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="comment">// numStack[index++] = Integer.valueOf(s);</span></span><br><span class="line">				<span class="comment">//valueOf改为parseInt，减少自动拆箱装箱操作</span></span><br><span class="line">				numStack[index++] = Integer.parseInt(s);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> numStack[<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<blockquote>
<p>文件名：LEQS9</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCodeExplore</tag>
        <tag>LeetcodeExploreQ&amp;S</tag>
      </tags>
  </entry>
  <entry>
    <title>有效的括号</title>
    <url>/2020/08/11/LEQS7/</url>
    <content><![CDATA[<h1 id="题目：-有效的括号-Easy"><a href="#题目：-有效的括号-Easy" class="headerlink" title="题目： 有效的括号 Easy"></a>题目： <a href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" rel="noopener">有效的括号</a> Easy</h1><h2 id="1-自己构思"><a href="#1-自己构思" class="headerlink" title="1.自己构思"></a>1.自己构思</h2><ol>
<li>漏判<strong>遍历结束</strong>后，栈中是否有左括号</li>
<li>快速判断采用<strong>哈希映射</strong>（HashMap）存储每一种括号</li>
<li>优化流程，注意到有效字符串的长度<strong>一定为偶</strong>数，因此如果字符串的长度为奇数，我们可以直接返回 \text{False}False，省去后续的遍历判断过程。</li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;Character&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'['</span>) stack.push(<span class="string">']'</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'('</span>) stack.push(<span class="string">')'</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'&#123;'</span>) stack.push(<span class="string">'&#125;'</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (stack.isEmpty() || c != stack.pop()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="解决方案一"><a href="#解决方案一" class="headerlink" title="解决方案一"></a>解决方案一</h3><h4 id="解题逻辑：栈匹配"><a href="#解题逻辑：栈匹配" class="headerlink" title="解题逻辑：栈匹配"></a><strong>解题逻辑</strong>：栈匹配</h4><h4 id="前置知识：HashMap用法；Map-Entry详解"><a href="#前置知识：HashMap用法；Map-Entry详解" class="headerlink" title="前置知识：HashMap用法；Map.Entry详解"></a>前置知识：<a href="https://blog.csdn.net/wdays83892469/article/details/79615609" target="_blank" rel="noopener"><em>HashMap用法</em></a>；<a href="https://blog.csdn.net/yaomingyang/article/details/78748130" target="_blank" rel="noopener">Map.Entry详解</a></h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line">HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">//创建HashMap</span></span><br><span class="line">map.put(<span class="string">"zhang"</span>, <span class="string">"31"</span>);<span class="comment">//存放键值对</span></span><br><span class="line">map.containsKey(<span class="string">"zhang"</span>));<span class="comment">//键中是否包含这个数据</span></span><br><span class="line">map.get(<span class="string">"zhang"</span>));<span class="comment">//通过键拿值</span></span><br><span class="line">map.isEmpty());<span class="comment">//判空</span></span><br><span class="line">map.remove(<span class="string">"zhang"</span>));<span class="comment">//从键值中删除</span></span><br><span class="line">map.clear();<span class="comment">//清楚表</span></span><br></pre></td></tr></table></figure></div>

<h4 id="对Java中使用两个大括号进行初始化的理解"><a href="#对Java中使用两个大括号进行初始化的理解" class="headerlink" title="对Java中使用两个大括号进行初始化的理解"></a><a href="https://www.cnblogs.com/matd/p/10978167.html" target="_blank" rel="noopener">对Java中使用两个大括号进行初始化的理解</a></h4><p><strong>使用匿名内部类 + 实例化代码块儿 = 使用两个大括号进行初始化</strong></p>
<h4 id="代码分析："><a href="#代码分析：" class="headerlink" title="代码分析："></a>代码分析：</h4><h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="comment">//奇数直接返回，简化判断</span></span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        Map&lt;Character, Character&gt; pairs = <span class="keyword">new</span> HashMap&lt;Character, Character&gt;() &#123;&#123;</span><br><span class="line">            put(<span class="string">')'</span>, <span class="string">'('</span>);</span><br><span class="line">            put(<span class="string">']'</span>, <span class="string">'['</span>);</span><br><span class="line">            put(<span class="string">'&#125;'</span>, <span class="string">'&#123;'</span>);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;Character&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> ch = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (pairs.containsKey(ch))&#123;     <span class="comment">//遇到闭符号查找栈顶是否有匹配的开符号</span></span><br><span class="line">                <span class="keyword">if</span> (stack.isEmpty() || stack.peek() != pairs.get(ch)) </span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125; <span class="keyword">else</span> stack.push(ch);			<span class="comment">//将开符号压入栈中</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty(); 	<span class="comment">//排除多余开符号情况</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="无map版："><a href="#无map版：" class="headerlink" title="无map版："></a>无map版：</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.isEmpty())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        Stack&lt;Character&gt; stack=<span class="keyword">new</span> Stack&lt;Character&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c:s.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span>(c==<span class="string">'('</span>)</span><br><span class="line">                stack.push(<span class="string">')'</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">'&#123;'</span>)</span><br><span class="line">                stack.push(<span class="string">'&#125;'</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">'['</span>)</span><br><span class="line">                stack.push(<span class="string">']'</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(stack.empty()||c!=stack.pop())</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(stack.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="tips"><a href="#tips" class="headerlink" title="tips:"></a>tips:</h4><ul>
<li></li>
</ul>
<blockquote>
<p>文件名：LEQS7</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCodeExplore</tag>
        <tag>LeetcodeExploreQ&amp;S</tag>
      </tags>
  </entry>
  <entry>
    <title>钥匙和房间</title>
    <url>/2020/09/06/LEQS16/</url>
    <content><![CDATA[<h1 id="题目：-钥匙和房间-Medium"><a href="#题目：-钥匙和房间-Medium" class="headerlink" title="题目： 钥匙和房间   Medium"></a>题目： <a href="https://leetcode-cn.com/problems/keys-and-rooms/" target="_blank" rel="noopener">钥匙和房间</a>   Medium</h1><h3 id="解决方案一-DFS"><a href="#解决方案一-DFS" class="headerlink" title="解决方案一 : DFS"></a>解决方案一 : DFS</h3><h4 id="解题逻辑：DFS"><a href="#解题逻辑：DFS" class="headerlink" title="解题逻辑：DFS"></a><strong>解题逻辑</strong>：DFS</h4><ul>
<li>用num来记录所有能打开的房间，遍历完成后与总数比较得结果</li>
<li>用boolean[] visit 来避免重复访问结点</li>
</ul>
<h4 id="代码分析："><a href="#代码分析：" class="headerlink" title="代码分析："></a>代码分析：</h4><h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span>[] vis;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canVisitAllRooms</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; rooms)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = rooms.size();</span><br><span class="line">        num = <span class="number">0</span>;</span><br><span class="line">        vis = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">        dfs(rooms, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> num == n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; rooms, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        vis[x] = <span class="keyword">true</span>;</span><br><span class="line">        num++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> it : rooms.get(x)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[it]) &#123;</span><br><span class="line">                dfs(rooms, it);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="解决方案二：BFS"><a href="#解决方案二：BFS" class="headerlink" title="解决方案二：BFS"></a>解决方案二：BFS</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canVisitAllRooms</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; rooms)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = rooms.size(), num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[] vis = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">        Queue&lt;Integer&gt; que = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        vis[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        que.offer(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = que.poll();</span><br><span class="line">            num++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> it : rooms.get(x)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!vis[it]) &#123;</span><br><span class="line">                    vis[it] = <span class="keyword">true</span>;</span><br><span class="line">                    que.offer(it);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num == n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="Tips"><a href="#Tips" class="headerlink" title="Tips:"></a>Tips:</h4><ul>
<li>去重可用hashset</li>
</ul>
<h3 id="解决方案三"><a href="#解决方案三" class="headerlink" title="解决方案三"></a>解决方案三</h3><blockquote>
<p>文件名：LEQS16</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCodeExplore</tag>
        <tag>LeetcodeExploreQ&amp;S</tag>
      </tags>
  </entry>
  <entry>
    <title>图像渲染</title>
    <url>/2020/09/05/LEQS14/</url>
    <content><![CDATA[<h1 id="题目：-图像渲染-Easy"><a href="#题目：-图像渲染-Easy" class="headerlink" title="题目：  图像渲染   Easy"></a>题目： <a href="https://leetcode-cn.com/problems/flood-fill/" target="_blank" rel="noopener"> 图像渲染</a>   Easy</h1><h2 id="1-自己构思：递归栈"><a href="#1-自己构思：递归栈" class="headerlink" title="1.自己构思：递归栈"></a>1.自己构思：递归栈</h2><h3 id="出现问题："><a href="#出现问题：" class="headerlink" title="出现问题："></a>出现问题：</h3><ol>
<li>未考虑oldColor == newColor情况</li>
</ol>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> oldColor;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] floodFill(<span class="keyword">int</span>[][] image, <span class="keyword">int</span> sr, <span class="keyword">int</span> sc, <span class="keyword">int</span> newColor) &#123;</span><br><span class="line">        oldColor = image[sr][sc];</span><br><span class="line">       <span class="comment">// if(oldColor == newColor) return image;</span></span><br><span class="line">       <span class="comment">// dfs(image,sr,sc,newColor);</span></span><br><span class="line">        <span class="keyword">if</span> (currColor != newColor) &#123;</span><br><span class="line">            dfs(image, sr, sc, currColor, newColor);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> image;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] image, <span class="keyword">int</span> sr, <span class="keyword">int</span> sc, <span class="keyword">int</span> newColor)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sr&lt;<span class="number">0</span>||sc&lt;<span class="number">0</span>||sr&gt;=image.length||sc&gt;=image[<span class="number">0</span>].length||image[sr][sc] != oldColor) <span class="keyword">return</span>;</span><br><span class="line">        image[sr][sc] = newColor;</span><br><span class="line">        dfs(image,sr+<span class="number">1</span>,sc,newColor);</span><br><span class="line">        dfs(image,sr,sc+<span class="number">1</span>,newColor);</span><br><span class="line">        dfs(image,sr-<span class="number">1</span>,sc,newColor);</span><br><span class="line">        dfs(image,sr,sc-<span class="number">1</span>,newColor);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h2 id="2-学习题解代码"><a href="#2-学习题解代码" class="headerlink" title="2.学习题解代码"></a>2.学习题解代码</h2><h3 id="解决方案一：广度优先搜索"><a href="#解决方案一：广度优先搜索" class="headerlink" title="解决方案一：广度优先搜索"></a>解决方案一：广度优先搜索</h3><h4 id="代码分析："><a href="#代码分析：" class="headerlink" title="代码分析："></a>代码分析：</h4><h4 id="优化自己代码"><a href="#优化自己代码" class="headerlink" title="优化自己代码"></a>优化自己代码</h4><h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>



<h4 id="tips"><a href="#tips" class="headerlink" title="tips:"></a>tips:</h4><ul>
<li><h3 id="解决方案二"><a href="#解决方案二" class="headerlink" title="解决方案二"></a>解决方案二</h3></li>
</ul>
<h3 id="解决方案三"><a href="#解决方案三" class="headerlink" title="解决方案三"></a>解决方案三</h3><blockquote>
<p>文件名：LEQS14</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCodeExplore</tag>
        <tag>LeetcodeExploreQ&amp;S</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串解码</title>
    <url>/2020/09/05/LEQS13/</url>
    <content><![CDATA[<h1 id="题目：-字符串解码-Medium"><a href="#题目：-字符串解码-Medium" class="headerlink" title="题目： 字符串解码   Medium"></a>题目： <a href="https://leetcode-cn.com/problems/decode-string/" target="_blank" rel="noopener">字符串解码</a>   Medium</h1><h2 id="1-自己构思：栈"><a href="#1-自己构思：栈" class="headerlink" title="1.自己构思：栈"></a>1.自己构思：栈</h2><h3 id="出现问题："><a href="#出现问题：" class="headerlink" title="出现问题："></a>出现问题：</h3><ol>
<li>出栈后克隆数个单字符以及最后组合成结果字符串的方式方法不清楚</li>
<li>遇到右括号出栈时字符串颠倒错误</li>
<li>最后出栈时，从栈底到栈头遍历出栈，LinkedList好处出来了</li>
</ol>
<h3 id="问题解决："><a href="#问题解决：" class="headerlink" title="问题解决："></a>问题解决：</h3><ol>
<li><p>出栈时遇到左括号后， 弹出，根据此时栈顶数字将出栈字符反序拼接并复制，最后再压入栈中。</p>
<p>反序时采用 <code>Collections.reverse()</code>颠倒，因为只是将括号内的各个字符串由出栈存入的逆序变为正序，然后结合再入栈</p>
<p>例如：[“abc” ,”def”]，出栈存入list【“def”,”abc”】,反转【“abc” ,”def”】，然后拼接压栈即可。</p>
<p>采用<code>StringBuffer reverse()</code>函数会将整个括号内的每个字符全部反转，<code>&quot;abc&quot;+&quot;def&quot;</code> 变为 <code>“fedcba”</code>不符合题意。</p>
</li>
<li><p>重复如上操作，最终将栈中的元素按照从栈底到栈顶的顺序拼接起来。</p>
</li>
<li><table>
<thead>
<tr>
<th align="center">API Character</th>
<th align="center">API LinkedList</th>
<th align="center">API StringBuffer</th>
<th>API String</th>
<th>API Integer</th>
</tr>
</thead>
<tbody><tr>
<td align="center">.isDigit()</td>
<td align="center">.addLast(digits)</td>
<td align="center">.append(s)</td>
<td>.charAt(ptr);</td>
<td>parseInt(c);</td>
</tr>
<tr>
<td align="center">.isLetter()</td>
<td align="center">.removeLast()</td>
<td align="center">.toString()</td>
<td>.valueOf(n);</td>
<td></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">.peekLast()</td>
<td align="center"></td>
<td></td>
<td></td>
</tr>
</tbody></table>
</li>
</ol>
<h2 id="2-学习题解代码"><a href="#2-学习题解代码" class="headerlink" title="2.学习题解代码"></a>2.学习题解代码</h2><h3 id="解决方案一：栈结构"><a href="#解决方案一：栈结构" class="headerlink" title="解决方案一：栈结构"></a>解决方案一：栈结构</h3><h4 id="解题逻辑："><a href="#解题逻辑：" class="headerlink" title="解题逻辑："></a><strong>解题逻辑</strong>：</h4><ul>
<li><img src="/images/LEQS13/image-20200904094102267.png" alt="image-20200904094102267" style="zoom: 80%;" />

</li>
</ul>
<h4 id="代码分析："><a href="#代码分析：" class="headerlink" title="代码分析："></a>代码分析：</h4><h4 id="重点："><a href="#重点：" class="headerlink" title="重点："></a>重点：</h4><ul>
<li><code>while (repTime-- &gt; 0)</code> 遍历reptime次</li>
<li><code>String.valueOf()</code>将变量或者char[]转换成字符串</li>
</ul>
<h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">   <span class="keyword">int</span> prt; <span class="comment">//定义遍历字符串指针</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> prt; <span class="comment">//定义遍历字符串指针</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDigit</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        StringBuffer num = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">while</span>(Character.isDigit(s.charAt(prt)))</span><br><span class="line">            num.append(s.charAt(prt++));</span><br><span class="line">        <span class="keyword">return</span> num.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getString</span><span class="params">(Deque&lt;String&gt; stack)</span></span>&#123;</span><br><span class="line">        StringBuffer ds = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="comment">//从栈底到栈头遍历</span></span><br><span class="line">        <span class="keyword">while</span>(stack.peekLast()!=<span class="keyword">null</span>)</span><br><span class="line">            ds.append(stack.removeLast());</span><br><span class="line"><span class="comment">//        ds.reverse();</span></span><br><span class="line">        <span class="keyword">return</span> ds.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">decodeString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Deque&lt;String&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        prt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(prt &lt; s.length())&#123;</span><br><span class="line">            <span class="keyword">if</span>(Character.isDigit(s.charAt(prt)))&#123;</span><br><span class="line">                stack.push(getDigit(s));</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(prt) == <span class="string">']'</span> )&#123;</span><br><span class="line">                ++prt;</span><br><span class="line"><span class="comment">//                StringBuffer sub = new StringBuffer();</span></span><br><span class="line"><span class="comment">//                while(!"[".equals(stack.peekFirst()))&#123;</span></span><br><span class="line"><span class="comment">//                    sub.append(stack.pop());</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//                sub.reverse();</span></span><br><span class="line"><span class="comment">//                stack.pop();</span></span><br><span class="line"><span class="comment">//                int times = Integer.parseInt(stack.pop());</span></span><br><span class="line"><span class="comment">//                while(times-- &gt; 0)</span></span><br><span class="line"><span class="comment">//                    stack.push(sub.toString());</span></span><br><span class="line"></span><br><span class="line">                LinkedList&lt;String&gt; sub = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">                <span class="keyword">while</span>(!<span class="string">"["</span>.equals(stack.peekFirst()))&#123;</span><br><span class="line">                    sub.addFirst(stack.pop());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                Collections.reverse(sub);</span><br><span class="line">                stack.pop();</span><br><span class="line">                <span class="keyword">int</span> times = Integer.parseInt(stack.pop());</span><br><span class="line">                StringBuffer t = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">                String o = getString(sub);</span><br><span class="line">                <span class="keyword">while</span>(times-- &gt; <span class="number">0</span>)</span><br><span class="line">                    t.append(o);</span><br><span class="line">                stack.push(t.toString());</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                stack.push(String.valueOf(s.charAt(prt++)));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getString(stack);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="tips"><a href="#tips" class="headerlink" title="tips:"></a>tips:</h4><ul>
<li><h3 id="解决方案二：递归栈"><a href="#解决方案二：递归栈" class="headerlink" title="解决方案二：递归栈"></a>解决方案二：递归栈</h3></li>
</ul>
<h3 id="解决方案三"><a href="#解决方案三" class="headerlink" title="解决方案三"></a>解决方案三</h3><blockquote>
<p>文件名：LEQS13</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCodeExplore</tag>
        <tag>LeetcodeExploreQ&amp;S</tag>
      </tags>
  </entry>
  <entry>
    <title>克隆图</title>
    <url>/2020/08/31/LEQS10/</url>
    <content><![CDATA[<h1 id="题目：-克隆图-Medium"><a href="#题目：-克隆图-Medium" class="headerlink" title="题目： 克隆图 Medium"></a>题目： <a href="https://leetcode-cn.com/problems/clone-graph/" target="_blank" rel="noopener">克隆图</a> Medium</h1><h3 id="解决方案一-DFS"><a href="#解决方案一-DFS" class="headerlink" title="解决方案一:DFS"></a>解决方案一:DFS</h3><h4 id="解题逻辑："><a href="#解题逻辑：" class="headerlink" title="解题逻辑："></a><strong>解题逻辑</strong>：</h4><ul>
<li><a href="https://blog.csdn.net/wdays83892469/article/details/79615609" target="_blank" rel="noopener">HashMap</a>记录已访问节点避免递归过程中死循环</li>
<li><img src="/images/LEQS10/3.png" alt="fig3"></li>
</ul>
<h4 id="代码分析："><a href="#代码分析：" class="headerlink" title="代码分析："></a>代码分析：</h4><h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HashMap &lt;Node, Node&gt; visited = <span class="keyword">new</span> HashMap &lt;&gt; ();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">cloneGraph</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果该节点已经被访问过了，则直接从哈希表中取出对应的克隆节点返回</span></span><br><span class="line">        <span class="keyword">if</span> (visited.containsKey(node)) &#123;</span><br><span class="line">            <span class="keyword">return</span> visited.get(node);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 克隆节点，注意到为了深拷贝我们不会克隆它的邻居的列表</span></span><br><span class="line">        Node cloneNode = <span class="keyword">new</span> Node(node.val, <span class="keyword">new</span> ArrayList());</span><br><span class="line">        <span class="comment">// 哈希表存储</span></span><br><span class="line">        visited.put(node, cloneNode);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历该节点的邻居并更新克隆节点的邻居列表</span></span><br><span class="line">        <span class="keyword">for</span> (Node neighbor: node.neighbors) &#123;</span><br><span class="line">            cloneNode.neighbors.add(cloneGraph(neighbor));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cloneNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="tips"><a href="#tips" class="headerlink" title="tips:"></a>tips:</h4><ul>
<li><h2 id="解决方案二：BFS"><a href="#解决方案二：BFS" class="headerlink" title="解决方案二：BFS"></a>解决方案二：BFS</h2></li>
</ul>
<img src="/images/LEQS10/4.png" alt="fig4" style="zoom: 33%;" />

<h4 id="要点："><a href="#要点：" class="headerlink" title="要点："></a>要点：</h4><ul>
<li>将hasmap中的键对应原本的节点图，并且进行克隆，克隆得到的结点存储在对应的值当中。</li>
<li>如此，既能在创建键的过程中实现判断结点是否遍历，又能对结点进行对应克隆。</li>
<li>最后返回题目提供的结点在hashmap表中对应的值结点即可。</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">cloneGraph</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Node, Node&gt; visited = <span class="keyword">new</span> HashMap();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将题目给定的节点添加到队列</span></span><br><span class="line">        LinkedList&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;Node&gt; ();</span><br><span class="line">        queue.add(node);</span><br><span class="line">        <span class="comment">// 克隆第一个节点并存储到哈希表中</span></span><br><span class="line">        visited.put(node, <span class="keyword">new</span> Node(node.val, <span class="keyword">new</span> ArrayList()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 广度优先搜索</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 取出队列的头节点</span></span><br><span class="line">            Node n = queue.remove();</span><br><span class="line">            <span class="comment">// 遍历该节点的邻居</span></span><br><span class="line">            <span class="keyword">for</span> (Node neighbor: n.neighbors) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited.containsKey(neighbor)) &#123;</span><br><span class="line">                    <span class="comment">// 如果没有被访问过，就克隆并存储在哈希表中</span></span><br><span class="line">                    visited.put(neighbor, <span class="keyword">new</span> Node(neighbor.val, <span class="keyword">new</span> ArrayList()));</span><br><span class="line">                    <span class="comment">// 将邻居节点加入队列中</span></span><br><span class="line">                    queue.add(neighbor);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 更新克隆节点的邻居列表</span></span><br><span class="line">                visited.get(n).neighbors.add(visited.get(neighbor));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">		<span class="comment">//返回的即是对应的值克隆节点</span></span><br><span class="line">        <span class="keyword">return</span> visited.get(node); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<blockquote>
<p>文件名：LEQS10</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCodeExplore</tag>
        <tag>LeetcodeExploreQ&amp;S</tag>
      </tags>
  </entry>
  <entry>
    <title>完全平方数</title>
    <url>/2020/08/11/LEQS4/</url>
    <content><![CDATA[<h1 id="题目：完全平方数-Medium"><a href="#题目：完全平方数-Medium" class="headerlink" title="题目：完全平方数   Medium"></a>题目：<a href="https://leetcode-cn.com/problems/perfect-squares/" target="_blank" rel="noopener">完全平方数</a>   Medium</h1><h3 id="解决方案一：BFS-队列"><a href="#解决方案一：BFS-队列" class="headerlink" title="解决方案一：BFS+队列"></a>解决方案一：BFS+队列</h3><h4 id="解题逻辑："><a href="#解题逻辑：" class="headerlink" title="解题逻辑："></a><strong>解题逻辑</strong>：</h4><ul>
<li><p>当每一次都可以判断出多种情况，有多次的时候就适合用BFS-广度优先遍历</p>
<p>队列：用来存储每一轮遍历得到的节点；<br>标记：对于遍历过的节点，应该将它标记，防止重复遍历。</p>
</li>
<li><p>为了节省遍历的时间，曾经（ n - 以前出现的平方数） 这个值出现过，则在此出现这样的数时直接忽略。</p>
</li>
<li><img src="/images/LEQS4/e7f3e392ad7b1068c8f0e05bad898b100ef20741112ea93b2f8a9fab9a75f95a-leetcode279.png" alt="leetcode279.png" style="zoom:50%;" />

</li>
</ul>
<h4 id="代码分析："><a href="#代码分析：" class="headerlink" title="代码分析："></a>代码分析：</h4><ul>
<li>每减一次代表组成的平方数找到一种情况</li>
</ul>
<h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//构造结点，包含代表当前找寻到的情况步数step和结点的平方数值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        <span class="keyword">int</span> step;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> val,<span class="keyword">int</span> step)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">            <span class="keyword">this</span>.step = step;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        Queue&lt;Node&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        q.add(<span class="keyword">new</span> Node(n, <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">boolean</span>[] record =<span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//出队列数值信息</span></span><br><span class="line">            <span class="keyword">int</span> val = q.peek().val;</span><br><span class="line">            <span class="keyword">int</span> step = q.peek().step;</span><br><span class="line">            q.remove();</span><br><span class="line">            <span class="comment">//进行当前层数的广度遍历</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;;i++)&#123;</span><br><span class="line">                <span class="comment">//试探下一层数值情况方便进行结束条件判断</span></span><br><span class="line">				<span class="keyword">int</span> nextVal = val - i*i;</span><br><span class="line">                <span class="comment">//结束条件1：达到最大平方数</span></span><br><span class="line">                <span class="keyword">if</span>(nextVal &lt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//结束条件2：找到最短路径,返回所需值</span></span><br><span class="line">                <span class="keyword">if</span>(nextVal == <span class="number">0</span> ) <span class="keyword">return</span> step;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//避免相同结点重复入队列，重复值的路径一定大于第一次结点出现时的路径</span></span><br><span class="line">                <span class="comment">//并且将下个结点进入队列.</span></span><br><span class="line">                <span class="keyword">if</span>(!record[nextVal])&#123;</span><br><span class="line">                    q.add(<span class="keyword">new</span> Node(nextVal,step + <span class="number">1</span>));</span><br><span class="line">                    record[nextVal] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="tips"><a href="#tips" class="headerlink" title="tips:"></a>tips:</h4><ul>
<li></li>
</ul>
<blockquote>
<p>文件名：LEQS4</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCodeExplore</tag>
        <tag>LeetcodeExploreQ&amp;S</tag>
      </tags>
  </entry>
  <entry>
    <title>目标和</title>
    <url>/2020/09/02/LEQS11/</url>
    <content><![CDATA[<h1 id="题目：-目标和-Medium"><a href="#题目：-目标和-Medium" class="headerlink" title="题目： 目标和   Medium"></a>题目： <a href="https://leetcode-cn.com/problems/target-sum/" target="_blank" rel="noopener">目标和</a>   Medium</h1><h2 id="1-自己构思：递归系统栈"><a href="#1-自己构思：递归系统栈" class="headerlink" title="1.自己构思：递归系统栈"></a>1.自己构思：递归系统栈</h2><h3 id="出现问题："><a href="#出现问题：" class="headerlink" title="出现问题："></a>出现问题：</h3><ol>
<li>目标和sum值不能为实例变量，应该在递归参数中随着各个分支处理而不同<strong>变化</strong>，否则递归过程中的<strong>其他分支</strong>sum值都会<strong>受到影响</strong></li>
<li>在进行递归时传入的目标sum必须有变化，否则为同一种情况，产生重复递归情况</li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">        dfs(nums , <span class="number">0</span> , <span class="number">1</span> , S, <span class="number">0</span>); <span class="comment">//sum不变等于同一种情况，变化的f并未改变sum的值，到下下一轮才影响</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums , <span class="keyword">int</span> i ,<span class="keyword">int</span> f , <span class="keyword">int</span> s, <span class="keyword">int</span> nums_sum)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(i == nums.length )&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums_sum == s) res++;  </span><br><span class="line">            <span class="comment">//nums_sum = 0;  </span></span><br><span class="line">            <span class="comment">// 不能将sum值置为0，如此则递归过程中的其他分支sum值都为0；并且sum值不能为应该在递归参数中随着各个分支              的处理而不同变化</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// nums_sum += nums[i] * f;</span></span><br><span class="line">        <span class="comment">//传入sum值没有变化即等于同一种情况</span></span><br><span class="line">        dfs(nums , i+<span class="number">1</span> , <span class="number">1</span> , s, nums_sum +  nums[i]);</span><br><span class="line">        dfs(nums , i+<span class="number">1</span> , -<span class="number">1</span> ,s, nums_sum -  nums[i] );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="2-学习题解代码"><a href="#2-学习题解代码" class="headerlink" title="2.学习题解代码"></a>2.学习题解代码</h2><h3 id="解决方案一-递归栈"><a href="#解决方案一-递归栈" class="headerlink" title="解决方案一:递归栈"></a>解决方案一:递归栈</h3><h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">        calculate(nums, <span class="number">0</span>, <span class="number">0</span>, S);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> sum, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == nums.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum == S)</span><br><span class="line">                count++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//直接传入计算好的不同sum值进行递归</span></span><br><span class="line">            calculate(nums, i + <span class="number">1</span>, sum + nums[i], S);</span><br><span class="line">            calculate(nums, i + <span class="number">1</span>, sum - nums[i], S);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="tips"><a href="#tips" class="headerlink" title="tips:"></a>tips:</h4><ul>
<li><a href="https://blog.csdn.net/chenkaibsw/article/details/78989459" target="_blank" rel="noopener">控制台打印数组的方法</a>，Arrays.toString();</li>
<li>IDEA中在调用函数方法时，要求是static静态的，或者创建该类的实例对象进行调用</li>
</ul>
<h3 id="解决方案二：动态规划"><a href="#解决方案二：动态规划" class="headerlink" title="解决方案二：动态规划"></a>解决方案二：动态规划</h3><h3 id="解决方案三：动态规划-空间优化"><a href="#解决方案三：动态规划-空间优化" class="headerlink" title="解决方案三：动态规划 + 空间优化"></a><strong>解决方案</strong>三：动态规划 + 空间优化</h3><blockquote>
<p>文件名：LEQS11</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCodeExplore</tag>
        <tag>LeetcodeExploreQ&amp;S</tag>
      </tags>
  </entry>
  <entry>
    <title>岛屿数量</title>
    <url>/2020/08/23/LEQS5/</url>
    <content><![CDATA[<h1 id="题目：-岛屿数量-Medium"><a href="#题目：-岛屿数量-Medium" class="headerlink" title="题目： 岛屿数量 Medium"></a>题目： <a href="https://leetcode-cn.com/problems/number-of-islands/" target="_blank" rel="noopener">岛屿数量</a> Medium</h1><h3 id="解决方案一：BFS"><a href="#解决方案一：BFS" class="headerlink" title="解决方案一：BFS"></a>解决方案一：BFS</h3><h4 id="解题逻辑：BFS广度优先搜索"><a href="#解题逻辑：BFS广度优先搜索" class="headerlink" title="解题逻辑：BFS广度优先搜索"></a><strong>解题逻辑</strong>：BFS广度优先搜索</h4><p>为了求出岛屿的数量，我们可以扫描整个二维网格。如果一个位置为 1，则将其加入队列，开始进行广度优先搜索。在广度优先搜索的过程中，每个搜索到的 1都会被重新标记为 0。直到队列为空，搜索结束。</p>
<p>最终岛屿的数量就是我们进行广度优先搜索的次数。</p>
<h4 id="代码分析："><a href="#代码分析：" class="headerlink" title="代码分析："></a>代码分析：</h4><h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> nr = grid.length;</span><br><span class="line">        <span class="keyword">int</span> nc = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> num_islands = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; nr; ++r) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; nc; ++c) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (grid[r][c] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                    ++num_islands;</span><br><span class="line">                    grid[r][c] = <span class="string">'0'</span>;<span class="comment">//将搜索到的1重新标记为 0,防止重复计算</span></span><br><span class="line">                    </span><br><span class="line">                    Queue&lt;Integer&gt; neighbors = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">                    neighbors.add(r * nc + c);</span><br><span class="line">                    <span class="keyword">while</span> (!neighbors.isEmpty()) &#123;</span><br><span class="line">                        </span><br><span class="line">                        <span class="keyword">int</span> id = neighbors.remove();</span><br><span class="line">                        <span class="keyword">int</span> row = id / nc;</span><br><span class="line">                        <span class="keyword">int</span> col = id % nc;</span><br><span class="line">                        <span class="comment">//上下左右遍历邻居加入队列</span></span><br><span class="line">                        <span class="keyword">if</span> (row - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[row-<span class="number">1</span>][col] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                            neighbors.add((row-<span class="number">1</span>) * nc + col);</span><br><span class="line">                            grid[row-<span class="number">1</span>][col] = <span class="string">'0'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (row + <span class="number">1</span> &lt; nr &amp;&amp; grid[row+<span class="number">1</span>][col] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                            neighbors.add((row+<span class="number">1</span>) * nc + col);</span><br><span class="line">                            grid[row+<span class="number">1</span>][col] = <span class="string">'0'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (col - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[row][col-<span class="number">1</span>] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                            neighbors.add(row * nc + col-<span class="number">1</span>);</span><br><span class="line">                            grid[row][col-<span class="number">1</span>] = <span class="string">'0'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (col + <span class="number">1</span> &lt; nc &amp;&amp; grid[row][col+<span class="number">1</span>] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                            neighbors.add(row * nc + col+<span class="number">1</span>);</span><br><span class="line">                            grid[row][col+<span class="number">1</span>] = <span class="string">'0'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> num_islands;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="解决方案二：DFS"><a href="#解决方案二：DFS" class="headerlink" title="解决方案二：DFS"></a>解决方案二：DFS</h3><img src="/images/LEQS5/image-20200830173102730.png" alt="image-20200830173102730" style="zoom: 80%;" />

<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                    dfs(grid, i, j);</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="comment">//递归结束条件</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= grid.length || j &gt;= grid[<span class="number">0</span>].length || grid[i][j] == <span class="string">'0'</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//循环执行</span></span><br><span class="line">        grid[i][j] = <span class="string">'0'</span>;</span><br><span class="line">        dfs(grid, i + <span class="number">1</span>, j);</span><br><span class="line">        dfs(grid, i, j + <span class="number">1</span>);</span><br><span class="line">        dfs(grid, i - <span class="number">1</span>, j);</span><br><span class="line">        dfs(grid, i, j - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="tips"><a href="#tips" class="headerlink" title="tips:"></a>tips:</h4><ul>
<li>if按照（）内条件顺序进行判断，将可能导致数组越界的条件放到最后避免报错</li>
</ul>
<h3 id="解决方案三：并查集"><a href="#解决方案三：并查集" class="headerlink" title="解决方案三：并查集"></a>解决方案三：并查集</h3><blockquote>
<p>文件名：LEQS5</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCodeExplore</tag>
        <tag>LeetcodeExploreQ&amp;S</tag>
      </tags>
  </entry>
  <entry>
    <title>每日温度</title>
    <url>/2020/08/30/LEQS8/</url>
    <content><![CDATA[<h1 id="题目：-每日温度-Medium"><a href="#题目：-每日温度-Medium" class="headerlink" title="题目：  每日温度   Medium"></a>题目： <a href="https://leetcode-cn.com/problems/daily-temperatures/" target="_blank" rel="noopener"> 每日温度</a>   Medium</h1><h2 id="1-自己构思"><a href="#1-自己构思" class="headerlink" title="1.自己构思"></a>1.自己构思</h2><h3 id="出现问题："><a href="#出现问题：" class="headerlink" title="出现问题："></a>出现问题：</h3><ol>
<li>出栈入栈条件代码编写共同逻辑混乱</li>
</ol>
<h3 id="问题解决："><a href="#问题解决：" class="headerlink" title="问题解决："></a>问题解决：</h3><ol>
<li>栈外元素比较无论如何都需进栈</li>
<li>不推荐使用stack，用deque实现栈结构【线程安全，同步操作会降低性能】</li>
<li>涉及长度length可创建临时变量</li>
</ol>
<h2 id="2-学习题解代码"><a href="#2-学习题解代码" class="headerlink" title="2.学习题解代码"></a>2.学习题解代码</h2><h3 id="解决方案一：单调栈"><a href="#解决方案一：单调栈" class="headerlink" title="解决方案一：单调栈"></a>解决方案一：单调栈</h3><h4 id="解题逻辑："><a href="#解题逻辑：" class="headerlink" title="解题逻辑："></a><strong>解题逻辑</strong>：</h4><ul>
<li><p>维护一个存储下标的单调栈，从栈底到栈顶的下标对应的温度列表中的温度依次递减。如果一个下标在单调栈里，则表示尚未找到下一次温度更高的下标。</p>
</li>
<li><p>向遍历温度列表。对于温度列表中的每个元素 T[i]，如果栈为空，则直接将 i 进栈，如果栈不为空，则比较栈顶元素 prevIndex 对应的温度 T[prevIndex] 和当前温度 T[i]，如果 T[i] &gt; T[prevIndex]，则将 prevIndex 移除，并将 prevIndex 对应的等待天数赋为 i - prevIndex，重复上述操作直到栈为空或者栈顶元素对应的温度小于等于当前温度，然后将 i 进栈。</p>
</li>
</ul>
<h4 id="代码分析："><a href="#代码分析：" class="headerlink" title="代码分析："></a>代码分析：</h4><h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] T) &#123;</span><br><span class="line">        <span class="keyword">int</span> length = T.length;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temperature = T[i];</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; temperature &gt; T[stack.peek()]) &#123;</span><br><span class="line">                <span class="keyword">int</span> prevIndex = stack.pop();</span><br><span class="line">                ans[prevIndex] = i - prevIndex;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h4 id="tips"><a href="#tips" class="headerlink" title="tips:"></a>tips:</h4><ul>
<li></li>
</ul>
<blockquote>
<p>文件名：LEQS8</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCodeExplore</tag>
        <tag>LeetcodeExploreQ&amp;S</tag>
      </tags>
  </entry>
  <entry>
    <title>转盘问题之BFS解题框架</title>
    <url>/2020/08/23/LEQS3/</url>
    <content><![CDATA[<h1 id="题目：-转盘问题之BFS解题框架"><a href="#题目：-转盘问题之BFS解题框架" class="headerlink" title="题目： 转盘问题之BFS解题框架"></a>题目： 转盘问题之BFS解题框架</h1><h2 id="BFS解题框架"><a href="#BFS解题框架" class="headerlink" title="BFS解题框架"></a>BFS解题框架</h2><ul>
<li>BFS本质<strong>就是在一幅「图」中找到从起点 <code>start</code> 到终点 <code>target</code> 的最近距离</strong></li>
<li>与DFS区别是空间复杂度高</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算从起点 start 到终点 target 的最近距离</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BFS</span><span class="params">(Node start, Node target)</span> </span>&#123;</span><br><span class="line">    Queue&lt;Node&gt; q; <span class="comment">// 核心数据结构</span></span><br><span class="line">    Set&lt;Node&gt; visited; <span class="comment">// 避免走回头路</span></span><br><span class="line">    </span><br><span class="line">    q.offer(start); <span class="comment">// 将起点加入队列</span></span><br><span class="line">    visited.add(start);</span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>; <span class="comment">// 记录扩散的步数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q not empty) &#123;</span><br><span class="line">        <span class="keyword">int</span> sz = q.size();</span><br><span class="line">        <span class="comment">/* 将当前队列中的所有节点向四周扩散 */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            Node cur = q.poll();</span><br><span class="line">            <span class="comment">/* 划重点：这里判断是否到达终点 */</span></span><br><span class="line">            <span class="keyword">if</span> (cur is target)</span><br><span class="line">                <span class="keyword">return</span> step;</span><br><span class="line">            <span class="comment">/* 将 cur 的相邻节点加入队列 */</span></span><br><span class="line">            <span class="keyword">for</span> (Node x : cur.adj())</span><br><span class="line">                <span class="keyword">if</span> (x not in visited) &#123;</span><br><span class="line">                    q.offer(x);</span><br><span class="line">                    visited.add(x);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 划重点：更新步数在这里 */</span></span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol>
<li>队列是BFS 的核心的数据结构；</li>
<li>cur.adj() 泛指 cur 相邻的节点，比如说二维数组中，cur 上下左右四面的位置就是相邻节点；</li>
<li>visited 的主要作用是防止走回头路，大部分时候都是必须的，但是像一 般的二叉树结构，没有子节点到父节点的指针，不会走回头路就不需要 visited。</li>
</ol>
<h3 id="解决方案一：BFS框架穷举解题"><a href="#解决方案一：BFS框架穷举解题" class="headerlink" title="解决方案一：BFS框架穷举解题"></a>解决方案一：BFS框架穷举解题</h3><h4 id="解题逻辑：BFS框架解题"><a href="#解题逻辑：BFS框架解题" class="headerlink" title="解题逻辑：BFS框架解题"></a><strong>解题逻辑</strong>：BFS框架解题</h4><ul>
<li><p>计算出最少的转动次数</p>
<p><strong>第一步，不管所有的限制条件，不管 <code>deadends</code> 和 <code>target</code> 的限制，穷举所有可能的密码组合</strong></p>
<p>转一下锁总共8 种可能：</p>
<p>比如说从 “0000” 开始，转一次，可以穷举出 “1000”, “9000”, “0100”, “0900”… 共 8 种密码。然后，再以这 8 种密码作为基础，对每个密码再转一下，穷举出所有可能…</p>
<p>可以抽象成一幅图，每个节点有 8 个相邻的节点，求最短距离，典型的 BFS 。</p>
</li>
<li><p><strong>第二步</strong>加上限制条件、终止条件、避免走回头路:</p>
<ol>
<li>使用hashset记录死亡密码进行跳过</li>
<li>添加找到target 就结束且返回波动次数</li>
<li>使用hashset记录已经穷举的密码避免回头路</li>
</ol>
</li>
</ul>
<h4 id="代码分析："><a href="#代码分析：" class="headerlink" title="代码分析："></a>代码分析：</h4><h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//向上拨动轮盘</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">plusOne</span><span class="params">(String s , <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] ch = s.toCharArray();</span><br><span class="line">        <span class="keyword">if</span>(ch[j] == <span class="string">'9'</span> ) ch[j] = <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">else</span> ch[j]++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(ch);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//向下波动轮盘</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minusOne</span><span class="params">(String s ,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] ch = s.toCharArray();</span><br><span class="line">        <span class="keyword">if</span>(ch[j] == <span class="string">'0'</span>) ch[j] = <span class="string">'9'</span>;</span><br><span class="line">        <span class="keyword">else</span> ch[j]--;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(ch);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">openLock</span><span class="params">(String[] deadends, String target)</span></span>&#123;</span><br><span class="line">        <span class="comment">//记录要跳过的死亡密码</span></span><br><span class="line">        Set&lt;String&gt; deads = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String dead : deadends)</span><br><span class="line">            deads.add(dead);</span><br><span class="line">        <span class="comment">//记录已经穷举过的密码防止走回头路</span></span><br><span class="line">        Set&lt;String&gt; visited =  <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="comment">//建立队列，从起点开始进行广度优先搜索</span></span><br><span class="line">        Queue&lt;String&gt; q =<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">        q.offer(<span class="string">"0000"</span>);</span><br><span class="line">        visited.add(<span class="string">"0000"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> sz = q.size();</span><br><span class="line">            <span class="comment">/* 将当前队列中的所有节点向周围扩散 */</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;sz;i++)&#123;</span><br><span class="line">                String cur = q.poll();</span><br><span class="line">                </span><br><span class="line">                 <span class="comment">/* 判断是否到达终点 */</span>   </span><br><span class="line">                <span class="keyword">if</span>(deads.contains(cur)) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (cur.equals(target)) <span class="keyword">return</span> step;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">/* 将一个节点的未遍历相邻节点加入队列 */</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">4</span>; j++)&#123;</span><br><span class="line">                    String up = plusOne(cur,j);</span><br><span class="line">                    <span class="keyword">if</span>(!visited.contains(up))&#123;</span><br><span class="line">                        q.offer(up);</span><br><span class="line">                        visited.add(up);</span><br><span class="line">                     &#125;</span><br><span class="line">                    String down =  minusOne(cur,j);</span><br><span class="line">                    <span class="keyword">if</span>(!visited.contains(down))&#123;</span><br><span class="line">                        q.offer(down);</span><br><span class="line">                        visited.add(down);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">           </span><br><span class="line">            &#125;</span><br><span class="line">            step++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h4 id="tips"><a href="#tips" class="headerlink" title="tips:"></a>tips:</h4><ul>
<li><p>char 类型的运算</p>
<p>Java中的“向上兼容”，即：不同数据类型的数据参与运算，数据类型要强制转换，转换的方向是：char-&gt;short-&gt;int-&gt;long-&gt;float-&gt;double。</p>
<p>在<code>System.out.println(y+1);</code>这个语句中，y是char类型，1是int类型，所以把y强转成int，然后运算结果是99，输出也是int类型99。</p>
</li>
<li><p><a href="https://stackoverflow.com/questions/21317631/java-char-int-conversions" target="_blank" rel="noopener">不是final不能+，c++和c += 1等于c = (char)(c + 1);</a></p>
</li>
<li><p>字符串与字符数组相互<a href="https://blog.csdn.net/MrTreeson/article/details/83746412" target="_blank" rel="noopener">转化方法</a>。</p>
<ol>
<li><p>string.toCharArray()</p>
</li>
<li><p>new String(char) 直接当参数构造</p>
<p>String.valueOf(char)方法构造</p>
</li>
</ol>
</li>
</ul>
<h3 id="解决方案二：双向BFS"><a href="#解决方案二：双向BFS" class="headerlink" title="解决方案二：双向BFS"></a>解决方案二：双向BFS</h3><blockquote>
<p>文件名：LEQS3</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCodeExplore</tag>
        <tag>LeetcodeExploreQ&amp;S</tag>
      </tags>
  </entry>
  <entry>
    <title>KMP算法</title>
    <url>/2020/08/07/LEAS4/</url>
    <content><![CDATA[<h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><h2 id="1-ASCII编码表"><a href="#1-ASCII编码表" class="headerlink" title="1.ASCII编码表"></a>1.<a href="https://www.jianshu.com/p/b4a24355c448" target="_blank" rel="noopener">ASCII编码表</a></h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote>
<p>在计算机中，一个字节可以表示<strong>八位二进制数</strong>，一个二进制数由0和1两种状态，因此一个字节有<strong>256</strong>种状态。如果这 256 中状态每一个都对应一个符号，就能通过 <strong>1 字节的数据表示 256 个字符</strong>。美国人于是就制定了一套编码（其实就是个字典），描述<strong>英语中</strong>的字符和这 8 位二进制数的对应关系，这被称为 ASCII 码</p>
</blockquote>
<p>前128个字符编码英语为确定，后128字符由其他国家定义未定义</p>
<p>强制类型转换遵循ASCII表 ,常用<code>&#39;a&#39; = 97,&#39;A&#39; = 65,0 = 48</code></p>
<h1 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a><a href="https://www.bilibili.com/video/BV1jb411V78H?from=search&seid=10108032066910417231" target="_blank" rel="noopener">KMP算法</a></h1><h2 id="方法一：构造next数组"><a href="#方法一：构造next数组" class="headerlink" title="方法一：构造next数组"></a>方法一：<a href="https://www.bilibili.com/video/BV1Z7411R7eC?p=146" target="_blank" rel="noopener">构造next数组</a></h2><h3 id="核心思想：最长公共前后缀，构造next数组，"><a href="#核心思想：最长公共前后缀，构造next数组，" class="headerlink" title="核心思想：最长公共前后缀，构造next数组，"></a><strong>核心思想</strong>：最长公共前后缀，构造next数组，</h3><p>传统暴力依次匹配进行每一轮匹配时，总是会重复对 A 进行比较。也就是说，对于 S 中的每个字符，我们都需要从 T 第一个位置重新开始比较，并且 S 前面的 A 越多，浪费的时间也就越多。假设 S 的长度为 m，T 的长度为 n，理论上讲，最坏情况下迭代 m−n+1m - n + 1m−n+1 轮，每轮最多进行 n 次比对，一共比较了 (m−n+1)×n次，当 m&gt;n时，渐进时间复杂度为 <strong>O(mn)</strong></p>
<p>KMP 复杂度可降到<strong>O(m+n)</strong></p>
<h4 id="构建next数组"><a href="#构建next数组" class="headerlink" title="构建next数组"></a>构建next数组</h4><p><strong><code>P[i]</code> 对应的下标，为 <code>P[0...i + 1]</code> 的最长公共前缀后缀的长度</strong></p>
<ul>
<li><code>next[0]</code>处为-1 因为第0个字符对应的是长度为1的子串没有更小的字串了不可能产生匹配所以置为-1，不肯配上的值就置为-1，寻找最长子串。</li>
<li>只需要根据模式串构建next数组即可</li>
<li>构建next数组时，当前位置的数值可以参考前一位的数值</li>
</ul>
<img src="/images/LEAS4/image-20200820152013405.png" alt="image-20200820152013405" style="zoom: 67%;" />

<img src="/images/LEAS4/8cd158c08b74130068b580d6d8830ecb700af1e84897ac07a6c533b9c6c0c6a6-8.png" alt="8.png" style="zoom:50%;" />

<h3 id="完整代码一（next数组除第一位外无可回溯目标时置0）"><a href="#完整代码一（next数组除第一位外无可回溯目标时置0）" class="headerlink" title="完整代码一（next数组除第一位外无可回溯目标时置0）"></a>完整代码一（next数组除第一位外无可回溯目标时置0）</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对主串s和模式串t进行KMP模式匹配</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> haystack 主串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> needle 模式串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 若匹配成功，返回needle在haystack中的位置（第一个相同字符对应的位置），若匹配失败，返回-1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(needle.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;	<span class="comment">//needle 为空 返回0</span></span><br><span class="line">        </span><br><span class="line">       	<span class="keyword">char</span>[] s_arr = haystack.toCharArray();	<span class="comment">//转换为好操作的字符数组</span></span><br><span class="line">        <span class="keyword">char</span>[] t_arr = needle.toCharArray();</span><br><span class="line">        <span class="keyword">int</span>[] next = getNextArray(t_arr);		<span class="comment">//创建next数组</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;	<span class="comment">// i 为 主串指针，j 为 模式串指针</span></span><br><span class="line">        <span class="keyword">while</span> (i&lt;s_arr.length &amp;&amp; j&lt;t_arr.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j == -<span class="number">1</span> || s_arr[i]==t_arr[j])&#123;		<span class="comment">//若匹配成功，或者模式串next数组回溯到无匹配子串则主串前进一位且模式串从头匹配</span></span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                j = next[j]; <span class="comment">//模式串指针回溯到最长公共位再进行匹配</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j == t_arr.length)	</span><br><span class="line">            <span class="keyword">return</span> i-j;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 求出一个字符数组的next数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t 字符数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> next数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getNextArray(<span class="keyword">char</span>[] t) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[t.length];</span><br><span class="line">        next[<span class="number">0</span>] = -<span class="number">1</span>;		<span class="comment">// 没有更小的字串了不可能产生匹配所以置为-1</span></span><br><span class="line">        <span class="keyword">int</span> k;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; t.length; j++) &#123;</span><br><span class="line">            k=next[j-<span class="number">1</span>];	<span class="comment">//k 记录前一位的next值 方便下一位next值的确定</span></span><br><span class="line">            <span class="keyword">while</span> (k!=-<span class="number">1</span>) &#123;	<span class="comment">// 一直往前找匹配的最长子串，直到上一位的next值为-1表识没有公共前后缀了为止</span></span><br><span class="line">                <span class="keyword">if</span> (t[j - <span class="number">1</span>] == t[k]) &#123;  <span class="comment">// 找到匹配的</span></span><br><span class="line">                    next[j] = k + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    k = next[k];			<span class="comment">//往前找</span></span><br><span class="line">                &#125;</span><br><span class="line">                next[j] = <span class="number">0</span>;   <span class="comment">//没有公共子串，则置为0，匹配时从模式串开头匹配</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="完整代码二（next数组无可回溯目标都置-1）（mooc）"><a href="#完整代码二（next数组无可回溯目标都置-1）（mooc）" class="headerlink" title="完整代码二（next数组无可回溯目标都置-1）（mooc）"></a>完整代码二（next数组无可回溯目标都置-1）（<a href="https://www.bilibili.com/video/BV1Z7411R7eC?t=500&p=147" target="_blank" rel="noopener">mooc</a>）</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(needle.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">char</span>[] s_arr = haystack.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] t_arr = needle.toCharArray();</span><br><span class="line">        <span class="keyword">int</span>[] next = getNextArray(t_arr);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;s_arr.length &amp;&amp; j&lt;t_arr.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s_arr[i] == t_arr[j])&#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>( j &gt; <span class="number">0</span> ) j = next[j-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> i++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(j == t_arr.length)</span><br><span class="line">            <span class="keyword">return</span> i-j;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getNextArray(<span class="keyword">char</span>[] t) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[t.length];</span><br><span class="line">        next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; t.length; j++) &#123;</span><br><span class="line">            i = next[j-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">while</span>(i&gt;=<span class="number">0</span> &amp;&amp; t[i+<span class="number">1</span>] != t[j])</span><br><span class="line">                i = next[i];</span><br><span class="line">            <span class="keyword">if</span>(t[i+<span class="number">1</span>] == t[j])</span><br><span class="line">                next[j] = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> next[j] = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="方法二：构建影子变量，状态转换"><a href="#方法二：构建影子变量，状态转换" class="headerlink" title="方法二：构建影子变量，状态转换"></a>方法二：构建影子变量，状态转换</h2><h3 id="核心思想：确定状态转换行为"><a href="#核心思想：确定状态转换行为" class="headerlink" title="核心思想：确定状态转换行为"></a>核心思想：确定状态转换行为</h3><p>得明确两个变量，一个是当前的<strong>匹配状态</strong>，另一个是<strong>遇到的字符</strong>；</p>
<p>确定了这两个变量后，就可以知道这个情况下应该转移到哪个状态。</p>
<p>为了描述状态转移图，我们定义一个二维 dp 数组，它的含义如下：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line">dp[j][c] = next</span><br><span class="line"><span class="number">0</span> &lt;= j &lt; M，代表当前的状态</span><br><span class="line"><span class="number">0</span> &lt;= c &lt; <span class="number">256</span>，代表遇到的字符（ASCII 码）</span><br><span class="line"><span class="number">0</span> &lt;= next &lt;= M，代表下一个状态</span><br><span class="line"></span><br><span class="line">dp[<span class="number">4</span>][<span class="string">'A'</span>] = <span class="number">3</span> 表示：</span><br><span class="line">当前是状态 <span class="number">4</span>，如果遇到字符 A，</span><br><span class="line">pat 应该转移到状态 <span class="number">3</span></span><br><span class="line"></span><br><span class="line">dp[<span class="number">1</span>][<span class="string">'B'</span>] = <span class="number">2</span> 表示：</span><br><span class="line">当前是状态 <span class="number">1</span>，如果遇到字符 B，</span><br><span class="line">pat 应该转移到状态 <span class="number">2</span></span><br></pre></td></tr></table></figure></div>

<p>在 <code>pat</code> 匹配 <code>txt</code> 的过程中，只要明确了「当前处在哪个状态」和「遇到的字符是什么」这两个问题，就可以确定应该转移到哪个状态（推进或回退）。</p>
<img src="/images/LEAS4/1.gif" style="zoom:50%;" />

<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(needle.equals(<span class="string">""</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(haystack.equals(<span class="string">""</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 构造KMP中的dp矩阵</span></span><br><span class="line">        <span class="keyword">int</span> m = needle.length();</span><br><span class="line">        <span class="comment">// 各个状态(行)遇到下一个字符(列)跳转到哪个状态</span></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][<span class="number">256</span>]; </span><br><span class="line">        <span class="comment">// 影子状态</span></span><br><span class="line">        <span class="keyword">int</span> X = <span class="number">0</span>;  </span><br><span class="line">        dp[<span class="number">0</span>][needle.charAt(<span class="number">0</span>)] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">256</span>; j++) &#123;</span><br><span class="line">                <span class="comment">//假设下个字符不匹配，此时要回去看影子状态，从而得知跳转到哪个状态</span></span><br><span class="line">                dp[i][j] = dp[X][j];  </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 只有pat上i的字符匹配，跳转到下个状态</span></span><br><span class="line">            dp[i][needle.charAt(i)] = i + <span class="number">1</span>;  </span><br><span class="line">            <span class="comment">// 更新影子状态</span></span><br><span class="line">            X = dp[X][needle.charAt(i)];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 构造dp完成后，开始search</span></span><br><span class="line">        <span class="comment">// 初始状态为0</span></span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; haystack.length(); i++) &#123;</span><br><span class="line">            s = dp[s][haystack.charAt(i)];</span><br><span class="line">            <span class="keyword">if</span> (s == m) &#123;</span><br><span class="line">                <span class="keyword">return</span> i - m + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 匹配失败，返回-1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="双指针解法"><a href="#双指针解法" class="headerlink" title="双指针解法"></a>双指针解法</h1><h3 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L = needle.length(), n = haystack.length();</span><br><span class="line">    <span class="keyword">if</span> (L == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pn = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (pn &lt; n - L + <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">// find the position of the first needle character</span></span><br><span class="line">      <span class="comment">// in the haystack string</span></span><br><span class="line">      <span class="keyword">while</span> (pn &lt; n - L + <span class="number">1</span> &amp;&amp; haystack.charAt(pn) != needle.charAt(<span class="number">0</span>)) ++pn;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// compute the max match string</span></span><br><span class="line">      <span class="keyword">int</span> currLen = <span class="number">0</span>, pL = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> (pL &lt; L &amp;&amp; pn &lt; n &amp;&amp; haystack.charAt(pn) == needle.charAt(pL)) &#123;</span><br><span class="line">        ++pn;</span><br><span class="line">        ++pL;</span><br><span class="line">        ++currLen;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// if the whole needle string is found,</span></span><br><span class="line">      <span class="comment">// return its start position</span></span><br><span class="line">      <span class="keyword">if</span> (currLen == L) <span class="keyword">return</span> pn - L;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// otherwise, backtrack</span></span><br><span class="line">      pn = pn - currLen + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h1 id="子串逐一比较解法"><a href="#子串逐一比较解法" class="headerlink" title="子串逐一比较解法"></a>子串逐一比较解法</h1><h3 id="完整代码-2"><a href="#完整代码-2" class="headerlink" title="完整代码"></a>完整代码</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L = needle.length(), n = haystack.length();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> start = <span class="number">0</span>; start &lt; n - L + <span class="number">1</span>; ++start) &#123;</span><br><span class="line">      <span class="keyword">if</span> (haystack.substring(start, start + L).equals(needle)) &#123;</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="tips"><a href="#tips" class="headerlink" title="tips:"></a>tips:</h3><ol>
<li>String substring(a , b) 不包含b</li>
<li>boolean equals(a , b)</li>
</ol>
<h1 id="Sunday解法（比kmp简单）"><a href="#Sunday解法（比kmp简单）" class="headerlink" title="Sunday解法（比kmp简单）"></a><a href="https://blog.csdn.net/q547550831/article/details/51860017" target="_blank" rel="noopener">Sunday解法（比kmp简单）</a></h1><p>该算法的思路相较于KMP十分容易理解:</p>
<ol>
<li>构建一张偏移表，该表主要记录了模式串中的每一个字符，以及每个字符在模式串中出现的最右位置到尾部的距离+1，未在模式串中出现的字符对应的偏移距离都是”模式串长度+1”。</li>
<li>有了偏移表之后开始比较，用idx作为当前查询索引，每次截取目标字符串的[idx，idx+模式串长度]子串和模式串比较，如果相等则返回idx。</li>
<li>如果不相等，查看子串在目标串中的后一个字符c是否存在于偏移表中，如果存在则idx=idx+偏移表[c]；如果不存在idx=idx+模式串长度。循环直至idx+模式串长度&gt;目标字符串长度。</li>
</ol>
<h3 id="完整代码-3"><a href="#完整代码-3" class="headerlink" title="完整代码"></a>完整代码</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack,String needle)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (needle.equals(<span class="string">""</span>))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> hLen=haystack.length(),nLen=needle.length();</span><br><span class="line">        <span class="keyword">if</span> (hLen&lt;nLen)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"><span class="comment">//        创建偏移表</span></span><br><span class="line">        Map&lt;Character,Integer&gt; offsetMap=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nLen;i++)&#123;</span><br><span class="line">            offsetMap.put(needle.charAt(i),nLen-i);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        开始查找模式串</span></span><br><span class="line">        <span class="keyword">int</span> idx=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//        循环直至idx+模式串长度&gt;目标字符串长度</span></span><br><span class="line">        <span class="keyword">while</span> (idx+nLen&lt;=hLen)&#123;</span><br><span class="line"><span class="comment">//            截取目标字符串</span></span><br><span class="line">            String cutHay = haystack.substring(idx, idx + nLen);</span><br><span class="line"><span class="comment">//            如果子串和模式串相等，则返回idx</span></span><br><span class="line">            <span class="keyword">if</span> (cutHay.equals(needle))&#123;</span><br><span class="line">                <span class="keyword">return</span> idx;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;==【 </span><br><span class="line"><span class="comment">//                边界处理</span></span><br><span class="line">                <span class="keyword">if</span>(idx+nLen&gt;=hLen)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"><span class="comment">//                如果子串在目标串中的后一个字符c是否存在于偏移表中</span></span><br><span class="line">                <span class="keyword">if</span> (offsetMap.containsKey(haystack.charAt(idx+nLen)))&#123;</span><br><span class="line">                    idx+=offsetMap.get(haystack.charAt(idx+nLen));</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    idx+=nLen;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCodeExplore</tag>
        <tag>LeetcodeExploreA&amp;S</tag>
      </tags>
  </entry>
  <entry>
    <title>翻转字符串里的单词</title>
    <url>/2020/08/04/LEAS3/</url>
    <content><![CDATA[<h1 id="题目：-反转字符串里的单词-Medium"><a href="#题目：-反转字符串里的单词-Medium" class="headerlink" title="题目： 反转字符串里的单词   Medium"></a>题目： <a href="https://leetcode-cn.com/problems/reverse-words-in-a-string" target="_blank" rel="noopener">反转字符串里的单词</a>   Medium</h1><h3 id="解决方案一"><a href="#解决方案一" class="headerlink" title="解决方案一"></a>解决方案一</h3><h4 id="解题逻辑：API解决"><a href="#解题逻辑：API解决" class="headerlink" title="解题逻辑：API解决"></a><strong>解题逻辑</strong>：API解决</h4><ul>
<li><p><code>split</code>（拆分），<code>reverse</code>（翻转）和 <code>join</code>（连接）</p>
<p><img src="/images/LEAS3/fun2.png" alt="fig"></p>
</li>
</ul>
<h4 id="代码分析："><a href="#代码分析：" class="headerlink" title="代码分析："></a>代码分析：</h4><h4 id="解决自己问题："><a href="#解决自己问题：" class="headerlink" title="解决自己问题："></a>解决自己问题：</h4><ul>
<li>API String  trim()</li>
<li>API String[] split()</li>
<li>API Collections.reverse(wordList)</li>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#join-java.lang.CharSequence-java.lang.Iterable-" target="_blank" rel="noopener">API</a> String.join((CharSequence delimiter,Iterable&lt;? extends CharSequence&gt; elements)</li>
</ul>
<h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        s = s.trm(); <span class="comment">//去除首位空白字符</span></span><br><span class="line">        List&lt;String&gt; wordList = Arrays.asList(s.split(<span class="string">"\\s+"</span>)); </span><br><span class="line">        <span class="comment">//正则表达式 \s 匹配任何空白字符，包括空格、制表符、换页符等。与 [ \f\n\r\t\v] 等效。</span></span><br><span class="line">        <span class="comment">// + 一次或多次匹配前面的字符或子表达式。</span></span><br><span class="line">        Collections.reverse(wordList);</span><br><span class="line">        <span class="keyword">return</span> String.join(<span class="string">" "</span>,wordList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h4 id="tips"><a href="#tips" class="headerlink" title="tips:"></a>tips:</h4><ul>
<li><p>熟悉api</p>
</li>
<li><p><code>StringUtils.join()</code>与 <code>String.join()</code></p>
<p>参数顺序不一样，另外，StringUtils.join(）可以传入Integer或者其他类型的集合或数组，而String.join()尽可以传入实现charSequence接口类型的集合或数组。</p>
</li>
</ul>
<h3 id="解决方案二"><a href="#解决方案二" class="headerlink" title="解决方案二"></a>解决方案二</h3><h4 id="解题逻辑：无API手动实现"><a href="#解题逻辑：无API手动实现" class="headerlink" title="解题逻辑：无API手动实现"></a><strong>解题逻辑</strong>：无API手动实现</h4><ul>
<li>java的String为不可变</li>
<li>对于不可变字符串转化成其他可变的数据结构，同时还需要在转化的过程中去除空格。</li>
<li>StringBuffer与SringBuilder<a href="https://blog.csdn.net/csxypr/article/details/92378336" target="_blank" rel="noopener">差异</a>前者线程安全后者未加锁</li>
</ul>
<h4 id="代码分析：-1"><a href="#代码分析：-1" class="headerlink" title="代码分析："></a>代码分析：</h4><h4 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> StringBuilder <span class="title">trimSpaces</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="comment">//去除首尾的空格 双指针	</span></span><br><span class="line">        <span class="keyword">int</span> left =<span class="number">0</span>,right = s.length()-<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right &amp;&amp; s.charAt(left)==<span class="string">" "</span>) ++left;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right &amp;&amp; s.charAt(right)==<span class="string">" "</span>) ++right;</span><br><span class="line">        </span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(left);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(c != <span class="string">" "</span>) sb.append(c);</span><br><span class="line">            <span class="comment">//插入空格分割字符，多余空格忽略</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(sb.charAt(sb.length()-<span class="number">1</span>) != <span class="string">" "</span>) sb.apend(C);</span><br><span class="line">            </span><br><span class="line">            ++left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseEachWord</span><span class="params">(StringBuilder sb)</span></span>&#123;</span><br><span class="line">        <span class="comment">//翻转单个单词</span></span><br><span class="line">        <span class="keyword">int</span> n = sb.length();</span><br><span class="line">       	<span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (start &lt; n)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> (end &lt; n &amp;&amp; sb.charAt(end) != <span class="string">" "</span>) ++end;</span><br><span class="line">            </span><br><span class="line">            reverse(sb, start , end-<span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">            start = end + <span class="number">1</span>;</span><br><span class="line">            ++end;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(StringBuilder sb, <span class="keyword">int</span> left ,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="comment">//翻转区间字符</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">char</span> temp = sb.charAt(left);</span><br><span class="line">            sb.setCharAt(left++,sb.charAt(right));</span><br><span class="line">            sb.setCharAt(right--,temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="comment">//翻转单词串，返回结果</span></span><br><span class="line">        StringBuilder sb = trimSpaces(s);</span><br><span class="line">        </span><br><span class="line">        reverse(sb,<span class="number">0</span>,sb.length()-<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        reverseEachWord(sb);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>文件名：LEAS3</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCodeExplore</tag>
        <tag>LeetcodeExploreA&amp;S</tag>
      </tags>
  </entry>
  <entry>
    <title>最长回文子串</title>
    <url>/2020/07/25/LEAS2/</url>
    <content><![CDATA[<h1 id="题目：-最长回文子串-Medium"><a href="#题目：-最长回文子串-Medium" class="headerlink" title="题目： 最长回文子串   Medium"></a>题目： <a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">最长回文子串</a>   Medium</h1><h3 id="解决方案一"><a href="#解决方案一" class="headerlink" title="解决方案一"></a>解决方案一</h3><h4 id="解题逻辑：暴力破解"><a href="#解题逻辑：暴力破解" class="headerlink" title="解题逻辑：暴力破解"></a><strong>解题逻辑</strong>：暴力破解</h4><ul>
<li>暴力破解</li>
</ul>
<h4 id="代码分析："><a href="#代码分析：" class="headerlink" title="代码分析："></a>代码分析：</h4><h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s_len = s.length();</span><br><span class="line">        <span class="keyword">if</span>(s_len &lt;<span class="number">2</span>) <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> maxlen = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[] charArray = s.toCharArray();</span><br><span class="line">		<span class="comment">//枚举所有长度大于1的子串</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s_len - <span class="number">1</span> ; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span> ; j &lt; s_len ; j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j - i + <span class="number">1</span> &gt; maxlen &amp;&amp; validPalindromic(charArray,i,j))&#123;</span><br><span class="line">                        begin = i;</span><br><span class="line">                        maxlen = j - i + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(begin ,begin + maxlen);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validPalindromic</span><span class="params">(<span class="keyword">char</span>[] charArray,<span class="keyword">int</span> begin,<span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//双指针-头尾指针 判断字符串是否为回文子串</span></span><br><span class="line">        <span class="keyword">while</span>(end &gt; begin)&#123;</span><br><span class="line">            <span class="keyword">if</span>(charArray[begin] != charArray[end])</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            begin++;end--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="tips"><a href="#tips" class="headerlink" title="tips:"></a>tips:</h4><ul>
<li><h3 id="解决方案二"><a href="#解决方案二" class="headerlink" title="解决方案二"></a>解决方案二</h3></li>
</ul>
<h4 id="解题逻辑：中心扩散法"><a href="#解题逻辑：中心扩散法" class="headerlink" title="解题逻辑：中心扩散法"></a><strong>解题逻辑</strong>：中心扩散法</h4><ul>
<li>中心扩散法</li>
</ul>
<h4 id="代码分析：-1"><a href="#代码分析：-1" class="headerlink" title="代码分析："></a>代码分析：</h4><h4 id="解决自己问题："><a href="#解决自己问题：" class="headerlink" title="解决自己问题："></a>解决自己问题：</h4><ul>
<li><p>分奇、偶讨论中心点的情况</p>
</li>
<li><p>归纳奇偶中心点起始begin值，向下取整找规律</p>
<p><img src="/images/LEAS2/image-20200802222133300.png" alt="image-20200802222133300"></p>
</li>
</ul>
<h4 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestpalindrome</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">if</span>(len &lt; <span class="number">2</span>) <span class="keyword">return</span> s;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">char</span>[] charArray = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;len-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> oddLen= expandAroundCenter(charArray, i,i);</span><br><span class="line">            <span class="keyword">int</span> evenLen = expandAroundCenter(charArray,i,i+<span class="number">1</span>);</span><br><span class="line">           </span><br><span class="line">            <span class="keyword">int</span> curMaxlen = Math.max(oddLen,evenLen);</span><br><span class="line">         	<span class="comment">//找最长回文子串</span></span><br><span class="line">            <span class="keyword">if</span>(curMaxLen &gt; maxLen)&#123;</span><br><span class="line">                maxLen = curMaxLen;</span><br><span class="line">                begin =  i -(maxlen - <span class="number">1</span> ) / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> s.substring(begin,begin + maxLen );</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expandAroundCenter</span><span class="params">(<span class="keyword">char</span>[] charArray,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> len = charArray.length;</span><br><span class="line">        <span class="keyword">int</span> i = left;</span><br><span class="line">        <span class="keyword">int</span> j = right;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span>&amp;&amp;j&lt;len)&#123;</span><br><span class="line">            <span class="keyword">if</span>(charArray[i] == charArray[j])&#123;</span><br><span class="line">                i--;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//跳出循环时，恰好满足 s.charAt(i) !=s.charAt(j),</span></span><br><span class="line">        <span class="comment">// 回文串长度是 j-i+1-2 =j-i-1</span></span><br><span class="line">        <span class="keyword">return</span> j-i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h4 id="tips-1"><a href="#tips-1" class="headerlink" title="tips:"></a>tips:</h4><ul>
<li><code>char[] charArray = s.toCharArray();</code> 字符串转字符数组</li>
</ul>
<blockquote>
<p>文件名：LAS2</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCodeExplore</tag>
        <tag>LeetcodeExploreA&amp;S</tag>
      </tags>
  </entry>
  <entry>
    <title>长度最小的子数组</title>
    <url>/2020/08/12/LEAD8/</url>
    <content><![CDATA[<h1 id="题目：-209-长度最小的子数组-Medium"><a href="#题目：-209-长度最小的子数组-Medium" class="headerlink" title="题目： 209. 长度最小的子数组  Medium"></a>题目： <a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/" target="_blank" rel="noopener">209. 长度最小的子数组</a>  Medium</h1><h2 id="1-自己构思"><a href="#1-自己构思" class="headerlink" title="1.自己构思"></a>1.自己构思</h2><h3 id="出现问题："><a href="#出现问题：" class="headerlink" title="出现问题："></a>出现问题：</h3><ol>
<li>双指针执行情况判断混乱</li>
</ol>
<h2 id="2-学习题解代码"><a href="#2-学习题解代码" class="headerlink" title="2.学习题解代码"></a>2.学习题解代码</h2><h3 id="解决方案一"><a href="#解决方案一" class="headerlink" title="解决方案一"></a>解决方案一</h3><h4 id="解题逻辑：暴力破解"><a href="#解题逻辑：暴力破解" class="headerlink" title="解题逻辑：暴力破解"></a><strong>解题逻辑</strong>：暴力破解</h4><ul>
<li><code>Integer.MAX_VALUE</code> 表示int类整数的最大值是2的31次方-1</li>
</ul>
<h4 id="代码分析："><a href="#代码分析：" class="headerlink" title="代码分析："></a>代码分析：</h4><h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; j++) &#123;</span><br><span class="line">                sum += nums[j];</span><br><span class="line">                <span class="keyword">if</span> (sum &gt;= s) &#123;</span><br><span class="line">                    ans = Math.min(ans, j - i + <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans == Integer.MAX_VALUE ? <span class="number">0</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="解决方案二"><a href="#解决方案二" class="headerlink" title="解决方案二"></a>解决方案二</h3><h4 id="解题逻辑：双指针"><a href="#解题逻辑：双指针" class="headerlink" title="解题逻辑：双指针"></a><strong>解题逻辑</strong>：双指针</h4><h4 id="代码分析：-1"><a href="#代码分析：-1" class="headerlink" title="代码分析："></a>代码分析：</h4><h4 id="解决自己问题："><a href="#解决自己问题：" class="headerlink" title="解决自己问题："></a>解决自己问题：</h4><ul>
<li>通过移动start指针遍历所有情况</li>
</ul>
<h4 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ans = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (end &lt; n)&#123;</span><br><span class="line">            sum += nums[end];</span><br><span class="line">            <span class="keyword">while</span>(sum &gt;= s) &#123;</span><br><span class="line">                ans = Math.min(ans, end - start + <span class="number">1</span>);</span><br><span class="line">                sum -= nums[start];</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">            end++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans == Integer.MAX_VALUE ? <span class="number">0</span> : ans ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="tips"><a href="#tips" class="headerlink" title="tips:"></a>tips:</h4><ul>
<li>多用 +=，-=</li>
</ul>
<blockquote>
<p>文件名：LEAD8</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCodeExplore</tag>
        <tag>LeetcodeExploreA&amp;S</tag>
      </tags>
  </entry>
  <entry>
    <title>移动零</title>
    <url>/2020/08/17/LEAD12/</url>
    <content><![CDATA[<h1 id="题目：-移动零-Easy"><a href="#题目：-移动零-Easy" class="headerlink" title="题目： 移动零   Easy"></a>题目： <a href="https://leetcode-cn.com/problems/move-zeroes/" target="_blank" rel="noopener">移动零</a>   Easy</h1><h2 id="1-自己构思"><a href="#1-自己构思" class="headerlink" title="1.自己构思"></a>1.自己构思</h2><h3 id="出现问题："><a href="#出现问题：" class="headerlink" title="出现问题："></a>出现问题：</h3><ol>
<li>超过数组上限</li>
<li>结果0在非零元素前面</li>
</ol>
<h3 id="问题解决："><a href="#问题解决：" class="headerlink" title="问题解决："></a>问题解决：</h3><ol>
<li>while循环括号内判断条件按顺序进行,nums[slow]判断放前面超过数组上限，放后面即可</li>
<li>slow指针移动不能快过fast否则会出现后面的slow零元素与前面的fast非零元素互换，导致判断逻辑失败</li>
</ol>
<h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> fast = <span class="number">1</span>; fast &lt; nums.length; fast++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(slow&lt;nums.length &amp;&amp; slow &lt; fast)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[slow] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span>(slow == nums.length - <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(nums[slow] == <span class="number">0</span> &amp;&amp; nums[fast] != <span class="number">0</span>)&#123;</span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">                nums[fast] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="2-学习题解代码"><a href="#2-学习题解代码" class="headerlink" title="2.学习题解代码"></a>2.学习题解代码</h2><h3 id="解决方案一"><a href="#解决方案一" class="headerlink" title="解决方案一"></a>解决方案一</h3><h4 id="解题逻辑：双指针"><a href="#解题逻辑：双指针" class="headerlink" title="解题逻辑：双指针"></a><strong>解题逻辑</strong>：双指针</h4><ul>
<li><p>更加简洁实现自己的思想</p>
<img src="/images/LEAD12/9669b4ffb158eaeeee6f0cd66a70f24411575edab1ab8a037c4c9084b1c743f5-283_1.gif" alt="283_1.gif" style="zoom: 33%;" />

</li>
</ul>
<h4 id="代码分析："><a href="#代码分析：" class="headerlink" title="代码分析："></a>代码分析：</h4><h4 id="解决自己问题："><a href="#解决自己问题：" class="headerlink" title="解决自己问题："></a>解决自己问题：</h4><ul>
<li><code>if (nums[i] != 0) nums[lastNonZeroFoundAt++] = nums[i];</code>      </li>
</ul>
<h4 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(nums==<span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//第一次遍历的时候，j指针记录非0的个数，只要是非0的统统都赋给nums[j]</span></span><br><span class="line">		<span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(nums[i]!=<span class="number">0</span>) &#123;</span><br><span class="line">				nums[j++] = nums[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//非0元素统计完了，剩下的都是0了</span></span><br><span class="line">		<span class="comment">//所以第二次遍历把末尾的元素都赋为0即可</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=j;i&lt;nums.length;++i) &#123;</span><br><span class="line">			nums[i] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="解决方案二"><a href="#解决方案二" class="headerlink" title="解决方案二"></a>解决方案二</h3><h4 id="解题逻辑：一次遍历"><a href="#解题逻辑：一次遍历" class="headerlink" title="解题逻辑：一次遍历"></a><strong>解题逻辑</strong>：一次遍历</h4><ul>
<li>参考快排</li>
<li>快速排序首先要确定一个待分割的元素做中间点<code>x</code>，然后把所有小于等于<code>x</code>的元素放到<code>x</code>的左边，大于x的元素放到其右边。<br>这里我们可以用<code>0</code>当做这个中间点，把不等于<code>0</code>(注意题目没说不能有负数)的放到中间点的左边，等于<code>0</code>的放到其右边。<br>这的中间点就是<code>0</code>本身，所以实现起来比快速排序简单很多，我们使用两个指针<code>i</code>和<code>j</code>，只要<code>nums[i]!=0</code>，我们就交换<code>nums[i]和nums[j]</code></li>
<li><img src="/images/LEAD12/36d1ac5d689101cbf9947465e94753c626eab7fcb736ae2175f5d87ebc85fdf0-283_2.gif" alt="283_2.gif" style="zoom: 33%;" />

</li>
</ul>
<h4 id="代码分析：-1"><a href="#代码分析：-1" class="headerlink" title="代码分析："></a>代码分析：</h4><h4 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a>实现代码</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(nums==<span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//两个指针i和j</span></span><br><span class="line">		<span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++) &#123;</span><br><span class="line">			<span class="comment">//当前元素!=0，就把其交换到左边，等于0的交换到右边</span></span><br><span class="line">			<span class="keyword">if</span>(nums[i]!=<span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">int</span> tmp = nums[i];</span><br><span class="line">				nums[i] = nums[j];</span><br><span class="line">				nums[j++] = tmp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<blockquote>
<p>文件名：LEAD12</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCodeExplore</tag>
        <tag>LeetcodeExploreA&amp;S</tag>
      </tags>
  </entry>
  <entry>
    <title>寻找旋转排序数组中的最小值</title>
    <url>/2020/08/17/LEAD10/</url>
    <content><![CDATA[<h1 id="题目：寻找旋转排序数组中的最小值-Medium"><a href="#题目：寻找旋转排序数组中的最小值-Medium" class="headerlink" title="题目：寻找旋转排序数组中的最小值   Medium"></a>题目：<a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/solution/xun-zhao-xuan-zhuan-pai-lie-shu-zu-zhong-de-zui-xi/" target="_blank" rel="noopener">寻找旋转排序数组中的最小值</a>   Medium</h1><h3 id="解决方案一"><a href="#解决方案一" class="headerlink" title="解决方案一"></a>解决方案一</h3><h4 id="解题逻辑：二分查找"><a href="#解题逻辑：二分查找" class="headerlink" title="解题逻辑：二分查找"></a><strong>解题逻辑</strong>：二分查找</h4><ul>
<li>找到变化点从而判断旋转位置</li>
</ul>
<h4 id="代码分析："><a href="#代码分析：" class="headerlink" title="代码分析："></a>代码分析：</h4><h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[right] &gt; nums[<span class="number">0</span>]) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//二分查找</span></span><br><span class="line">        <span class="keyword">while</span>(right &gt;= left)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right -left)/<span class="number">2</span>; <span class="comment">//防止溢出</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; nums[mid+<span class="number">1</span>]) <span class="keyword">return</span> nums[mid+<span class="number">1</span>]; <span class="comment">//找到变化点，确认最小值</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid-<span class="number">1</span>] &gt; nums[mid]) <span class="keyword">return</span> nums[mid];</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; nums[<span class="number">0</span>])</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">             <span class="keyword">else</span> right = mid - <span class="number">1</span>;                         </span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="tips"><a href="#tips" class="headerlink" title="tips:"></a>tips:</h4><ul>
<li></li>
</ul>
<blockquote>
<p>文件名：LEAD10</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCodeExplore</tag>
        <tag>LeetcodeExploreA&amp;S</tag>
      </tags>
  </entry>
  <entry>
    <title>移除元素</title>
    <url>/2020/08/10/LEAD4/</url>
    <content><![CDATA[<h1 id="题目：-移除元素-Easy"><a href="#题目：-移除元素-Easy" class="headerlink" title="题目： 移除元素  Easy"></a>题目： <a href="https://leetcode-cn.com/problems/remove-element/solution/yi-chu-yuan-su-by-leetcode/" target="_blank" rel="noopener">移除元素</a>  Easy</h1><h2 id="1-自己构思"><a href="#1-自己构思" class="headerlink" title="1.自己构思"></a>1.自己构思</h2><h3 id="解题逻辑：双指针-快慢指针"><a href="#解题逻辑：双指针-快慢指针" class="headerlink" title="解题逻辑：双指针-快慢指针"></a>解题逻辑：双指针-快慢指针</h3><h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> fast=<span class="number">0</span>; fast&lt;nums.length ; fast++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fast] != val)&#123;</span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h2 id="2-学习题解代码"><a href="#2-学习题解代码" class="headerlink" title="2.学习题解代码"></a>2.学习题解代码</h2><h3 id="解决方案一"><a href="#解决方案一" class="headerlink" title="解决方案一"></a>解决方案一</h3><h4 id="解题逻辑：双指针-减少赋值"><a href="#解题逻辑：双指针-减少赋值" class="headerlink" title="解题逻辑：双指针-减少赋值"></a><strong>解题逻辑</strong>：双指针-减少赋值</h4><ul>
<li>当我们遇到 nums[i] = val 时，我们可以将当前元素与<strong>最后一个元素</strong>进行交换，并<strong>释放</strong>最后一个元素。这实际上使数组的大小减少了 1。</li>
</ul>
<h4 id="代码分析："><a href="#代码分析：" class="headerlink" title="代码分析："></a>代码分析：</h4><h4 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == val) &#123;</span><br><span class="line">            nums[i] = nums[n - <span class="number">1</span>];</span><br><span class="line">            <span class="comment">// reduce array size by one</span></span><br><span class="line">            n--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="tips"><a href="#tips" class="headerlink" title="tips:"></a>tips:</h4><ul>
<li></li>
</ul>
<blockquote>
<p>文件名：LEAD4</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCodeExplore</tag>
        <tag>LeetcodeExploreA&amp;S</tag>
      </tags>
  </entry>
  <entry>
    <title>498 对角线遍历 medium</title>
    <url>/2020/06/14/LEA4/</url>
    <content><![CDATA[<h1 id="题目：498-对角线遍历-Medium"><a href="#题目：498-对角线遍历-Medium" class="headerlink" title="题目：498. 对角线遍历 Medium"></a>题目：<a href="https://leetcode-cn.com/problems/diagonal-traverse/" target="_blank" rel="noopener">498. 对角线遍历</a> Medium</h1><h2 id="1-自己构思"><a href="#1-自己构思" class="headerlink" title="1.自己构思"></a>1.自己构思</h2><h3 id="解题思想：模拟过程，寻找临界"><a href="#解题思想：模拟过程，寻找临界" class="headerlink" title="解题思想：模拟过程，寻找临界"></a>解题思想：模拟过程，寻找临界</h3><h3 id="出现问题："><a href="#出现问题：" class="headerlink" title="出现问题："></a>出现问题：</h3><ol>
<li>转向临界值判断出现问题</li>
<li>传入数组为空判断</li>
</ol>
<h3 id="问题解决："><a href="#问题解决：" class="headerlink" title="问题解决："></a>问题解决：</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//模拟遍历过程，寻找临界值</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] findDiagonalOrder(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line">        <span class="keyword">int</span> row = matrix.length;</span><br><span class="line">        <span class="keyword">if</span>(row == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];<span class="comment">//int[0]即表示空；</span></span><br><span class="line">        <span class="keyword">int</span> col = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> Lnum=row*col;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[Lnum];</span><br><span class="line">        <span class="keyword">int</span> m=<span class="number">0</span>;<span class="keyword">int</span> n=<span class="number">0</span>; <span class="keyword">boolean</span> o = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i&lt;Lnum;i++)&#123;</span><br><span class="line">            res[i] = matrix[m][n];</span><br><span class="line">            <span class="keyword">if</span>(o)&#123;                              </span><br><span class="line">                <span class="keyword">if</span>(m!=<span class="number">0</span>&amp;&amp;n&lt;matrix[<span class="number">0</span>].length-<span class="number">1</span>)&#123;</span><br><span class="line">                    m--;n++;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(n&lt;matrix[<span class="number">0</span>].length-<span class="number">1</span>)&#123;</span><br><span class="line">                        o = <span class="keyword">false</span>;</span><br><span class="line">                        n++;</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        o = <span class="keyword">false</span>;</span><br><span class="line">                        m++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(n!=<span class="number">0</span>&amp;&amp;m&lt;matrix.length-<span class="number">1</span>)&#123;</span><br><span class="line">                    m++;n--;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(m&lt;matrix.length-<span class="number">1</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        o = <span class="keyword">true</span>;</span><br><span class="line">                        m++;</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        o = <span class="keyword">true</span>;</span><br><span class="line">                        n++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h2 id="2-学习题解代码"><a href="#2-学习题解代码" class="headerlink" title="2.学习题解代码"></a>2.学习题解代码</h2><h3 id="解决方案一"><a href="#解决方案一" class="headerlink" title="解决方案一"></a>解决方案一</h3><h4 id="解题逻辑："><a href="#解题逻辑：" class="headerlink" title="解题逻辑："></a><strong>解题逻辑</strong>：</h4><ul>
<li><p>解决许多复杂问题的常见策略是首先解决该问题的<strong>简化问题</strong></p>
</li>
<li><p>首先考虑按照<strong>逐条对角线打印元素</strong>，而不考虑翻转的情况。</p>
</li>
<li><p>对于<strong>奇数编号的对角线</strong>，只需要将迭代结果<strong>翻转</strong>再加入结果数组即可</p>
<p><img src="/images/LEA4/img1.png" alt="img"></p>
</li>
</ul>
<h4 id="代码分析："><a href="#代码分析：" class="headerlink" title="代码分析："></a>代码分析：</h4><h4 id="解决自己问题："><a href="#解决自己问题：" class="headerlink" title="解决自己问题："></a>解决自己问题：</h4><ul>
<li><code>if (matrix == null || matrix.length == 0) {return new int[0];}</code>判断传来数组问题</li>
<li>翻转集合更方便 <code>Collections.reverse(intermediate);</code></li>
</ul>
<h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findDiagonalOrder(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Check for empty matrices</span></span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Variables to track the size of the matrix</span></span><br><span class="line">        <span class="keyword">int</span> N = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> M = matrix[<span class="number">0</span>].length;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// The two arrays as explained in the algorithm</span></span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[N*M];</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        ArrayList&lt;Integer&gt; intermediate = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// We have to go over all the elements in the first</span></span><br><span class="line">        <span class="comment">// row and the last column to cover all possible diagonals</span></span><br><span class="line">        <span class="comment">//N+M-1 为总对角线条数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>; d &lt; N + M - <span class="number">1</span>; d++) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Clear the intermediate array every time we start</span></span><br><span class="line">            <span class="comment">// to process another diagonal</span></span><br><span class="line">            intermediate.clear();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// We need to figure out the "head" of this diagonal</span></span><br><span class="line">            <span class="comment">// The elements in the first row and the last column</span></span><br><span class="line">            <span class="comment">// are the respective heads.</span></span><br><span class="line">            <span class="comment">// r临界值从10开始为d-m+1</span></span><br><span class="line">            <span class="comment">//c临界值从10开始都为m-1 </span></span><br><span class="line">            <span class="keyword">int</span> r = d &lt; M ? <span class="number">0</span> : d - M + <span class="number">1</span>;    </span><br><span class="line">            <span class="keyword">int</span> c = d &lt; M ? d : M - <span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Iterate until one of the indices goes out of scope</span></span><br><span class="line">            <span class="comment">// Take note of the index math to go down the diagonal</span></span><br><span class="line">            <span class="comment">//从上到下遍历所有条数</span></span><br><span class="line">            <span class="keyword">while</span> (r &lt; N &amp;&amp; c &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">                </span><br><span class="line">                intermediate.add(matrix[r][c]);</span><br><span class="line">                ++r;</span><br><span class="line">                --c;</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">            <span class="comment">// Reverse even numbered diagonals. The</span></span><br><span class="line">            <span class="comment">// article says we have to reverse odd </span></span><br><span class="line">            <span class="comment">// numbered articles but here, the numbering</span></span><br><span class="line">            <span class="comment">// is starting from 0 :P</span></span><br><span class="line">            <span class="comment">//翻转加入</span></span><br><span class="line">            <span class="keyword">if</span> (d % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                Collections.reverse(intermediate);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; intermediate.size(); i++) &#123;</span><br><span class="line">                result[k++] = intermediate.get(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h4 id="tips"><a href="#tips" class="headerlink" title="tips:"></a>tips:</h4><ul>
<li>return new int[0]；表示返回空数组</li>
</ul>
<blockquote>
<p>文件名：LEA4</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCodeExplore</tag>
        <tag>LeetcodeExploreA&amp;S</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题 01.08.零矩阵 Medium</title>
    <url>/2020/06/11/LEA3/</url>
    <content><![CDATA[<h1 id="题目：-零矩阵-Medium"><a href="#题目：-零矩阵-Medium" class="headerlink" title="题目： 零矩阵 Medium"></a>题目： <a href="https://leetcode-cn.com/problems/zero-matrix-lcci/" target="_blank" rel="noopener">零矩阵</a> Medium</h1><h2 id="1-自己构思"><a href="#1-自己构思" class="headerlink" title="1.自己构思"></a>1.自己构思</h2><h3 id="出现问题："><a href="#出现问题：" class="headerlink" title="出现问题："></a>出现问题：</h3><ol>
<li>线性思维无法解决判断0为原本数据存在的还是后来生成的</li>
</ol>
<h3 id="问题解决："><a href="#问题解决：" class="headerlink" title="问题解决："></a>问题解决：</h3><ol>
<li>思路一：开两个一维数组存放要清理的行列</li>
<li>思路二：需要设零的行i：将该行的第一列元素<code>matrix[i][0]</code>设为0，表示该行需要清零；<br>需要设为零的列j：将该列的第一行元素<code>matrix[0][j]</code>设为0，表示该列需要清零；<br>根据第一行和第一列的标记，进行清零操作</li>
</ol>
<h2 id="2-学习题解代码"><a href="#2-学习题解代码" class="headerlink" title="2.学习题解代码"></a>2.学习<a href="https://leetcode-cn.com/problems/merge-intervals/solution/chi-jing-ran-yi-yan-miao-dong-by-sweetiee/" target="_blank" rel="noopener">题解</a>代码</h2><h3 id="解决方案一"><a href="#解决方案一" class="headerlink" title="解决方案一"></a>解决方案一</h3><h4 id="解题逻辑："><a href="#解题逻辑：" class="headerlink" title="解题逻辑："></a><strong>解题逻辑</strong>：</h4><p>1.开两个一维数组存放要清理的行列，遍历即可</p>
<h4 id="代码分析："><a href="#代码分析：" class="headerlink" title="代码分析："></a>代码分析：</h4><h4 id="解决自己问题："><a href="#解决自己问题：" class="headerlink" title="解决自己问题："></a>解决自己问题：</h4><ul>
<li>问题1</li>
</ul>
<h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span>[] line = <span class="keyword">new</span> <span class="keyword">boolean</span>[matrix.length];</span><br><span class="line">      <span class="keyword">boolean</span>[] column = <span class="keyword">new</span> <span class="keyword">boolean</span>[matrix[<span class="number">0</span>].length];</span><br><span class="line">      <span class="comment">// 找出要清零的行列</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">              <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                  line[i] = <span class="keyword">true</span>;</span><br><span class="line">                  column[j] = <span class="keyword">true</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 开始对行清零</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (line[i]) &#123;</span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                  matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 开始对列清零</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix[<span class="number">0</span>].length; i++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (column[i]) &#123;</span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix.length; j++) &#123;</span><br><span class="line">                  matrix[j][i] = <span class="number">0</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></div>



<h4 id="tips"><a href="#tips" class="headerlink" title="tips:"></a>tips:</h4><ul>
<li><p>两个boolean数组，更加方便针对行列判断</p>
</li>
<li><p>java 对boolean类型默认为false</p>
</li>
<li><p>二维数组 a.length为里面包含的一维数组个数</p>
<p>a[0].length为其中一维数组包含元素个数</p>
</li>
</ul>
<h3 id="解决方案二"><a href="#解决方案二" class="headerlink" title="解决方案二"></a>解决方案二</h3><h4 id="解题逻辑：-1"><a href="#解题逻辑：-1" class="headerlink" title="解题逻辑："></a><strong>解题逻辑</strong>：</h4><p>需要设零的行i：将该行的第一列元素<code>matrix[i][0]</code>设为0，表示该行需要清零；<br>需要设为零的列j：将该列的第一行元素<code>matrix[0][j]</code>设为0，表示该列需要清零；<br>根据第一行和第一列的标记，进行清零操作</p>
<h4 id="代码分析：-1"><a href="#代码分析：-1" class="headerlink" title="代码分析："></a>代码分析：</h4><h4 id="解决自己问题：-1"><a href="#解决自己问题：-1" class="headerlink" title="解决自己问题："></a>解决自己问题：</h4><ul>
<li>问题2</li>
</ul>
<h4 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setZeroes</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> shu = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> hen = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                        hen = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                        shu = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                    matrix[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; matrix[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                    matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; matrix[<span class="number">0</span>].length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[<span class="number">0</span>][i] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; matrix.length; j++) &#123;</span><br><span class="line">                    matrix[j][i] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (shu) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">                matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (hen) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix[<span class="number">0</span>].length; i++) &#123;</span><br><span class="line">                matrix[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h4 id="tips-1"><a href="#tips-1" class="headerlink" title="tips:"></a>tips:</h4><blockquote>
<p>文件名：LEA3</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCodeExplore</tag>
        <tag>LeetcodeExploreA&amp;S</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题 01.07 旋转矩阵 medium</title>
    <url>/2020/06/11/LEA2/</url>
    <content><![CDATA[<h1 id="旋转矩阵-medium"><a href="#旋转矩阵-medium" class="headerlink" title="旋转矩阵 medium"></a><a href="https://leetcode-cn.com/problems/rotate-matrix-lcci/" target="_blank" rel="noopener">旋转矩阵</a> medium</h1><h2 id="1-自己构思"><a href="#1-自己构思" class="headerlink" title="1.自己构思"></a>1.自己构思</h2><p>无法解决：</p>
<ul>
<li>不带开销旋转出错值</li>
</ul>
<p>问题总结： 陷入拿辅助数组copy的思维定势</p>
<h2 id="2-学习题解代码"><a href="#2-学习题解代码" class="headerlink" title="2.学习题解代码"></a>2.学习<a href="https://leetcode-cn.com/problems/merge-intervals/solution/chi-jing-ran-yi-yan-miao-dong-by-sweetiee/" target="_blank" rel="noopener">题解</a>代码</h2><h3 id="解题逻辑："><a href="#解题逻辑：" class="headerlink" title="解题逻辑："></a><strong>解题逻辑</strong>：</h3><p> 观察旋转逻辑给出代码复现思路：【先进行转置然后对每一行以中点进行翻转】</p>
<h3 id="代码分析："><a href="#代码分析：" class="headerlink" title="代码分析："></a>代码分析：</h3><h4 id="解决自己问题："><a href="#解决自己问题：" class="headerlink" title="解决自己问题："></a>解决自己问题：</h4><p>原地翻转一个temp变量即可</p>
<h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.length;</span><br><span class="line">        <span class="comment">// 先以对角线（左上-&gt;右下）为轴进行翻转</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = matrix[i][j];</span><br><span class="line">                matrix[i][j] = matrix[j][i];</span><br><span class="line">                matrix[j][i] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 再对每一行以中点进行翻转</span></span><br><span class="line">        <span class="keyword">int</span> mid = n &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mid; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = matrix[i][j];</span><br><span class="line">                matrix[i][j] = matrix[i][n - <span class="number">1</span> - j];</span><br><span class="line">                matrix[i][n - <span class="number">1</span> - j] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h4 id="tips"><a href="#tips" class="headerlink" title="tips:"></a>tips:</h4><p><code>int mid = n &gt;&gt; 1;</code>:算术右移</p>
<p><img src="/images/LEA2/image-20200611130319775.png" alt="image-20200611130319775"></p>
<blockquote>
<p>文件名：LEA2</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCodeExplore</tag>
        <tag>LeetcodeExploreA&amp;S</tag>
      </tags>
  </entry>
  <entry>
    <title>删除排序数组中的重复项</title>
    <url>/2020/08/17/LEAD11/</url>
    <content><![CDATA[<h1 id="题目：-删除排序数组中的重复项-Easy"><a href="#题目：-删除排序数组中的重复项-Easy" class="headerlink" title="题目： 删除排序数组中的重复项 Easy"></a>题目： 删除排序数组中的重复项 Easy</h1><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="解题逻辑：双指针"><a href="#解题逻辑：双指针" class="headerlink" title="解题逻辑：双指针"></a><strong>解题逻辑</strong>：双指针</h4><h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[j] != nums[i]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            nums[i] = nums[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<blockquote>
<p>文件名：LEAD11</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCodeExplore</tag>
        <tag>LeetcodeExploreA&amp;S</tag>
      </tags>
  </entry>
  <entry>
    <title>杨辉三角 Easy</title>
    <url>/2020/08/10/LEAD9/</url>
    <content><![CDATA[<h1 id="题目：杨辉三角-Easy"><a href="#题目：杨辉三角-Easy" class="headerlink" title="题目：杨辉三角 Easy"></a>题目：杨辉三角 Easy</h1><h3 id="背景知识：杨辉三角"><a href="#背景知识：杨辉三角" class="headerlink" title="背景知识：杨辉三角"></a>背景知识：杨辉三角</h3><ul>
<li>杨辉三角，是<a href="https://baike.baidu.com/item/二项式系数/6763242" target="_blank" rel="noopener">二项式系数</a>在三角形中的一种几何排列</li>
<li>在杨辉三角中，每个数是它左上方和右上方的数的和。</li>
</ul>
<h4 id="解题逻辑：动态规划"><a href="#解题逻辑：动态规划" class="headerlink" title="解题逻辑：动态规划"></a><strong>解题逻辑</strong>：动态规划</h4><h4 id="代码分析："><a href="#代码分析：" class="headerlink" title="代码分析："></a>代码分析：</h4><h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; generate(<span class="keyword">int</span> numRows) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; triangle = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// First base case; if user requests zero rows, they get zero rows.</span></span><br><span class="line">        <span class="keyword">if</span> (numRows == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> triangle;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Second base case; first row is always [1].</span></span><br><span class="line">        triangle.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        triangle.get(<span class="number">0</span>).add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> rowNum = <span class="number">1</span>; rowNum &lt; numRows; rowNum++) &#123;</span><br><span class="line">            List&lt;Integer&gt; row = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            List&lt;Integer&gt; prevRow = triangle.get(rowNum-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// The first row element is always 1.</span></span><br><span class="line">            row.add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Each triangle element (other than the first and last of each row)</span></span><br><span class="line">            <span class="comment">// is equal to the sum of the elements above-and-to-the-left and</span></span><br><span class="line">            <span class="comment">// above-and-to-the-right.</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; rowNum; j++) &#123;</span><br><span class="line">                row.add(prevRow.get(j-<span class="number">1</span>) + prevRow.get(j));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// The last row element is always 1.</span></span><br><span class="line">            row.add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            triangle.add(row);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> triangle;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h4 id="tips"><a href="#tips" class="headerlink" title="tips:"></a>tips:</h4><ul>
<li></li>
</ul>
<blockquote>
<p>文件名：LEAD9</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCodeExplore</tag>
        <tag>LeetcodeExploreA&amp;S</tag>
      </tags>
  </entry>
  <entry>
    <title>反转字符串</title>
    <url>/2020/08/10/LEAD1/</url>
    <content><![CDATA[<h1 id="题目：-反转字符串-Easy"><a href="#题目：-反转字符串-Easy" class="headerlink" title="题目： 反转字符串   Easy"></a>题目： 反转字符串   Easy</h1><h2 id="1-自己构思"><a href="#1-自己构思" class="headerlink" title="1.自己构思"></a>1.自己构思</h2><h3 id="出现问题："><a href="#出现问题：" class="headerlink" title="出现问题："></a>出现问题：</h3><ol>
<li>处理字符数组为空或长度为零情况</li>
</ol>
<h3 id="问题解决："><a href="#问题解决：" class="headerlink" title="问题解决："></a>问题解决：</h3><ol>
<li><p><code>if(s == null || s.length == 0) return;</code> </p>
<p>void 函数 使用return；中断程序执行</p>
</li>
</ol>
<h2 id="2-学习题解代码"><a href="#2-学习题解代码" class="headerlink" title="2.学习题解代码"></a>2.学习题解代码</h2><h3 id="解决方案一"><a href="#解决方案一" class="headerlink" title="解决方案一"></a>解决方案一</h3><h4 id="解题逻辑：双指针"><a href="#解题逻辑：双指针" class="headerlink" title="解题逻辑：双指针"></a><strong>解题逻辑</strong>：双指针</h4><h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(<span class="keyword">char</span>[] s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = s.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;  <span class="comment">//奇数个的时候中间元素不动</span></span><br><span class="line">            <span class="keyword">char</span> temp = s[left];</span><br><span class="line">            s[left] = s[right];</span><br><span class="line">            s[right] = temp;</span><br><span class="line">            left ++;</span><br><span class="line">            right --;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="tips"><a href="#tips" class="headerlink" title="tips:"></a>tips:</h4><ul>
<li></li>
</ul>
<blockquote>
<p>文件名：LEAD1</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCodeExplore</tag>
        <tag>LeetcodeExploreA&amp;S</tag>
      </tags>
  </entry>
  <entry>
    <title>杨辉三角ii</title>
    <url>/2020/08/14/LEAD7/</url>
    <content><![CDATA[<h1 id="题目：-杨辉三角-ii-Easy"><a href="#题目：-杨辉三角-ii-Easy" class="headerlink" title="题目： 杨辉三角 ii  Easy"></a>题目： 杨辉三角 ii  Easy</h1><h2 id="解决方案一"><a href="#解决方案一" class="headerlink" title="解决方案一"></a>解决方案一</h2><h4 id="解题逻辑：双List-迭代构造至所需行数"><a href="#解题逻辑：双List-迭代构造至所需行数" class="headerlink" title="解题逻辑：双List 迭代构造至所需行数"></a><strong>解题逻辑</strong>：双List 迭代构造至所需行数</h4><ul>
<li>动态规划，双List 迭代构造至所需行数</li>
</ul>
<h4 id="代码分析："><a href="#代码分析：" class="headerlink" title="代码分析："></a>代码分析：</h4><h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getRow</span><span class="params">(<span class="keyword">int</span> rowIndex)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; pre = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; cur = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= rowIndex; i++) &#123;</span><br><span class="line">        cur = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">0</span> || j == i) &#123;</span><br><span class="line">                cur.add(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur.add(pre.get(j - <span class="number">1</span>) + pre.get(j));</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        pre = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="优化一"><a href="#优化一" class="headerlink" title="优化一"></a>优化一</h2><h4 id="解题逻辑：单List-覆盖cur"><a href="#解题逻辑：单List-覆盖cur" class="headerlink" title="解题逻辑：单List 覆盖cur"></a><strong>解题逻辑</strong>：单List 覆盖cur</h4><ul>
<li>需要临时变量存储pre 的j处的值</li>
</ul>
<h4 id="代码分析：-1"><a href="#代码分析：-1" class="headerlink" title="代码分析："></a>代码分析：</h4><h4 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getRow</span><span class="params">(<span class="keyword">int</span> rowIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pre = <span class="number">1</span>;</span><br><span class="line">    List&lt;Integer&gt; cur = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    cur.add(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= rowIndex; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = cur.get(j);</span><br><span class="line">            cur.set(j, pre + cur.get(j));</span><br><span class="line">            pre = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.add(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="优化二"><a href="#优化二" class="headerlink" title="优化二"></a>优化二</h2><h4 id="解题逻辑：从后往前获取值，无需temp"><a href="#解题逻辑：从后往前获取值，无需temp" class="headerlink" title="解题逻辑：从后往前获取值，无需temp"></a><strong>解题逻辑</strong>：从后往前获取值，无需temp</h4><h4 id="代码分析：-2"><a href="#代码分析：-2" class="headerlink" title="代码分析："></a>代码分析：</h4><h4 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a>实现代码</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getRow</span><span class="params">(<span class="keyword">int</span> rowIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pre = <span class="number">1</span>;</span><br><span class="line">    List&lt;Integer&gt; cur = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    cur.add(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= rowIndex; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = cur.get(j);</span><br><span class="line">            cur.set(j, pre + cur.get(j));</span><br><span class="line">            pre = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.add(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<blockquote>
<p>文件名：LEAD7</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCodeExplore</tag>
        <tag>LeetcodeExploreA&amp;S</tag>
      </tags>
  </entry>
  <entry>
    <title>最大连续1的个数</title>
    <url>/2020/08/11/LEAD5/</url>
    <content><![CDATA[<h1 id="题目：-最大连续1的个数-Easy"><a href="#题目：-最大连续1的个数-Easy" class="headerlink" title="题目： 最大连续1的个数 Easy"></a>题目： <a href="https://leetcode-cn.com/problems/max-consecutive-ones/" target="_blank" rel="noopener">最大连续1的个数</a> Easy</h1><h2 id="1-自己构思"><a href="#1-自己构思" class="headerlink" title="1.自己构思"></a>1.自己构思</h2><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaxConsecutiveOnes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>,temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> fast = <span class="number">0</span>;fast  &lt; nums.length;fast++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fast] != <span class="number">0</span>)&#123;</span><br><span class="line">                temp++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123; </span><br><span class="line">                temp=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            max = temp &gt; max ? temp : max;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h2 id="2-学习题解代码"><a href="#2-学习题解代码" class="headerlink" title="2.学习题解代码"></a>2.学习题解代码</h2><h3 id="解决方案一"><a href="#解决方案一" class="headerlink" title="解决方案一"></a>解决方案一</h3><h4 id="解题逻辑：双指针-计数器一次遍历"><a href="#解题逻辑：双指针-计数器一次遍历" class="headerlink" title="解题逻辑：双指针-计数器一次遍历"></a><strong>解题逻辑</strong>：双指针-计数器一次遍历</h4><ul>
<li>与自己思路一致</li>
</ul>
<h4 id="代码分析："><a href="#代码分析：" class="headerlink" title="代码分析："></a>代码分析：</h4><h4 id="代码优化："><a href="#代码优化：" class="headerlink" title="代码优化："></a>代码优化：</h4><ul>
<li><p><code>max = temp &gt; max ? temp : max;</code></p>
<p>优化为<code>max = Math.max(max,temp)</code></p>
</li>
</ul>
<h4 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaxConsecutiveOnes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(nums[i] == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// Increment the count of 1's by one.</span></span><br><span class="line">        count += <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Find the maximum till now.</span></span><br><span class="line">        maxCount = Math.max(maxCount, count);</span><br><span class="line">        <span class="comment">// Reset count of 1.</span></span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(maxCount, count);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h4 id="tips"><a href="#tips" class="headerlink" title="tips:"></a>tips:</h4><ul>
<li></li>
</ul>
<blockquote>
<p>文件名：LEAD5</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCodeExplore</tag>
        <tag>LeetcodeExploreA&amp;S</tag>
      </tags>
  </entry>
  <entry>
    <title>HexoProblem1</title>
    <url>/2020/08/11/HexoProblem1/</url>
    <content><![CDATA[<h1 id="Hexo相关问题"><a href="#Hexo相关问题" class="headerlink" title="Hexo相关问题"></a>Hexo相关问题</h1><h2 id="1-部署到gitee样式出现问题"><a href="#1-部署到gitee样式出现问题" class="headerlink" title="1.部署到gitee样式出现问题"></a>1.部署到gitee样式出现问题</h2><p>解答：在_config.yaml中修改</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="HTML"><figure class="iseeu highlight /html"><table><tr><td class="code"><pre><span class="line">url: https://gitee.com/JQ20/JQ20.git</span><br><span class="line">root: /</span><br></pre></td></tr></table></figure></div>

]]></content>
  </entry>
  <entry>
    <title>两数之和 II - 输入有序数组</title>
    <url>/2020/08/10/LEAD3/</url>
    <content><![CDATA[<h1 id="题目：两数之和-II-输入有序数组-Easy"><a href="#题目：两数之和-II-输入有序数组-Easy" class="headerlink" title="题目：两数之和 II - 输入有序数组 Easy"></a>题目：两数之和 II - 输入有序数组 Easy</h1><h2 id="1-自己构思"><a href="#1-自己构思" class="headerlink" title="1.自己构思"></a>1.自己构思</h2><h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l =<span class="number">0</span>;l&lt;numbers.length-<span class="number">1</span>;l++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> h=l+<span class="number">1</span>;h&lt;numbers.length;h++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(numbers[l]+numbers[h]==target)&#123;</span><br><span class="line">                    result[<span class="number">0</span>]=l+<span class="number">1</span>;</span><br><span class="line">                    result[<span class="number">1</span>]=h+<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">return</span> result;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="改进部分"><a href="#改进部分" class="headerlink" title="改进部分"></a>改进部分</h4><ul>
<li>返回数组创建太麻烦，使用 <code>new int[]{low+1,high-1}</code></li>
</ul>
<h2 id="2-学习题解代码"><a href="#2-学习题解代码" class="headerlink" title="2.学习题解代码"></a>2.学习题解代码</h2><h3 id="解决方案一"><a href="#解决方案一" class="headerlink" title="解决方案一"></a>解决方案一</h3><h4 id="解题逻辑：双指针"><a href="#解题逻辑：双指针" class="headerlink" title="解题逻辑：双指针"></a><strong>解题逻辑</strong>：双指针</h4><ul>
<li>设两指针left,right指向<strong>一头一尾</strong>，<ol>
<li>sum&gt;target right–;</li>
<li>sum==target return;</li>
<li>sum&lt;target  left++;</li>
</ol>
</li>
</ul>
<h4 id="代码分析："><a href="#代码分析：" class="headerlink" title="代码分析："></a>代码分析：</h4><h4 id="解决自己问题："><a href="#解决自己问题：" class="headerlink" title="解决自己问题："></a>解决自己问题：</h4><ul>
<li>o(n)复杂度</li>
</ul>
<h4 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = numbers.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = numbers[low] + numbers[high];</span><br><span class="line">            <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;low + <span class="number">1</span>, high + <span class="number">1</span>&#125;;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">                ++low;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                --high;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="tips"><a href="#tips" class="headerlink" title="tips:"></a>tips:</h4><ul>
<li></li>
</ul>
<blockquote>
<p>文件名：LEAD3</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCodeExplore</tag>
        <tag>LeetcodeExploreA&amp;S</tag>
      </tags>
  </entry>
  <entry>
    <title>数组拆分Ⅰ</title>
    <url>/2020/08/10/LEAD2/</url>
    <content><![CDATA[<h1 id="题目：-数组拆分Ⅰ-Easy"><a href="#题目：-数组拆分Ⅰ-Easy" class="headerlink" title="题目： 数组拆分Ⅰ  Easy"></a>题目： 数组拆分Ⅰ  Easy</h1><h2 id="1-自己构思"><a href="#1-自己构思" class="headerlink" title="1.自己构思"></a>1.自己构思</h2><h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">arrayPairSum</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i += <span class="number">2</span>) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="tips"><a href="#tips" class="headerlink" title="tips:"></a>tips:</h4><ul>
<li></li>
</ul>
<blockquote>
<p>文件名：LEAD2</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCodeExplore</tag>
        <tag>LeetcodeExploreA&amp;S</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaStduyRoad</title>
    <url>/2020/06/08/JavaRoad/</url>
    <content><![CDATA[<blockquote class="blockquote-center">本篇总结Java学习资源路线</blockquote>

<ol>
<li>根据JavaGuid<a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/Java基础知识.md">补基础</a>、</li>
<li>重读《Head First  Java》JAVASE</li>
<li>javaweb</li>
</ol>
<blockquote>
<p>文件名：JavaRoad</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaBasics（二）</title>
    <url>/2020/06/13/JB2/</url>
    <content><![CDATA[<blockquote class="blockquote-center"><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.md#2-java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1">Java基本功--JAVA面向对象</a></blockquote>

<h1 id="JAVA面向对象"><a href="#JAVA面向对象" class="headerlink" title="JAVA面向对象"></a>JAVA面向对象</h1><h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><h3 id="面向对象和面向过程的区别"><a href="#面向对象和面向过程的区别" class="headerlink" title="面向对象和面向过程的区别"></a>面向对象和面向过程的区别</h3><ul>
<li><strong>面向过程</strong> ：面向过程<strong>性能</strong>比面向对象<strong>高</strong>。 因为类调用时需要<strong>实例化</strong>，<strong>开销比较大</strong>，比较消耗资源，所以当性能是最重要的考量因素的时候，比如单片机、嵌入式开发、Linux/Unix 等一般采用面向过程开发。但是，<strong>面向过程没有面向对象易维护、易复用、易扩展。</strong></li>
<li><strong>面向对象</strong> ：面向对象<strong>易维护、易复用、易扩展</strong>。 因为面向对象有封装、继承、多态性的特性，所以可以设计出<strong>低耦合</strong>的系统，使系统更加灵活、更加易于维护。但是，<strong>面向对象性能比面向过程低</strong>。</li>
</ul>
<h3 id="【坑】构造器-Constructor-是否可被-override"><a href="#【坑】构造器-Constructor-是否可被-override" class="headerlink" title="【坑】构造器 Constructor 是否可被 override?"></a>【坑】构造器 Constructor 是否可被 override?</h3><p> Constructor 不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况。</p>
<h3 id="【坑】在-Java-中定义一个不做事且没有参数的构造方法的作用"><a href="#【坑】在-Java-中定义一个不做事且没有参数的构造方法的作用" class="headerlink" title="【坑】在 Java 中定义一个不做事且没有参数的构造方法的作用"></a>【坑】在 Java 中定义一个不做事且没有参数的构造方法的作用</h3><p>Java 程序在执行子类的构造方法之前，</p>
<p>如果<strong>没有</strong>用 <code>super()</code>来调用父类特定的构造方法，</p>
<p>则会调用父类中“<strong>没有参数的构造方法</strong>”。</p>
<p>因此，如果父类中只定义了<strong>有参数</strong>的构造方法，而在子类的构造方法中又<strong>没有</strong>用 <code>super()</code>来调用父类中特定的构造方法，</p>
<p>则编译时将发生<strong>错误</strong>，因为 Java 程序在父类中找不到没有参数的构造方法可供执行。</p>
<p><strong>解决办法</strong>是在父类里加上一个不做事且没有参数的构造方法。</p>
<h3 id="成员变量与局部变量的区别有哪些？"><a href="#成员变量与局部变量的区别有哪些？" class="headerlink" title="成员变量与局部变量的区别有哪些？"></a>成员变量与局部变量的区别有哪些？</h3><ol>
<li>从<strong>语法</strong>形式上看:成员变量是<strong>属于类</strong>的，而局部变量是在方法中定义的变量或是<strong>方法的参数</strong>；成员变量可以被 public,private,static 等修饰符所<strong>修饰</strong>，而局部变量不能被访问控制修饰符及 static 所修饰；但是，成员变量和局部变量都能被 <strong>final 所修饰</strong>。</li>
<li>从变量在内存中的存储方式来看:如果成员变量是使用<code>static</code>修饰的，那么这个成员变量是<strong>属于类</strong>的，如果没有使用<code>static</code>修饰，这个成员变量是<strong>属于实例</strong>的。而对象存在于<strong>堆内存</strong>，局部变量则存在于<strong>栈内存</strong>。</li>
<li>从变量在内存中的生存时间上看:成员变量是对象的一部分，它随着<strong>对象的创建而存在</strong>，而局部变量随着方法的调用而<strong>自动消失</strong>。</li>
<li>成员变量如果没有被赋初值:则会自动以类型的默认值而<strong>赋值</strong>（一种情况例外:被 final 修饰的成员变量也必须显式地赋值），而局部变量则<strong>不会自动赋值</strong>。</li>
</ol>
<h3 id="创建一个对象用什么运算符-对象实体与对象引用有何不同"><a href="#创建一个对象用什么运算符-对象实体与对象引用有何不同" class="headerlink" title="创建一个对象用什么运算符?对象实体与对象引用有何不同?"></a>创建一个对象用什么运算符?对象实体与对象引用有何不同?</h3><p><strong>new</strong> 运算符，new 创建对象实例（对象实例在<strong>堆</strong>内存中），对象引用指向对象实例（对象引用存放在<strong>栈</strong>内存中）。一个对象引用可以指向 0 个或 1 个对象（一根绳子可以不系气球，也可以系一个气球）;一个对象可以有 n 个引用指向它（可以用 n 条绳子系住一个气球）。</p>
<h3 id="一个类的构造方法的作用是什么-若一个类没有声明构造方法，该程序能正确执行吗-为什么"><a href="#一个类的构造方法的作用是什么-若一个类没有声明构造方法，该程序能正确执行吗-为什么" class="headerlink" title="一个类的构造方法的作用是什么? 若一个类没有声明构造方法，该程序能正确执行吗? 为什么?"></a>一个类的构造方法的作用是什么? 若一个类没有声明构造方法，该程序能正确执行吗? 为什么?</h3><ul>
<li><p>主要作用：完成对类对象的<strong>初始化</strong>工作</p>
</li>
<li><p>可以执行</p>
<p>有默认的不带参数的构造方法。</p>
<p>如果我们自己添加了类的构造方法（无论是否有参），Java 就不会再添加默认的无参数的构造方法了，这时候，就不能直接 new 一个对象而不传递参数了，所以我们一直在不知不觉地使用构造方法，这也是为什么我们在创建对象的时候后面要加一个括号（因为要调用无参的构造方法）。如果我们<strong>重载</strong>了有参的构造方法，记得都要把<strong>无参的构造方法也写出来</strong>（无论是否用到），因为这可以帮助我们在创建对象的时候少踩坑。</p>
</li>
</ul>
<h4 id="构造方法有哪些特性？"><a href="#构造方法有哪些特性？" class="headerlink" title="构造方法有哪些特性？"></a>构造方法有哪些特性？</h4><ol>
<li>名字与<strong>类名</strong>相同。</li>
<li><strong>没有返回值</strong>，但不能用 void 声明构造函数。</li>
<li>生成类的对象时<strong>自动执行</strong>，无需调用。</li>
</ol>
<h4 id="在调用子类构造方法之前会先调用父类没有参数的构造方法-其目的是"><a href="#在调用子类构造方法之前会先调用父类没有参数的构造方法-其目的是" class="headerlink" title="在调用子类构造方法之前会先调用父类没有参数的构造方法,其目的是?"></a>在调用子类构造方法之前会先调用父类没有参数的构造方法,其目的是?</h4><p>帮助子类做初始化工作。</p>
<h3 id="对象的相等与指向他们的引用相等-两者有什么不同"><a href="#对象的相等与指向他们的引用相等-两者有什么不同" class="headerlink" title="对象的相等与指向他们的引用相等,两者有什么不同?"></a>对象的相等与指向他们的引用相等,两者有什么不同?</h3><ul>
<li><p>对象的相等，比的是内存中存放的<strong>内容</strong>是否相等。</p>
</li>
<li><p>而引用相等，比较的是他们指向的内存<strong>地址</strong>是否相等。</p>
</li>
</ul>
<h2 id="面向对象三大特征"><a href="#面向对象三大特征" class="headerlink" title="面向对象三大特征"></a>面向对象三大特征</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p><strong>封装</strong>：指把一个对象的状态信息（也就是属性）<strong>隐藏</strong>在对象内部，<strong>不允许</strong>外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的<strong>方法</strong>来操作属性</p>
<p><strong>举例</strong>：就好像我们看不到挂在墙上的空调的内部的零件信息（也就是属性），但是可以通过遥控器（方法）来控制空调。如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。就好像如果没有空调遥控器，那么我们就无法操控空凋制冷，空调本身就没有意义了（当然现在还有很多其他方法 ，这里只是为了举例子）。</p>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p><strong>继承</strong>：是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。</p>
<p>作用：通过使用继承，可以快速地创建新的类，可以提高代码的<strong>重用</strong>，程序的<strong>可维护性</strong>，节省大量创建新类的<strong>时间</strong> ，提高我们的<strong>开发效率</strong>。</p>
<p>要点：</p>
<ol>
<li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，<strong>只是拥有</strong>。</li>
<li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li>
<li>子类可以用自己的方式实现父类的方法。。</li>
</ol>
<h3 id="多态【坑】"><a href="#多态【坑】" class="headerlink" title="多态【坑】"></a>多态【坑】</h3><p><strong>多态</strong>，顾名思义，表示一个对象具有多种的状态。</p>
<p>具体表现为<strong>父类</strong>的引用指向<strong>子类</strong>的实例</p>
<p><strong>多态的特点:</strong></p>
<ul>
<li>对象类型和引用类型之间具有继承（类）/实现（接口）的关系；</li>
<li>对象类型不可变，引用类型可变；</li>
<li>方法具有多态性，属性不具有多态性；</li>
<li>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；</li>
<li>多态不能调用“只在<strong>子类存在</strong>但在<strong>父类不存在</strong>”的方法；</li>
<li>如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。</li>
</ul>
<h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><h4 id="在一个静态方法内调用一个非静态成员为什么是非法的"><a href="#在一个静态方法内调用一个非静态成员为什么是非法的" class="headerlink" title="在一个静态方法内调用一个非静态成员为什么是非法的?"></a>在一个静态方法内调用一个非静态成员为什么是非法的?</h4><p>由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员。</p>
<h4 id="静态方法和实例方法有何不同"><a href="#静态方法和实例方法有何不同" class="headerlink" title="静态方法和实例方法有何不同"></a>静态方法和实例方法有何不同</h4><ol>
<li>在外部调用静态方法时，可以使用<strong>“类名.方法名”</strong>的方式，也可以使用<strong>“对象名.方法名”</strong>的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以<strong>无需创建对象</strong>。</li>
<li>静态方法在访问本类的成员时，只允许访问<strong>静态成员</strong>（即静态成员变量和静态方法），而不允许访问<strong>实例成员变量和实例方法</strong>；实例方法则无此限制。</li>
</ol>
<h4 id="常见关键字总结-static-final-this-super"><a href="#常见关键字总结-static-final-this-super" class="headerlink" title="常见关键字总结:static,final,this,super"></a>常见关键字总结:static,final,this,super</h4><p>详见笔主的这篇文章: <a href="https://snailclimb.gitee.io/javaguide/#/docs/java/basic/final,static,this,super2.3.3" target="_blank" rel="noopener">https://snailclimb.gitee.io/javaguide/#/docs/java/basic/final,static,this,super2.3.3</a>. </p>
<h2 id="接口和抽象类【坑】"><a href="#接口和抽象类【坑】" class="headerlink" title="接口和抽象类【坑】"></a>接口和抽象类【坑】</h2><h4 id="接口和抽象类的区别是什么？"><a href="#接口和抽象类的区别是什么？" class="headerlink" title="接口和抽象类的区别是什么？"></a>接口和抽象类的区别是什么？</h4><ol>
<li>接口的方法默认是 public，所有方法在接口中<strong>不能有实现</strong>(Java 8 开始接口方法可以有默认实现），而抽象类可以有非抽象的方法。</li>
<li>接口中除了 static、final 变量，不能有<strong>其他变量</strong>，而抽象类中则不一定。</li>
<li>一个类可以实现多个接口，但只能实现<strong>一个抽象类</strong>。接口自己本身可以通过 extends 关键字扩展多个接口。</li>
<li>接口方法默认修饰符是 public，抽象方法可以有 public、protected 和 default 这些修饰符（抽象方法就是为了被重写所以不能使用 private 关键字修饰！）。</li>
<li>从设计层面来说，抽象是对<strong>类的抽象</strong>，是一种模板设计，而接口是对<strong>行为的抽象</strong>，是一种行为的规范。</li>
</ol>
<h2 id="其它重要知识点"><a href="#其它重要知识点" class="headerlink" title="其它重要知识点"></a>其它重要知识点</h2><h4 id="2-5-1-String-StringBuffer-和-StringBuilder【坑】-的区别是什么-String-为什么是不可变的"><a href="#2-5-1-String-StringBuffer-和-StringBuilder【坑】-的区别是什么-String-为什么是不可变的" class="headerlink" title="2.5.1. String StringBuffer 和 StringBuilder【坑】 的区别是什么? String 为什么是不可变的?"></a>2.5.1. String StringBuffer 和 StringBuilder【坑】 的区别是什么? String 为什么是不可变的?</h4><p>简单的来说：<code>String</code> 类中使用 <strong>final</strong> 关键字修饰字符数组来保存字符串，<code>private final char value[]</code>，所以<code>String</code> 对象是不可变的。</p>
<p>补充（来自<a href="https://github.com/Snailclimb/JavaGuide/issues/675">issue 675</a>）：在 Java 9 之后，String 类的实现改用 byte 数组存储字符串 <code>private final byte[] value</code>;</p>
<p>而 <strong><code>StringBuilder</code></strong> 与 <strong><code>StringBuffer</code></strong> 都继承自 <code>AbstractStringBuilder</code> 类，在 <code>AbstractStringBuilder</code> 中也是使用字符数组保存字符串<code>char[]value</code> 但是<strong>没有用</strong> <code>final</code>关键字修饰，所以这两种对象都是可变的。</p>
<p><strong>线程安全性</strong></p>
<ul>
<li><p><code>String</code> 中的对象是<strong>不可变</strong>的，也就可以理解为常量，线程安全。<code>AbstractStringBuilder</code>是 <code>StringBuilder</code> 与 <code>StringBuffer</code> 的公共父类，定义了一些字符串的基本操作，如 <code>expandCapacity</code>、<code>append</code>、<code>insert</code>、<code>indexOf</code> 等公共方法。</p>
</li>
<li><p><code>StringBuffer</code> 对方法加了同步锁或者对调用的方法加了<strong>同步锁</strong>，所以是线程安全的。</p>
</li>
<li><p><code>StringBuilder</code> 并<strong>没有</strong>对方法进行加同步锁，所以是非线程安全的。</p>
</li>
</ul>
<p><strong>性能</strong>【坑】</p>
<p>每次对 <code>String</code> 类型进行改变的时候，都会生成一个新的 <code>String</code> 对象，然后将指针指向新的 <code>String</code> 对象。<code>StringBuffer</code> 每次都会对 <code>StringBuffer</code> 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 <code>StringBuilder</code> 相比使用 <code>StringBuffer</code> 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p>
<p><strong>对于三者使用的总结：</strong></p>
<ol>
<li>操作少量的数据: 适用 <code>String</code></li>
<li>单线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuilder</code></li>
<li>多线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuffer</code></li>
</ol>
<h4 id="Object-类的常见方法总结【坑】"><a href="#Object-类的常见方法总结【坑】" class="headerlink" title="Object 类的常见方法总结【坑】"></a>Object 类的常见方法总结【坑】</h4><p>Object 类是一个特殊的类，是所有类的父类。它主要提供了以下 11 个方法：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass()<span class="comment">//native方法，用于返回当前运行时对象的Class对象，使用了final关键字修饰，故不允许子类重写。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> <span class="comment">//native方法，用于返回对象的哈希码，主要使用在哈希表中，比如JDK中的HashMap。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span><span class="comment">//用于比较2个对象的内存地址是否相等，String类对该方法进行了重写用户比较字符串的值是否相等。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException<span class="comment">//naitive方法，用于创建并返回当前对象的一份拷贝。一般情况下，对于任何对象 x，表达式 x.clone() != x 为true，x.clone().getClass() == x.getClass() 为true。Object本身没有实现Cloneable接口，所以不重写clone方法并且进行调用的话会发生CloneNotSupportedException异常。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span><span class="comment">//返回类的名字@实例的哈希码的16进制的字符串。建议Object所有的子类都重写这个方法。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span><span class="comment">//native方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span><span class="comment">//native方法，并且不能重写。跟notify一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException<span class="comment">//native方法，并且不能重写。暂停线程的执行。注意：sleep方法没有释放锁，而wait方法释放了锁 。timeout是等待时间。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException<span class="comment">//多了nanos参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上nanos毫秒。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException<span class="comment">//跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123; &#125;<span class="comment">//实例被垃圾回收器回收的时候触发的操作</span></span><br></pre></td></tr></table></figure></div>

<h4 id="与-equals-重要"><a href="#与-equals-重要" class="headerlink" title="== 与 equals(重要)"></a>== 与 equals(重要)</h4><p><strong>==</strong> : 它的作用是判断两个对象的<strong>地址</strong>是不是相等。即，判断两个对象是不是同一个对象(基本数据类型==比较的是值，引用数据类型==比较的是内存地址)。</p>
<p><strong>equals()</strong> : 它的作用也是判断两个对象是否<strong>相</strong>等。但它一般有两种使用情况：</p>
<ul>
<li>情况 1：类<strong>没有覆盖</strong> equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过<strong>“==”</strong>比较这两个对象。</li>
<li>情况 2：类<strong>覆盖了</strong> equals() 方法。一般，我们都覆盖 equals() 方法来比较两个<strong>对象的内容</strong>是否相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。</li>
</ul>
<p><strong>举个例子：</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String a = <span class="keyword">new</span> String(<span class="string">"ab"</span>); <span class="comment">// a 为一个引用</span></span><br><span class="line">        String b = <span class="keyword">new</span> String(<span class="string">"ab"</span>); <span class="comment">// b为另一个引用,对象的内容一样</span></span><br><span class="line">        String aa = <span class="string">"ab"</span>; <span class="comment">// 放在常量池中</span></span><br><span class="line">        String bb = <span class="string">"ab"</span>; <span class="comment">// 从常量池中查找</span></span><br><span class="line">        <span class="keyword">if</span> (aa == bb) <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">"aa==bb"</span>);</span><br><span class="line">        <span class="keyword">if</span> (a == b) <span class="comment">// false，非同一对象</span></span><br><span class="line">            System.out.println(<span class="string">"a==b"</span>);</span><br><span class="line">        <span class="keyword">if</span> (a.equals(b)) <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">"aEQb"</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">42</span> == <span class="number">42.0</span>) &#123; <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">"true"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>说明：</strong></p>
<ul>
<li>String 中的 equals 方法是被<strong>重写</strong>过的，因为 object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是<strong>对象的值</strong>。</li>
<li>当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果<strong>有就把它赋给当前引用</strong>。如果没有就在常量池中重新创建一个 String 对象。</li>
</ul>
<h3 id="hashCode-与-equals-重要"><a href="#hashCode-与-equals-重要" class="headerlink" title="hashCode 与 equals (重要)"></a>hashCode 与 equals (重要)</h3><p>面试官可能会问你：“你重写过 hashcode 和 equals 么，为什么重写 equals 时必须重写 hashCode 方法？”</p>
<h4 id="hashCode（）介绍"><a href="#hashCode（）介绍" class="headerlink" title="hashCode（）介绍"></a>hashCode（）介绍</h4><p>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个 <strong>int 整数</strong>。这个哈希码的作用是确定该对象在哈希表中的<strong>索引位置</strong>。hashCode() 定义在 JDK 的 Object.java 中，这就意味着 Java 中的任何类都包含有 hashCode() 函数。</p>
<p>散列表存储的是<strong>键值对</strong>(key-value)，它的特点是：能根据“<strong>键</strong>”快速的检索出对应的“值”。这其中就利用到了<strong>散列码</strong>！（可以快速找到所需要的对象）</p>
<h4 id="为什么要有-hashCode"><a href="#为什么要有-hashCode" class="headerlink" title="为什么要有 hashCode"></a>为什么要有 hashCode</h4><p><strong>我们先以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode：</strong> 当你把对象加入 <strong>HashSet</strong> 时，HashSet 会先计算对象的 <strong>hashcode</strong> 值来判断对象加入的位置，同时也会与该位置其他已经加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，HashSet 会假设对象没有<strong>重复出现</strong>。但是如果发现有相同 hashcode 值的对象，这时会调用 <code>equals()</code>方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会<strong>重新散列到其他位置</strong>。（摘自我的 Java 启蒙书《Head first java》第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。</p>
<p>通过我们可以看出：<code>hashCode()</code> 的作用就是<strong>获取哈希码</strong>，也称为散列码；它实际上是返回一个 int 整数。这个<strong>哈希码的作用</strong>是确定该对象在哈希表中的索引位置。<strong><code>hashCode()</code>在散列表中才有用，在其它情况下没用</strong>。在散列表中 hashCode() 的作用是获取对象的散列码，进而确定该对象在散列表中的位置。</p>
<h4 id="hashCode（）与-equals（）的相关规定"><a href="#hashCode（）与-equals（）的相关规定" class="headerlink" title="hashCode（）与 equals（）的相关规定"></a>hashCode（）与 equals（）的相关规定</h4><ol>
<li>如果两个对象相等，则 hashcode 一定也是相同的</li>
<li>两个对象相等,对两个对象分别调用 equals 方法都返回 true</li>
<li>两个对象有相同的 hashcode 值，它们也不一定是相等的</li>
<li><strong>因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖</strong></li>
<li>hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</li>
</ol>
<p>推荐阅读：<a href="https://www.cnblogs.com/skywang12345/p/3324958.html" target="_blank" rel="noopener">Java hashCode() 和 equals()的若干问题解答</a></p>
<h3 id="Java-序列化中如果有些字段不想进行序列化，怎么办？【坑】"><a href="#Java-序列化中如果有些字段不想进行序列化，怎么办？【坑】" class="headerlink" title="Java 序列化中如果有些字段不想进行序列化，怎么办？【坑】"></a>Java 序列化中如果有些字段不想进行序列化，怎么办？【坑】</h3><p>对于不想进行序列化的变量，使用 transient 关键字修饰。</p>
<p>transient 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复。transient 只能修饰变量，不能修饰类和方法。</p>
<h3 id="获取用键盘输入常用的两种方法"><a href="#获取用键盘输入常用的两种方法" class="headerlink" title="获取用键盘输入常用的两种方法"></a>获取用键盘输入常用的两种方法</h3><p>方法 1：通过 Scanner</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line">Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">String s  = input.nextLine();</span><br><span class="line">input.close();</span><br></pre></td></tr></table></figure></div>

<p>方法 2：通过 BufferedReader</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line">BufferedReader input = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">String s = input.readLine();</span><br></pre></td></tr></table></figure></div>

<h1 id="Java-核心技术"><a href="#Java-核心技术" class="headerlink" title="Java 核心技术"></a>Java 核心技术</h1><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="Collections-工具类和-Arrays-工具类常见方法总结"><a href="#Collections-工具类和-Arrays-工具类常见方法总结" class="headerlink" title="Collections 工具类和 Arrays 工具类常见方法总结"></a>Collections 工具类和 Arrays 工具类常见方法总结</h3><p>详见笔主的这篇文章: <a href="https://gitee.com/SnailClimb/JavaGuide/blob/master/docs/java/basic/Arrays,CollectionsCommonMethods.md" target="_blank" rel="noopener">https://gitee.com/SnailClimb/JavaGuide/blob/master/docs/java/basic/Arrays,CollectionsCommonMethods.md</a></p>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><h4 id="Java-异常类层次结构图"><a href="#Java-异常类层次结构图" class="headerlink" title="Java 异常类层次结构图"></a>Java 异常类层次结构图</h4><p>图片来自：<a href="https://simplesnippets.tech/exception-handling-in-java-part-1/" target="_blank" rel="noopener">https://simplesnippets.tech/exception-handling-in-java-part-1/</a></p>
<p>图片来自：<a href="https://chercher.tech/java-programming/exceptions-java" target="_blank" rel="noopener">https://chercher.tech/java-programming/exceptions-java</a></p>
<p>在 Java 中，所有的异常都有一个共同的祖先 java.lang 包中的 <strong>Throwable 类</strong>。Throwable： 有两个重要的子类：<strong>Exception（异常）</strong> 和 <strong>Error（错误）</strong> ，二者都是 Java 异常处理的重要子类，各自都包含大量子类。</p>
<p><strong>Error（错误）:是程序无法处理的错误</strong>，表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作无关，而表示代码运行时 <strong>JVM</strong>（Java 虚拟机）出现的问题。例如，Java 虚拟机运行错误（Virtual MachineError），当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</p>
<p>这些错误表示故障发生于虚拟机自身、或者发生在虚拟机试图执行应用时，如 Java 虚拟机运行错误（Virtual MachineError）、类定义错误（NoClassDefFoundError）等。这些错误是<strong>不可查</strong>的，因为它们在应用程序的控制和处理能力之 外，而且绝大多数是程序运行时不允许出现的状况。对于设计合理的应用程序来说，即使确实发生了错误，本质上也不应该试图去处理它所引起的异常状况。在 Java 中，错误通过 Error 的子类描述。</p>
<p><strong>Exception（异常）:是程序本身可以处理的异常</strong>。Exception 类有一个重要的子类 <strong>RuntimeException</strong>。RuntimeException 异常由 Java 虚拟机抛出。<strong>NullPointerException</strong>（要访问的变量没有引用任何对象时，抛出该异常）、<strong>ArithmeticException</strong>（算术运算异常，一个整数除以 0 时，抛出该异常）和 <strong>ArrayIndexOutOfBoundsException</strong> （下标越界异常）。</p>
<p><strong>注意：异常和错误的区别：异常能被程序本身处理，错误是无法处理。</strong></p>
<h3 id="Throwable-类常用方法"><a href="#Throwable-类常用方法" class="headerlink" title="Throwable 类常用方法"></a>Throwable 类常用方法</h3><ul>
<li><strong><code>public string getMessage()</code></strong>:返回异常发生时的简要描述</li>
<li><strong><code>public string toString()</code></strong>:返回异常发生时的详细信息</li>
<li><strong><code>public string getLocalizedMessage()</code></strong>:返回异常对象的本地化信息。使用 <code>Throwable</code>的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 <code>getMessage（）</code>返回的结果相同</li>
<li><strong><code>public void printStackTrace()</code></strong>:在控制台上打印 <code>Throwable</code> 对象封装的异常信息</li>
</ul>
<h3 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h3><ul>
<li><strong>try 块：</strong> 用于捕获异常。其后可接零个或多个 catch 块，如果没有 catch 块，则必须跟一个 finally 块。</li>
<li><strong>catch 块：</strong> 用于处理 try 捕获到的异常。</li>
<li><strong>finally 块：</strong> 无论是否捕获或处理异常，finally 块里的语句都会被执行。当在 try 块或 catch 块中遇到 return 语句时，finally 语句块将在方法返回之前被执行。</li>
</ul>
<p><strong>在以下 4 种特殊情况下，finally 块不会被执行：</strong>【坑】</p>
<ol>
<li>在 finally 语句块第一行发生了异常。 因为在其他行，finally 块还是会得到执行</li>
<li>在前面的代码中用了 System.exit(int)已退出程序。 exit 是带参函数 ；若该语句在异常语句之后，finally 会执行</li>
<li>程序所在的线程死亡。</li>
<li>关闭 CPU。</li>
</ol>
<p>下面这部分内容来自 issue:<a href="https://github.com/Snailclimb/JavaGuide/issues/190。">https://github.com/Snailclimb/JavaGuide/issues/190。</a></p>
<p><strong>注意：</strong> 当 try 语句和 finally 语句中都有 return 语句时，在方法返回之前，finally 语句的内容将被执行，并且 finally 语句的返回值将会覆盖原始的返回值。如下：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> value * value;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (value == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>如果调用 <code>f(2)</code>，返回值将是 0，因为 finally 语句的返回值<strong>覆盖</strong>了 try 语句块的返回值。</p>
<h3 id="使用-try-with-resources-来代替try-catch-finally"><a href="#使用-try-with-resources-来代替try-catch-finally" class="headerlink" title="使用 try-with-resources 来代替try-catch-finally"></a>使用 <code>try-with-resources</code> 来代替<code>try-catch-finally</code></h3><p>《Effecitve Java》中明确指出：</p>
<blockquote>
<p>面对必须要关闭的资源，我们总是应该优先使用<strong>try-with-resources</strong>而不是<code>try-finally</code>。随之产生的代码更简短，更清晰，产生的异常对我们也更有用。<code>try-with-resources</code>语句让我们更容易编写必须要关闭的资源的代码，若采用<code>try-finally</code>则几乎做不到这点。</p>
</blockquote>
<p>Java 中类似于<code>InputStream</code>、<code>OutputStream</code> 、<code>Scanner</code> 、<code>PrintWriter</code>等的资源都需要我们调用<code>close()</code>方法来手动关闭，一般情况下我们都是通过<code>try-catch-finally</code>语句来实现这个需求，如下：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//读取文本文件的内容</span></span><br><span class="line">Scanner scanner = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    scanner = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> File(<span class="string">"D://read.txt"</span>));</span><br><span class="line">    <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">        System.out.println(scanner.nextLine());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (scanner != <span class="keyword">null</span>) &#123;</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>使用Java 7之后的 <code>try-with-resources</code> 语句改造上面的代码:</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (Scanner scanner = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> File(<span class="string">"test.txt"</span>))) &#123;</span><br><span class="line">    <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">        System.out.println(scanner.nextLine());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException fnfe) &#123;</span><br><span class="line">    fnfe.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>当然多个资源需要关闭的时候，使用 <code>try-with-resources</code> 实现起来也非常简单，如果你还是用<code>try-catch-finally</code>可能会带来很多问题。</p>
<p>通过使用分号分隔，可以在<code>try-with-resources</code>块中声明多个资源：</p>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="简述线程、程序、进程的基本概念。以及他们之间关系是什么"><a href="#简述线程、程序、进程的基本概念。以及他们之间关系是什么" class="headerlink" title="简述线程、程序、进程的基本概念。以及他们之间关系是什么?"></a>简述线程、程序、进程的基本概念。以及他们之间关系是什么?</h3><ul>
<li><p><strong>线程</strong>与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生<strong>多个线程</strong>。与进程不同的是同类的多个线程共享<strong>同一块内存空间</strong>和<strong>一组系统资源</strong>，所以系统在产生一个线程，或是在各个线程之间作切换工作时，<strong>负担</strong>要比进程<strong>小</strong>得多，也正因为如此，线程也被称为<strong>轻量级进程</strong>。</p>
</li>
<li><p><strong>程序</strong>是含有<strong>指令和数据</strong>的<strong>文件</strong>，被存储在磁盘或其他的数据存储设备中，也就是说程序是<strong>静态的代码</strong>。</p>
</li>
<li><p><strong>进程</strong>是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。</p>
<p>系统运行一个程序即是一个进程从创建，运行到消亡的过程。简单来说，一个进程就是一个<strong>执行中的程序</strong>，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如 CPU 时间，内存空间，文件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统<strong>载入内存</strong>中。</p>
<p> 线程是进程划分成的<strong>更小的运行单位</strong>。线程和进程最大的不同在于基本上<strong>各进程是独立的</strong>，而<strong>各线程则不一定</strong>，因为同一进程中的线程极有可能会<strong>相互影响</strong>。</p>
<p>从另一角度来说，进程属于操作系统的范畴，主要是同一段时间内，可以同时执行<strong>一个以上的程序</strong>，而线程则是在同一程序内几乎同时执行一<strong>个以上的程序段</strong>。</p>
</li>
</ul>
<h3 id="线程有哪些基本状态"><a href="#线程有哪些基本状态" class="headerlink" title="线程有哪些基本状态?"></a>线程有哪些基本状态?</h3><p>Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态（图源《Java 并发编程艺术》4.1.4 节）。</p>
<p><a href="https://camo.githubusercontent.com/bd21f0c6bf04fe410fa5397897cc47b9278ae5cb/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31392d312d32392f4a6176612545372542412542462545372541382538422545372539412538342545372538412542362545362538302538312e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/bd21f0c6bf04fe410fa5397897cc47b9278ae5cb/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31392d312d32392f4a6176612545372542412542462545372541382538422545372539412538342545372538412542362545362538302538312e706e67" alt="Java线程的状态"></a></p>
<p>线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。Java 线程状态变迁如下图所示（图源《Java 并发编程艺术》4.1.4 节）：</p>
<p><a href="https://camo.githubusercontent.com/88ca089de34d29350d6b72ee1b9e9c8f8f8691f2/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31392d312d32392f4a6176612532302545372542412542462545372541382538422545372538412542362545362538302538312545352538462539382545382542462538312e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/88ca089de34d29350d6b72ee1b9e9c8f8f8691f2/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31392d312d32392f4a6176612532302545372542412542462545372541382538422545372538412542362545362538302538312545352538462539382545382542462538312e706e67" alt="Java线程状态变迁"></a></p>
<p>由上图可以看出：</p>
<p>线程创建之后它将处于 <strong>NEW（新建）</strong> 状态，调用 <code>start()</code> 方法后开始运行，线程这时候处于 <strong>READY（可运行）</strong> 状态。可运行状态的线程获得了 cpu 时间片（timeslice）后就处于 <strong>RUNNING（运行）</strong> 状态。</p>
<blockquote>
<p>操作系统隐藏 Java 虚拟机（JVM）中的 READY 和 RUNNING 状态，它只能看到 RUNNABLE 状态（图源：<a href="https://howtodoinjava.com/" target="_blank" rel="noopener">HowToDoInJava</a>：<a href="https://howtodoinjava.com/java/multi-threading/java-thread-life-cycle-and-thread-states/" target="_blank" rel="noopener">Java Thread Life Cycle and Thread States</a>），所以 Java 系统一般将这两个状态统称为 <strong>RUNNABLE（运行中）</strong> 状态 。</p>
</blockquote>
<p>当线程执行 <code>wait()</code>方法之后，线程进入 <strong>WAITING（等待）</strong>状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态，而 <strong>TIME_WAITING(超时等待)</strong> 状态相当于在等待状态的基础上增加了超时限制，比如通过 <code>sleep（long millis）</code>方法或 <code>wait（long millis）</code>方法可以将 Java 线程置于 TIMED WAITING 状态。当超时时间到达后 Java 线程将会返回到 RUNNABLE 状态。当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到 <strong>BLOCKED（阻塞）</strong> 状态。线程在执行 Runnable 的<code>run()</code>方法之后将会进入到 <strong>TERMINATED（终止）</strong> 状态。</p>
<h1 id="文件与-I-O-流"><a href="#文件与-I-O-流" class="headerlink" title="文件与 I\O 流"></a>文件与 I\O 流</h1><h3 id="Java-中-IO-流分为几种"><a href="#Java-中-IO-流分为几种" class="headerlink" title="Java 中 IO 流分为几种?"></a>Java 中 IO 流分为几种?</h3><ul>
<li>按照流的流向分，可以分为<strong>输入流</strong>和<strong>输出流</strong>；</li>
<li>按照操作单元划分，可以划分为<strong>字节流</strong>和<strong>字符流</strong>；</li>
<li>按照流的角色划分为<strong>节点流</strong>和<strong>处理流</strong>。</li>
</ul>
<p>Java Io 流共涉及 40 多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系， Java I0 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。</p>
<ul>
<li>InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li>
<li>OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li>
</ul>
<p>按操作方式分类结构图：</p>
<p><img src="https://camo.githubusercontent.com/639ec442b39898de071c3e4fd098215fb48f11e9/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f494f2d2545362539332538442545342542442539432545362539362542392545352542432538462545352538382538362545372542312542422e706e67" alt="IO-æä½æ¹å¼åç±»"></p>
<p>按操作对象分类结构图：</p>
<p><a href="https://camo.githubusercontent.com/4a44e49ab13eacac26cbb0e481db73d6d11181b7/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f494f2d2545362539332538442545342542442539432545352541462542392545382542312541312545352538382538362545372542312542422e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/4a44e49ab13eacac26cbb0e481db73d6d11181b7/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f494f2d2545362539332538442545342542442539432545352541462542392545382542312541312545352538382538362545372542312542422e706e67" alt="IO-操作对象分类"></a></p>
<h4 id="既然有了字节流-为什么还要有字符流"><a href="#既然有了字节流-为什么还要有字符流" class="headerlink" title="既然有了字节流,为什么还要有字符流?"></a>既然有了字节流,为什么还要有字符流?</h4><p>问题本质想问：<strong>不管是文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么 I/O 流操作要分为字节流操作和字符流操作呢？</strong></p>
<p>回答：字符流是由 Java 虚拟机将字节转换得到的，问题就出在这个过程还算是非常耗时，并且，如果我们不知道<strong>编码类型</strong>就很容易出现<strong>乱码</strong>问题。所以， I/O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。</p>
<h4 id="BIO-NIO-AIO-有什么区别-【坑】"><a href="#BIO-NIO-AIO-有什么区别-【坑】" class="headerlink" title="BIO,NIO,AIO 有什么区别?【坑】"></a>BIO,NIO,AIO 有什么区别?【坑】</h4><ul>
<li><p><strong>BIO (Blocking I/O):</strong> 同步阻塞 I/O 模式，数据的读取写入必须<strong>阻塞</strong>在一个线程内等待其完成。</p>
<p>在活动连接数不是特别高（小于单机 1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。</p>
</li>
<li><p><strong>NIO (Non-blocking/New I/O):</strong> NIO 是一种<strong>同步非阻塞</strong>的 I/O 模型，在 Java 1.4 中引入了 NIO 框架，对应 java.nio 包，提供了 Channel , Selector，Buffer 等抽象。NIO 中的 N 可以理解为 Non-blocking，不单纯是 New。它支持面向缓冲的，基于通道的 I/O 操作方法。 NIO 提供了与传统 BIO 模型中的 <code>Socket</code> 和 <code>ServerSocket</code> 相对应的 <code>SocketChannel</code> 和 <code>ServerSocketChannel</code> 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞 I/O 来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发</p>
</li>
<li><p><strong>AIO (Asynchronous I/O):</strong> AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的 IO 模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。AIO 是异步 IO 的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO 操作本身是同步的。查阅网上相关资料，我发现就目前来说 AIO 的应用还不是很广泛，Netty 之前也尝试使用过 AIO，不过又放弃了。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>JavaBasics</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaBasics（一）</title>
    <url>/2020/06/09/JB1/</url>
    <content><![CDATA[<blockquote class="blockquote-center"><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.md#1-java-%E5%9F%BA%E6%9C%AC%E5%8A%9F">Java基本功--JAVA入门</a></blockquote>

<h1 id="Java-入门"><a href="#Java-入门" class="headerlink" title="Java 入门"></a>Java 入门</h1><h2 id="JVM-JDK-JRE"><a href="#JVM-JDK-JRE" class="headerlink" title="JVM JDK JRE"></a>JVM JDK JRE</h2><p>Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是<strong>使用相同的字节码</strong>，它们都会给出相同的结果。<strong>字节码</strong>和不同系统的 <strong>JVM</strong> 实现是 Java 语言“一次编译，随处可以运行”的关键所在。</p>
<p><strong>什么是字节码?采用字节码的好处是什么?</strong></p>
<blockquote>
<p>在 Java 中，JVM 可以理解的代码就叫做<code>字节码</code>（即扩展名为 <code>.class</code> 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。</p>
</blockquote>
<p><img src="/images/JB1/image-20200609155856790.png" alt="image-20200609155856790"></p>
<p>【2020/6/12 坑】JIT AOT -&gt; <strong>Java 是编译与解释共存的语言</strong></p>
<h4 id="为什么说-Java-语言“编译与解释并存”？"><a href="#为什么说-Java-语言“编译与解释并存”？" class="headerlink" title="为什么说 Java 语言“编译与解释并存”？"></a>为什么说 Java 语言“编译与解释并存”？</h4><p>高级编程语言按照程序的执行方式分为<strong>编译</strong>型和<strong>解释</strong>型两种。</p>
<p>编译型语言是指编译器针对特定的操作系统将源代码<strong>一次性翻译</strong>成可被该平台执行的<strong>机器码</strong>；</p>
<p>解释型语言是指解释器对源程序逐行解释成特定平台的机器码并<strong>立即执行</strong>。</p>
<p>例子：你想阅读一本英文名著，你可以找一个英文翻译人员帮助你阅读， 有两种选择方式，你可以先等翻译人员将全本的英文名著（也就是源码）都翻译成汉语，再去阅读，也可以让翻译人员翻译一段，你在旁边阅读一段，慢慢把书读完。</p>
<p>Java 语言既具有编译型语言的特征，也具有解释型语言的特征，</p>
<p>因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（*.class 文件），这种字节码必须由 Java 解释器来解释执行。</p>
<p>因此，我们可以认为 Java 语言编译与解释并存。</p>
<h2 id="JDK-amp-JRE"><a href="#JDK-amp-JRE" class="headerlink" title="JDK &amp;JRE"></a>JDK &amp;JRE</h2><p><strong>JDK</strong> 是 Java Development Kit，它是功能齐全的 Java SDK。它拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）。它能够创建和编译程序。<strong>JDK = SDK plus + JRE +…</strong></p>
<p><strong>JRE</strong> 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。但是，它不能用于创建新程序。</p>
<h3 id="Oracle-JDK-和-OpenJDK-的对比"><a href="#Oracle-JDK-和-OpenJDK-的对比" class="headerlink" title="Oracle JDK 和 OpenJDK 的对比"></a>Oracle JDK 和 OpenJDK 的对比</h3><ol>
<li>OpenJDK<strong>完全开源</strong>，Oracle JDK 是 OpenJDK 的一个实现，并<strong>不是完全开源</strong>的；</li>
<li>稳定性： Oracle JDK &gt;  OpenJDK</li>
<li>响应性和 JVM : Oracle JDK &gt; OpenJDK</li>
</ol>
<h3 id="Java-和-C-的区别"><a href="#Java-和-C-的区别" class="headerlink" title="Java 和 C++的区别?"></a>Java 和 C++的区别?</h3><ol>
<li>都是面向对象的语言，都支持封装、继承和多态</li>
<li>Java 不提供指针来直接访问内存，程序内存更加安全</li>
<li>Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承</li>
<li>Java 有自动内存管理机制，不需要程序员手动释放无用内存</li>
<li>在 C 语言中，字符串或字符数组最后都会有一个额外的字符‘\0’来表示结束。但是，Java 语言中<a href="https://blog.csdn.net/sszgg2006/article/details/49148189" target="_blank" rel="noopener">没有结束符这一概念</a>。</li>
</ol>
<h3 id="什么是-Java-程序的主类-应用程序和小程序的主类有何不同-amp-Java-应用程序与小程序之间有哪些差别"><a href="#什么是-Java-程序的主类-应用程序和小程序的主类有何不同-amp-Java-应用程序与小程序之间有哪些差别" class="headerlink" title="什么是 Java 程序的主类 应用程序和小程序的主类有何不同?&amp;Java 应用程序与小程序之间有哪些差别?"></a>什么是 Java 程序的主类 应用程序和小程序的主类有何不同?&amp;Java 应用程序与小程序之间有哪些差别?</h3><p>【2020/6/12 坑】小程序</p>
<p>一个程序中可以有多个类，但只能有一个类是主类。在 Java 应用程序中，这个主类是指包含 main（）方法的类。</p>
<p>而在 Java 小程序中，这个主类是一个继承自系统类 JApplet 或 Applet 的子类。应用程序的主类不一定要求是 public 类，但小程序的主类要求必须是 public 类。</p>
<p>主类是 Java 程序执行的入口点。</p>
<p>简单说应用程序是从主线程启动(也就是 <code>main()</code> 方法)。</p>
<p>applet 小程序没有 <code>main()</code> 方法，主要是嵌在浏览器页面上运行(调用<code>init()</code>或者<code>run()</code>来启动)，嵌入浏览器这点跟 flash 的小游戏类似。</p>
<h3 id="import-java-和-javax-有什么区别？"><a href="#import-java-和-javax-有什么区别？" class="headerlink" title="import java 和 javax 有什么区别？"></a>import java 和 javax 有什么区别？</h3><p>【2020/6/12 坑】</p>
<h2 id="Java-语法"><a href="#Java-语法" class="headerlink" title="Java 语法"></a>Java 语法</h2><h3 id="字符型常量和字符串常量的区别"><a href="#字符型常量和字符串常量的区别" class="headerlink" title="字符型常量和字符串常量的区别?"></a>字符型常量和字符串常量的区别?</h3><ol>
<li><p>形式上: 字符常量是单引号引起<code>&#39; &#39;</code>的<strong>一个字符</strong>; 字符串常量是双引号 <code>&quot; &quot;</code> 引起的<strong>若干个字符</strong></p>
</li>
<li><p>含义上: 字符常量相当于一个<strong>整型值</strong>( ASCII 值),可以参加表达式运算; </p>
<p>字符串常量代表一个<strong>地址值</strong>(该字符串在内存中存放位置)</p>
</li>
<li><p>占内存大小 字符常量只占 2 个字节; 字符串常量占若干个字节 (<strong>注意： char 在 Java 中占两个字节</strong>)</p>
</li>
</ol>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p><strong>若编程语言足够有表达力，就不需要注释，尽量通过代码来阐述</strong></p>
<p>去掉下面复杂的注释，只需要创建一个与注释所言同一事物的函数即可</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// check to see if the employee is eligible for full benefits</span></span><br><span class="line"><span class="keyword">if</span> ((employee.flags &amp; HOURLY_FLAG) &amp;&amp; (employee.age &gt; <span class="number">65</span>))</span><br></pre></td></tr></table></figure></div>

<p>应替换为</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (employee.isEligibleForFullBenefits())</span><br></pre></td></tr></table></figure></div>

<h3 id="标识符和关键字的区别是什么？"><a href="#标识符和关键字的区别是什么？" class="headerlink" title="标识符和关键字的区别是什么？"></a>标识符和关键字的区别是什么？</h3><p>在我们编写程序的时候，需要大量地为程序、类、变量、方法等取名字，于是就有了标识符，简单来说，<strong>标识符就是一个名字</strong>。</p>
<p>但是有一些标识符，Java 语言已经赋予了其特殊的含义，只能<strong>用于特定</strong>的地方，这种特殊的标识符就是<strong>关键字</strong>。因此，<strong>关键字是被赋予特殊含义的标识符</strong>。比如，在我们的日常生活中 ，“警察局”这个名字已经被赋予了特殊的含义，所以如果你开一家店，店的名字不能叫“警察局”，“警察局”就是我们日常生活中的关键字。</p>
<h3 id="【坑】Java泛型了解么？什么是类型擦除？介绍一下常用的通配符？"><a href="#【坑】Java泛型了解么？什么是类型擦除？介绍一下常用的通配符？" class="headerlink" title="【坑】Java泛型了解么？什么是类型擦除？介绍一下常用的通配符？"></a>【坑】Java泛型了解么？什么是类型擦除？介绍一下常用的通配符？</h3><p>【2020/6/12 坑】Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时<strong>类型安全检测机制</strong>，该机制允许程序员在编译时检测到<strong>非法的类型</strong>。泛型的本质是<strong>参数化类型</strong>，也就是说所操作的数据类型被指定为一个参数。</p>
<p><strong>Java的泛型是伪泛型，这是因为Java在编译期间，所有的泛型信息都会被擦掉，这也就是通常所说类型擦除 。</strong> 更多关于类型擦除的问题，可以查看这篇文章：<a href="https://www.cnblogs.com/wuqinglong/p/9456193.html" target="_blank" rel="noopener">《Java泛型类型擦除以及类型擦除带来的问题》</a> 。</p>
<h4 id="泛型一般有三种使用方式-泛型类、泛型接口、泛型方法。"><a href="#泛型一般有三种使用方式-泛型类、泛型接口、泛型方法。" class="headerlink" title="泛型一般有三种使用方式:泛型类、泛型接口、泛型方法。"></a>泛型一般有三种使用方式:泛型类、泛型接口、泛型方法。</h4><p><strong>1.泛型类</strong>：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</span></span><br><span class="line"><span class="comment">//在实例化泛型类时，必须指定T的具体类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;<span class="title">T</span>&gt;</span>&#123; </span><br><span class="line">   </span><br><span class="line">    <span class="keyword">private</span> T key;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Generic</span><span class="params">(T key)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getKey</span><span class="params">()</span></span>&#123; </span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>如何实例化泛型类：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line">Generic&lt;Integer&gt; genericInteger = <span class="keyword">new</span> Generic&lt;Integer&gt;(<span class="number">123456</span>);</span><br></pre></td></tr></table></figure></div>

<p><strong>2.泛型接口</strong> ：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>实现泛型接口，不指定类型： </p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GeneratorImpl</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>实现泛型接口，指定类型：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GeneratorImpl</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>3.泛型方法</strong> ：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt; E &gt; <span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">( E[] inputArray )</span></span></span><br><span class="line"><span class="function"></span>&#123;         </span><br><span class="line">      <span class="keyword">for</span> ( E element : inputArray )&#123;        </span><br><span class="line">         System.out.printf( <span class="string">"%s "</span>, element );</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></div>

<p>使用：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建不同类型数组： Integer, Double 和 Character</span></span><br><span class="line">Integer[] intArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">String[] stringArray = &#123; <span class="string">"Hello"</span>, <span class="string">"World"</span> &#125;;</span><br><span class="line">printArray( intArray  ); </span><br><span class="line">printArray( stringArray  );</span><br></pre></td></tr></table></figure></div>

<h4 id="常用的通配符为：-T，E，K，V，？"><a href="#常用的通配符为：-T，E，K，V，？" class="headerlink" title="常用的通配符为： T，E，K，V，？"></a><strong>常用的通配符为： T，E，K，V，？</strong></h4><ul>
<li>？ 表示不确定的 java 类型</li>
<li>T (type) 表示具体的一个java类型</li>
<li>K V (key value) 分别代表java键值中的Key Value</li>
<li>E (element) 代表Element</li>
</ul>
<p>更多关于Java 泛型中的通配符可以查看这篇文章：<a href="https://juejin.im/post/5d5789d26fb9a06ad0056bd9" target="_blank" rel="noopener">《聊一聊-JAVA 泛型中的通配符 T，E，K，V，？》</a></p>
<h3 id="和equals的区别"><a href="#和equals的区别" class="headerlink" title="==和equals的区别"></a>==和equals的区别</h3><p><strong><code>=</code></strong> : 它的作用是判断两个对象的<strong>地址</strong>是不是相等。即判断两个对象是不是同一个对象。</p>
<p>(<strong>基本数据类型==比较的是值，引用数据类型==比较的是内存地址</strong>)</p>
<blockquote>
<p>因为 Java 只有值传递，所以，对于 == 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。</p>
</blockquote>
<p><strong><code>equals()</code></strong> : 它的作用也是判断两个对象是否相等，它不能用于比较基本数据类型的变量。<code>equals()</code>方法存在于<code>Object</code>类中，而<code>Object</code>类是所有类的直接或间接父类。</p>
<p><code>Object</code>类<code>equals()</code>方法：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="hashCode-与-equals"><a href="#hashCode-与-equals" class="headerlink" title="hashCode()与 equals()"></a>hashCode()与 equals()</h3><h4 id="hashCode-介绍"><a href="#hashCode-介绍" class="headerlink" title="hashCode()介绍"></a><strong>hashCode()</strong>介绍</h4><p><code>hashCode()</code> 的作用是获取哈希码，也称为散列码；它实际上是返回一个 int 整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。</p>
<h4 id="【坑】什么要有-hashCode？"><a href="#【坑】什么要有-hashCode？" class="headerlink" title="【坑】什么要有 hashCode？"></a><strong>【坑】什么要有 hashCode？</strong></h4><p>例子：“<code>HashSet</code> 如何检查重复？”</p>
<p>【2020/6/12 坑：Headfirst java 阅读：hashset】</p>
<ol>
<li>对象加入 <code>HashSet</code></li>
<li><code>HashSet</code> 计算对象的 hashcode 值 判断对象加入的位置， </li>
<li>同时也会与其他已经加入的对象的 hashcode 值作比较，</li>
<li>如果没有相符的 hashcode，<code>HashSet</code> 会假设对象没有重复出现。</li>
<li>但是如果发现有相同 hashcode 值的对象，</li>
<li>这时会调用 equals（）方法来检查 hashcode 相等的对象是否真的相同。</li>
<li>如果两者相同，<code>HashSet</code> 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。【Headfirst java】</li>
</ol>
<ul>
<li>结果：大大减少了 equals 的次数，提高了执行速度。</li>
</ul>
<h4 id="为什么重写-equals-时必须重写-hashCode-方法？"><a href="#为什么重写-equals-时必须重写-hashCode-方法？" class="headerlink" title="为什么重写 equals 时必须重写 hashCode 方法？"></a><strong>为什么重写 <code>equals</code> 时必须重写 <code>hashCode</code> 方法？</strong></h4><p>【2020/6/12 坑】如果两个对象相等，则 hashcode 一定也是相同的。两个对象相等,对两个对象分别调用 equals 方法都返回 true。但是，两个对象有相同的 hashcode 值，它们也不一定是相等的 。<strong>因此，equals 方法被覆盖过，则 <code>hashCode</code> 方法也必须被覆盖。</strong></p>
<blockquote>
<p>文件名：JB1</p>
</blockquote>
<h4 id="为什么两个对象有相同的-hashcode-值，它们也不一定是相等的？"><a href="#为什么两个对象有相同的-hashcode-值，它们也不一定是相等的？" class="headerlink" title="为什么两个对象有相同的 hashcode 值，它们也不一定是相等的？"></a><strong>为什么两个对象有相同的 hashcode 值，它们也不一定是相等的？</strong></h4><p>不同的对象有可能得到相同的 <code>hashCode</code></p>
<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>Java中有8种基本数据类型，分别为：</p>
<ol>
<li>6种数字类型 ：byte、short、int、long、float、double</li>
<li>1种字符类型：char</li>
<li>1中布尔型：boolean。</li>
</ol>
<p>注意：</p>
<ol>
<li>Java 里使用 long 类型的数据一定要在数值后面加上 <strong>L</strong>，否则将作为整型解析：</li>
<li><code>char a = &#39;h&#39;</code>char :单引号，<code>String a = &quot;hello&quot;</code> :双引号</li>
</ol>
<h4 id="自动装箱与拆箱【坑】"><a href="#自动装箱与拆箱【坑】" class="headerlink" title="自动装箱与拆箱【坑】"></a>自动装箱与拆箱【坑】</h4><ul>
<li><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；</li>
<li><strong>拆箱</strong>：将包装类型转换为基本数据类型；</li>
</ul>
<h4 id="8种基本类型的包装类和常量池【坑】"><a href="#8种基本类型的包装类和常量池【坑】" class="headerlink" title="8种基本类型的包装类和常量池【坑】"></a>8种基本类型的包装类和常量池【坑】</h4><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="什么是方法的返回值-返回值在类的方法里的作用是什么"><a href="#什么是方法的返回值-返回值在类的方法里的作用是什么" class="headerlink" title="什么是方法的返回值?返回值在类的方法里的作用是什么?"></a>什么是方法的返回值?返回值在类的方法里的作用是什么?</h3><ul>
<li>方法的返回值：获取到的某个方法体中的代码执行后产生的结果！（前提是该方法可能产生结果）。</li>
<li>返回值的作用：接收出结果，使得它可以用于其他的操作！</li>
</ul>
<h3 id="为什么-Java-中只有值传递？"><a href="#为什么-Java-中只有值传递？" class="headerlink" title="为什么 Java 中只有值传递？"></a>为什么 Java 中只有值传递？</h3><ul>
<li><p>按<strong>值</strong>调用(call by value)表示方法接收的是调用者提供的<strong>值</strong>。</p>
</li>
<li><p>按<strong>引用</strong>调用（call by reference)表示方法接收的是调用者提供的<strong>变量地址</strong>。【<strong>改地址</strong>】</p>
<p>一个方法可以修改传递<strong>引用</strong>所对应的变量值，而不能修改传递<strong>值</strong>调用所对应的变量值。</p>
</li>
<li><p><strong>引用类型</strong>的按<strong>值</strong>传递，传递的是<strong>对象的地</strong>址</p>
</li>
<li><p>引用数据数据类型分为三种：<strong>① 接口 ② 类 ③ 数组</strong></p>
</li>
<li><p>对象引用是按<strong>值</strong>传递</p>
</li>
</ul>
<h3 id="【坑】重载和重写的区别"><a href="#【坑】重载和重写的区别" class="headerlink" title="【坑】重载和重写的区别"></a>【坑】重载和重写的区别</h3><blockquote>
<p>重载就是同样的一个方法能够根据<strong>输入数据的不同</strong>，做出<strong>不同的处理</strong></p>
<p>重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要<strong>覆盖父类方法</strong></p>
</blockquote>
<ul>
<li><strong>重载</strong>就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。</li>
<li><strong>重写</strong>就是子类对父类方法的重新改造，外部样子不能改变，<strong>内部逻辑可以改变</strong>。</li>
</ul>
<p>【坑 2020/6/13 重写不懂】</p>
<h3 id="深拷贝-vs-浅拷贝"><a href="#深拷贝-vs-浅拷贝" class="headerlink" title="深拷贝 vs 浅拷贝"></a>深拷贝 vs 浅拷贝</h3><ol>
<li><strong>浅拷贝</strong>：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝，此为浅拷贝。</li>
<li><strong>深拷贝</strong>：对基本数据类型进行值传递，对引用数据类型，<strong>创建一个新的对象，并复制其内容</strong>，此为深拷贝。</li>
</ol>
<h3 id="方法的四种类型"><a href="#方法的四种类型" class="headerlink" title="方法的四种类型"></a>方法的四种类型</h3><p>1、无参数无返回值的方法</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 无参数无返回值的方法(如果方法没有返回值，不能不写，必须写void，表示没有返回值)</span><br><span class="line">public void f1() &#123;</span><br><span class="line">    System.out.println(&quot;无参数无返回值的方法&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>2、有参数无返回值的方法</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* 有参数无返回值的方法</span><br><span class="line">* 参数列表由零组到多组“参数类型+形参名”组合而成，多组参数之间以英文逗号（,）隔开，形参类型和形参名之间以英文空格隔开</span><br><span class="line">*&#x2F;</span><br><span class="line">public void f2(int a, String b, int c) &#123;</span><br><span class="line">    System.out.println(a + &quot;--&gt;&quot; + b + &quot;--&gt;&quot; + c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>3、有返回值无参数的方法</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 有返回值无参数的方法（返回值可以是任意的类型,在函数里面必须有return关键字返回对应的类型）</span><br><span class="line">public int f3() &#123;</span><br><span class="line">    System.out.println(&quot;有返回值无参数的方法&quot;);</span><br><span class="line">    return 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>4、有返回值有参数的方法</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 有返回值有参数的方法</span><br><span class="line">public int f4(int a, int b) &#123;</span><br><span class="line">    return a * b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>5、return 在无返回值方法的特殊使用</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; return在无返回值方法的特殊使用</span><br><span class="line">public void f5(int a) &#123;</span><br><span class="line">    if (a&gt;10) &#123;</span><br><span class="line">    return;&#x2F;&#x2F;表示结束所在方法 （f5方法）的执行,下方的输出语句不会执行</span><br><span class="line">&#125;</span><br><span class="line">    System.out.println(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>JavaBasics</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello Hexo</title>
    <url>/2020/06/07/hellohexo/</url>
    <content><![CDATA[<p>搭建完个人博客主站，主要参考以下网站：</p>
<ol>
<li><p><a href="https://tding.top/archives/aad98408.html" target="_blank" rel="noopener">小丁主题美化 </a></p>
</li>
<li><p><a href="https://blog.juanertu.com/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/page/3/" target="_blank" rel="noopener">ConstOwn主题美化</a></p>
</li>
<li><p><a href="https://blog.csdn.net/qq_32623363/article/details/100524856?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase" target="_blank" rel="noopener">Typora写博客</a></p>
</li>
<li><p><a href="https://hasaik.com/posts/ab21860c.html" target="_blank" rel="noopener">很详细的教程博客</a></p>
</li>
</ol>
<p>后续美化升级可以按照1，2来。</p>
<h1 id="hexo-常用操作"><a href="#hexo-常用操作" class="headerlink" title="hexo 常用操作"></a>hexo 常用操作</h1><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">hexo deploy &#x2F;&#x2F;部署到服务器上</span><br></pre></td></tr></table></figure></div>



<blockquote>
<p>文件名：hellohexo</p>
</blockquote>
]]></content>
      <categories>
        <category>Hexo_NexT配置</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
